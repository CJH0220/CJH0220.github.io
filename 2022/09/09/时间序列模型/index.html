<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>时间序列模型 | CJH's blog</title><meta name="keywords" content="时间序列"><meta name="author" content="CJH"><meta name="copyright" content="CJH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="原文出处 时间序列（按照时间排序的一组随机变量）_百度百科 (baidu.com) 时间序列基础知识 - 知乎 (zhihu.com) 一 二 三 时间序列(ARIMA)案例超详细讲解1时间序列是按照一定的时间间隔排列的一组数据，其时间间隔可以是任意的时间单位，如小时、日、周月等。通过对这些时间序列的分析，从中发现和揭示现象发展变化的规律，并将这些知识和信息用于预测。 想象一下，你的任务是：根据已">
<meta property="og:type" content="article">
<meta property="og:title" content="时间序列模型">
<meta property="og:url" content="http://cjh0220.github.io/2022/09/09/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="CJH&#39;s blog">
<meta property="og:description" content="原文出处 时间序列（按照时间排序的一组随机变量）_百度百科 (baidu.com) 时间序列基础知识 - 知乎 (zhihu.com) 一 二 三 时间序列(ARIMA)案例超详细讲解1时间序列是按照一定的时间间隔排列的一组数据，其时间间隔可以是任意的时间单位，如小时、日、周月等。通过对这些时间序列的分析，从中发现和揭示现象发展变化的规律，并将这些知识和信息用于预测。 想象一下，你的任务是：根据已">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/08/vqpCng.jpg">
<meta property="article:published_time" content="2022-09-09T01:44:24.000Z">
<meta property="article:modified_time" content="2022-09-09T01:45:11.121Z">
<meta property="article:author" content="CJH">
<meta property="article:tag" content="时间序列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/09/08/vqpCng.jpg"><link rel="shortcut icon" href="/img/CJH.png"><link rel="canonical" href="http://cjh0220.github.io/2022/09/09/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '时间序列模型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-09 09:45:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/09/08/vbOo6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2022/09/08/vqpCng.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CJH's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">时间序列模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-09T01:44:24.000Z" title="发表于 2022-09-09 09:44:24">2022-09-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-09T01:45:11.121Z" title="更新于 2022-09-09 09:45:11">2022-09-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="时间序列模型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://bbs.spsspro.com/news/129">原文出处</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/时间序列/1389644">时间序列（按照时间排序的一组随机变量）_百度百科 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/349897496">时间序列基础知识 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://smilecoc.vip/2021/01/15/time_series_part1_introduction_and_models/">一</a></p>
<p><a target="_blank" rel="noopener" href="http://smilecoc.vip/2021/01/15/time_series_part2_stability/">二</a></p>
<p><a target="_blank" rel="noopener" href="http://smilecoc.vip/2021/01/15/time_series_part3_arima_models/">三</a></p>
<h1 id="时间序列-ARIMA-案例超详细讲解"><a href="#时间序列-ARIMA-案例超详细讲解" class="headerlink" title="时间序列(ARIMA)案例超详细讲解"></a>时间序列(ARIMA)案例超详细讲解</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间序列是按照一定的时间间隔排列的一组数据，其时间间隔可以是任意的时间单位，如小时、日、周月等。通过对这些时间序列的分析，从中发现和揭示现象发展变化的规律，并将这些知识和信息用于预测。</span><br></pre></td></tr></table></figure>
<p>想象一下，你的任务是：根据已有的历史时间数据，预测未来的趋势走向。作为一个数据分析师，你会把这类问题归类为什么？当然是时间序列建模。</p>
<p>从预测一个产品的销售量到估计每天产品的用户数量，时间序列预测是任何数据分析师都应该知道的核心技能之一。常用的时间序列模型有很多种，在本文中主要研究ARIMA模型，也是实际案例中最常用的模型，这种模型主要针对平稳非白噪声序列数据。</p>
<h3 id="时间序列概念"><a href="#时间序列概念" class="headerlink" title="时间序列概念"></a>时间序列概念</h3><p>时间序列是按照一定的时间间隔排列的一组数据，其时间间隔可以是任意的时间单位，如小时、日、周月等。通过对这些时间序列的分析，从中发现和揭示现象发展变化的规律，并将这些知识和信息用于预测。比如销售量是上升还是下降，是否可以通过现有的数据预测未来一年的销售额是多少等。</p>
<p>构成要素：长期趋势，季节变动，循环变动，不规则变动。</p>
<p>1）<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/长期趋势/6458640">长期趋势</a>（T）现象在较长时期内受某种根本性因素作用而形成的总的变动趋势。</p>
<p>2）<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/季节变动/1700201">季节变动</a>（S）现象在一年内随着季节的变化而发生的有规律的周期性变动。</p>
<p>3）<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/循环变动/6427021">循环变动</a>（C）现象以若干年为周期所呈现出的波浪起伏形态的有规律的变动。</p>
<p>4）<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/不规则变动/9661423">不规则变动</a>（I）是一种无规律可循的变动，包括严格的随机变动和不规则的突发性影响很大的变动两种类型。</p>
<p><strong>时间数列的组合模型</strong></p>
<p>1加法模型：Y=T+S+C+I（Y,T计量单位相同的总量指标）（S,C,I对长期趋势产生的或正或负的偏差）</p>
<p>2乘法模型：Y=T·S·C·I（常用模型）（Y,T计量单位相同的总量指标）（S,C,I对原数列指标增加或减少的百分比）</p>
<h2 id="1-ARIMA（差分自回归移动平均模型）简介"><a href="#1-ARIMA（差分自回归移动平均模型）简介" class="headerlink" title="1 ARIMA（差分自回归移动平均模型）简介"></a>1 ARIMA（差分自回归移动平均模型）简介</h2><p><img src="https://bbs.spsspro.com/api/v2/files/1412" alt="image.png"></p>
<p>模型的一般形式如下式所示：</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1413" alt="image.png"></p>
<h3 id="1-1-适用条件"><a href="#1-1-适用条件" class="headerlink" title="1.1 适用条件"></a>1.1 适用条件</h3><p>数据序列是平稳的，这意味着均值和方差不应随时间而变化。通过对数变换或差分可以使序列平稳。</p>
<p>输入的数据必须是单变量序列，因为ARIMA利用过去的数值来预测未来的数值。</p>
<h3 id="1-2-分量解释"><a href="#1-2-分量解释" class="headerlink" title="1.2 分量解释"></a>1.2 分量解释</h3><p>AR(自回归项)、I(差分项)和MA(移动平均项)：</p>
<p>AR项是指用于预测下一个值的过去值。AR项由ARIMA中的参数p定义。p值是由PACF图确定的。</p>
<p>MA项定义了预测未来值时过去预测误差的数目。ARIMA中的参数q代表MA项。ACF图用于识别正确的q值</p>
<p>差分顺序规定了对序列执行差分操作的次数，对数据进行差分操作的目的是使之保持平稳。ADF可以用来确定序列是否是平稳的，并有助于识别d值。</p>
<h3 id="1-3-模型基本步骤"><a href="#1-3-模型基本步骤" class="headerlink" title="1.3 模型基本步骤"></a>1.3 模型基本步骤</h3><h4 id="1-31-序列平稳化检验，确定d值"><a href="#1-31-序列平稳化检验，确定d值" class="headerlink" title="1.31 序列平稳化检验，确定d值"></a>1.31 序列平稳化检验，确定d值</h4><p>对序列绘图，进行 ADF 检验，观察序列是否平稳（一般为不平稳）；对于非平稳时间序列要先进行 d 阶差分，转化为平稳时间序列</p>
<h4 id="1-32-确定p值和q值"><a href="#1-32-确定p值和q值" class="headerlink" title="1.32 确定p值和q值"></a>1.32 确定p值和q值</h4><p>(1)p 值可从偏自相关系数（PACF）图的最大滞后点来大致判断，q 值可从自相关系数（ACF）图的最大滞后点来大致判断</p>
<p>(2)遍历搜索AIC和BIC最小的参数组合</p>
<h4 id="1-33-拟合ARIMA模型-p-d-q"><a href="#1-33-拟合ARIMA模型-p-d-q" class="headerlink" title="1.33 拟合ARIMA模型 (p,d,q)"></a>1.33 拟合ARIMA模型 (p,d,q)</h4><h4 id="1-34-预测未来的值"><a href="#1-34-预测未来的值" class="headerlink" title="1.34 预测未来的值"></a>1.34 预测未来的值</h4><h2 id="2-案例介绍及操作"><a href="#2-案例介绍及操作" class="headerlink" title="2 案例介绍及操作"></a>2 案例介绍及操作</h2><p>基于 1985-2021年某杂志的销售量，预测某商品的未来五年的销售量。</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1414" alt="image.png"></p>
<h3 id="2-1-序列平稳化检验，确定d值"><a href="#2-1-序列平稳化检验，确定d值" class="headerlink" title="2.1 序列平稳化检验，确定d值"></a>2.1 序列平稳化检验，确定d值</h3><p><strong>平稳性概念</strong></p>
<p>假定某个时间序列是由一系列随机过程生成的，即假定时间序列的每一个数值都是从一个概率分布中随机得到，如果满足下列条件：</p>
<p>均值u是与时间t无关的常数；</p>
<p>方差是与时间t无关的常数；</p>
<p>协方差是只与时间间隔K有关，与时间t无关的常数</p>
<p>则称该随机时间序列是平稳的，而该随机过程是平稳随机过程。</p>
<p><strong>ADF思路</strong></p>
<p>白噪声的过程是：</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1415" alt="image.png"></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1416" alt="image.png"></p>
<p>对于白噪声序列，基本是在均值附近较为平均的随机震荡。它满足正态分布，均值与方差都是与时间t无关的函数，它满足平稳性要求。</p>
<p><strong>随机游走的过程是：</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1417" alt="image.png"></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1418" alt="image.png"></p>
<p>对于随机游走，可以看到比白噪声平滑很多，并且呈现出一些“趋势性”的感觉。它的均值为0，方差与时间t有关，他不满足平稳性要求。</p>
<p>而随机游走的一阶差分是平稳的：</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1419" alt="image.png"></p>
<p>如果一个时间序列是非平稳的，它常常可以通过取差分的方法而形成平稳序列。</p>
<p>ADF 大致的思想就是基于随机游走的，对回归，如果发现p=1，说明序列满足随机游走，就是非平稳的。</p>
<p>下图是通过spsspro软件生成：</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1420" alt="image.png"></p>
<p><strong>如何确定该序列是否平稳呢？</strong></p>
<p><strong>（1）临界值检验</strong></p>
<p>临界值1%、5%、10%不同程度拒绝原假设的统计值和假设检验值t进行比较，t同时小于1%、5%、10%即说明非常好地拒绝该假设</p>
<p><strong>（2）显著性检验p&lt;0.05</strong></p>
<p>本数据中，原序列的 ADF 假设检验值t为1.814， 大于三个level的统计值，所以是非平稳的。而一阶差分序列的 ADF 假设检验值t为-3.156，小于三个level的统计值，再来看显著性p的值为0.023&lt;0.05，所以是平稳的。</p>
<p>经过二阶差分，与一阶差分相比，只是在显著性程度上扩大了，因此对于该序列，采用一阶差分比较合适。一般情况下，采用一阶、二阶差分就可以使序列变得平稳。</p>
<p>所以差分阶数d=1</p>
<h3 id="2-2-确定p值和q值"><a href="#2-2-确定p值和q值" class="headerlink" title="2.2 确定p值和q值"></a>2.2 确定p值和q值</h3><h4 id="2-21-绘制ACF-、PACF图"><a href="#2-21-绘制ACF-、PACF图" class="headerlink" title="2.21 绘制ACF 、PACF图"></a>2.21 绘制ACF 、PACF图</h4><p>先来介绍几个概念：</p>
<p>拖尾和截尾</p>
<p>拖尾，顾名思义，就是序列缓慢衰减，“尾巴”慢慢拖着滑下来，或者震荡衰减</p>
<p>而截尾则是突然截断了，像个悬崖，指序列从某个时点变得非常小</p>
<p>专业点来说呢，就是：</p>
<p>如果样本自相关系数和样本偏自相关系数在最初的阶明显大于2倍标准差（下图虚线），而后几乎95%的系数都落在2倍标准差的范围内，且非零系数衰减为小值波动的过程非常突然，通常视为k阶截尾。</p>
<p>如果有超过5%的样本相关系数大于2倍标准差，或者非零系数衰减为小值波动的过程比较缓慢或连续，通常视为拖尾。</p>
<p>自相关系数（ACF）</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1421" alt="image.png"></p>
<p>自相关系数度量的是同一事件在两个不同时期之间的相关程度，形象的讲就是度量自己过去的行为对自己现在的影响。在这里可以通过自相关系数（ACF）图的最大滞后点来大致判断q 值。</p>
<p>偏自相关系数（PACF）</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1422" alt="image.png"></p>
<p>计算某一个要素对另一个要素的影响或相关程度时，把其他要素的影响视为常数，即暂不考虑其他要素的影响，而单独研究那两个要素之间的相互关系的密切程度时，称为偏相关。在这里可以通过偏自相关系数（PACF）图的最大滞后点来大致判断p 值。</p>
<p>下图是通过spsspro软件生成：</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1423" alt="image.png"> 差分数据自相关图（ACF）</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1424" alt="image.png"> 差分数据偏自相关图（PACF）</p>
<p>从上图可以看到：趋势序列 ACF 有 1 阶截尾，PACF 有 1 阶截尾尾。因此可以选 p=1， q=1。</p>
<p>通过拖尾和截尾对模型定阶，具有很强的主观性。</p>
<h4 id="2-22-AIC、BIC准则"><a href="#2-22-AIC、BIC准则" class="headerlink" title="2.22 AIC、BIC准则"></a>2.22 AIC、BIC准则</h4><p>AIC 准则全称是最小化信息量准则</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1425" alt="image.png"></p>
<p>其中 L 表示模型的极大似然函数， K 表示模型参数个数。</p>
<p>当样本容量很大时，采用BIC贝叶斯信息准则</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1426" alt="image.png"></p>
<p>其中 n 表示样本容量。</p>
<p>通过比较不同差分阶数的AIC、BIC的值，取两者最小值p、q</p>
<p>从评价准则的结果看：p = 0， q = 1 时，两者值最小，AIC为251.973，BIC为256.724。</p>
<h3 id="2-3-拟合ARIMA模型-p-d-q"><a href="#2-3-拟合ARIMA模型-p-d-q" class="headerlink" title="2.3 拟合ARIMA模型 (p,d,q)"></a>2.3 拟合ARIMA模型 (p,d,q)</h3><p>由上述步骤，我们已知d=1，p=0，q=1，故拟合模型为ARIMA（0,1,1）</p>
<p>采用多元线性回归，得到y(t)=4.996+0.671*ε(t-1)</p>
<h3 id="2-4-预测"><a href="#2-4-预测" class="headerlink" title="2.4 预测"></a>2.4 预测</h3><p>使用该公式，得到未来五年的杂志销量分别为285.097、290.093、295.089、300.085、305.081。</p>
<h2 id="3-案例工具实现"><a href="#3-案例工具实现" class="headerlink" title="3 案例工具实现"></a>3 案例工具实现</h2><h3 id="3-1使用工具"><a href="#3-1使用工具" class="headerlink" title="3.1使用工具"></a>3.1使用工具</h3><p>SPSSPRO—&gt;【预测模型—&gt;时间序列分析（ARIMA）】</p>
<h4 id="3-11-案例操作"><a href="#3-11-案例操作" class="headerlink" title="3.11 案例操作"></a>3.11 案例操作</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1427" alt="image.png"></p>
<p>Step1：新建分析；</p>
<p>Step2：上传数据；</p>
<p>Step3：选择对应数据打开后进行预览，确认无误后点击开始分析；</p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1428" alt="image.png"></p>
<p>step4：选择【时间序列分析（ARIMA）】；</p>
<p>step5：查看对应的数据数据格式，【时间序列分析（ARIMA）】要求输入１个时间序列数据定量变量。</p>
<p>step6：选择向后预测的期数。</p>
<p>step7：点击【开始分析】，完成全部操作。</p>
<h4 id="3-12-分析结果解读"><a href="#3-12-分析结果解读" class="headerlink" title="3.12 分析结果解读"></a>3.12 分析结果解读</h4><p>以下生成的结果来源于SPSSPRO软件的分析结果导出，SPSSPRO输出的结果中会给出智能解读结果，直接查看智能分析：</p>
<p><strong>输出结果 1：ADF 检验表</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1429" alt="image.png"></p>
<p>图表说明：该序列检验的结果显示，基于字段年度销量:</p>
<p>在差分为 0 阶时，显著性 P 值为 0.998，水平上不要呈现显著性，不能拒绝原假设，该序列为不平稳的时间序列。在差分为 1 阶时，显著性 P 值为 0.023，水平上呈现显著性，拒绝原假设，该序列为平稳的时间序列。</p>
<p>在差分为 2 阶时，显著性 P 值为 0.000，水平上呈现显著性，拒绝原假设，该序列为平稳的时间序列。</p>
<p>（注意：在理论上，足够多的差分运算可以充分提取原时间序列中的非平稳确定性信息。但进行差分运算需要注意的是，差分运算的阶数不是越多越好。差分是对信息的提取、加工的过程，每次差分都会有信息的损失，所以差分的阶数需要适当，以免过度差分。）</p>
<p><strong>输出结果 2：最佳差分序列图</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1430" alt="image.png"></p>
<p>图表说明：由于一阶差分后序列进行单位根检验的 P 值小于 0.05，说明一阶差分后序列是平稳数据，上图展示了原始数据 1 阶差分后的时序图。</p>
<p><strong>输出结果 3：最终差分数据自相关图（ACF）</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1431" alt="image.png"></p>
<p>图表说明：由自相关图可知，一阶自相关系数很明显地大于 2 倍标准差范围，自一阶自相关系数后，其余自相关系数都在 2 倍标准差范围以内，我们可以判断自相关图为截尾。</p>
<p><strong>输出结果 4：最终差分数据偏自相关图（PACF）</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1432" alt="image.png"></p>
<p>图表说明：由偏自相关图可知，一阶偏自相关系数很明显地大于 2 倍标准差范围，自一阶偏自相关系数后，其余自相关系数都在 2 倍标准差范围以内，我们可以判断偏自相关图为截尾。</p>
<p><strong>输出结果 5：模型参数表</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1433" alt="image.png"></p>
<p>图表说明：由于通过自相关分析和偏自相关分析来判断 ARIMA 的参数存在人为主观性，SPSSPRO 基于 AIC 信息准则自动寻找最优参数，模型结果为 ARIMA 模型（0,1,1）检验表，基于字段：年度销量，从 Q 统计量结果分析可以得到：Q6 在水平上不呈现显著性，不能拒绝模型的残差为白噪声序列的假设，同时模型的拟合优度 R2 为 0.981，模型表现优秀，模型基本满足要求。（注意：一般来说，只检验前 6 期和前 12 延迟的 Q 统计量（即 Q6 和 Q12）就可得出残差是否是随机序列的结论。这是因为平稳序列通常具有短期相关性，如果一个短期延迟序列值之间不存在显著的相关关系，通常延迟之间就更不会存在显著的相关关系。）</p>
<p><strong>输出结果 6：模型残差自相关图（ACF）</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1434" alt="image.png"></p>
<p>图表说明：上图展示了模型的残差自相关图，（ACF）若相关系数均在虚线（2 倍标准差）内，自回归模型（AR）残差为白噪声序列，时间序列要求模型残差为白噪声序列。很明显，残差的自相关系数均在虚线内。</p>
<p><strong>输出结果 7：模型残差偏自相关图（PACF）</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1435" alt="image.png"></p>
<p>图表说明：上图展示了模型的残差偏自相关图（PACF），若相关系数均在虚线内，滑动平均模型（MA）残差为白噪声序列，时间序列要求模型残差为白噪声序列。很明显，残差的大部分偏自相关系数均在虚线内，即便第 9 阶与第 14 阶超过了 2 倍标准差，这可能是由于偶然因素引起的。</p>
<p><strong>输出结果 8：模型检验表</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1436" alt="image.png"></p>
<p>图表说明：基于字段年度销量，SPSSPRO 基于 AIC 信息准则自动寻找最优参数，模型结果为 ARIMA 模型（0,1,1）检验表且基于 1 差分数据，模型公式如下：y(t)=4.996+0.671*ε(t-1)</p>
<p><strong>输出结果 9：时间序列图</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1437" alt="image.png"></p>
<p>图表说明：上图表示了该时间序列模型的原始数据图、模型拟合值、模型预测值。从图可知，拟合序列趋势与真实序列趋势有着极大的相似性，说明拟合效果较好。</p>
<p><strong>输出结果 10：时间序列预测表</strong></p>
<p><img src="https://bbs.spsspro.com/api/v2/files/1438" alt="image.png"></p>
<p>图表说明：上表显示了时间序列模型最近 5 期数据预测情况。</p>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h2><p>ARIMA 是用于单变量时间序列数据预测的最广泛使用方法之一，模型十分简单，只需要内生变量而不需要借助其他外生变量，但是，采用ARIMA模型预测时序，数据必须是稳定的，如果不稳定的数据，是无法捕捉到规律的。比如股票数据用ARIMA无法预测的原因就是股票数据是非稳定的，常常受政策和新闻的影响而波动。</p>
<h1 id="时间序列（一）：时间序列数据与时间序列预测模型"><a href="#时间序列（一）：时间序列数据与时间序列预测模型" class="headerlink" title="时间序列（一）：时间序列数据与时间序列预测模型"></a>时间序列（一）：时间序列数据与时间序列预测模型</h1><h2 id="朴素法"><a href="#朴素法" class="headerlink" title="朴素法"></a>朴素法</h2><p>朴素法就是<strong>预测值等于实际观察到的最后一个值</strong>。它假设数据是平稳且没有趋势性与季节性的。通俗来说就是以后的预测值都等于最后的值。</p>
<p>这种方法很明显适用情况极少，所以我们重点通过这个方法来熟悉一下数据可视化与模型的评价及其相关代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#朴素法</span></span><br><span class="line">dd = np.asarray(train[<span class="string">&#x27;Count&#x27;</span>])<span class="comment">#训练组数据</span></span><br><span class="line">y_hat = test.copy()<span class="comment">#测试组数据</span></span><br><span class="line">y_hat[<span class="string">&#x27;naive&#x27;</span>] = dd[<span class="built_in">len</span>(dd) - <span class="number">1</span>]<span class="comment">#预测组数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">plt.plot(train.index, train[<span class="string">&#x27;Count&#x27;</span>], label=<span class="string">&#x27;Train&#x27;</span>)</span><br><span class="line">plt.plot(test.index, test[<span class="string">&#x27;Count&#x27;</span>], label=<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line">plt.plot(y_hat.index, y_hat[<span class="string">&#x27;naive&#x27;</span>], label=<span class="string">&#x27;Naive Forecast&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Naive Forecast&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>得到结果：<br><img src="https://img-blog.csdnimg.cn/202009202338285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjkyMzg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们通过计算均方根误差，检查模型在测试数据集上的准确率。<br>其中均方根误差（RMSE）是各数据偏离真实值的距离平方和的平均数的开方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算均方根误差RMSE</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"><span class="comment"># mean_squared_error求均方误差</span></span><br><span class="line">rmse = sqrt(mean_squared_error(test[<span class="string">&#x27;Count&#x27;</span>], y_hat[<span class="string">&#x27;naive&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span>(rmse)</span><br></pre></td></tr></table></figure>
<p>得到均方根误差为1053</p>
<h2 id="简单平均法"><a href="#简单平均法" class="headerlink" title="简单平均法"></a>简单平均法</h2><p>简单平均法就是<strong>预测的值为之前过去所有值的平均</strong>.当然这不会很准确，但这种预测方法在某些情况下效果是最好的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简单平均法</span></span><br><span class="line">y_hat_avg = test.copy()</span><br><span class="line">y_hat_avg[<span class="string">&#x27;avg_forecast&#x27;</span>] = train[<span class="string">&#x27;Count&#x27;</span>].mean()</span><br></pre></td></tr></table></figure>
<p>其后续可视化与模型效果评估方法与上述一致，这里不再赘述，需要详细代码可以查看相关源码。得到RMSE值为2637</p>
<h2 id="移动平均法"><a href="#移动平均法" class="headerlink" title="移动平均法"></a>移动平均法</h2><p>我们经常会遇到这种数据集，比如价格或销售额某段时间大幅上升或下降。如果我们这时用之前的简单平均法，就得使用所有先前数据的平均值，但在这里使用之前的所有数据是说不通的，因为用开始阶段的价格值会大幅影响接下来日期的预测值。因此，我们只取最近几个时期的价格平均值。很明显这里的逻辑是只有最近的值最要紧。这种用<strong>某些窗口期计算平均值</strong>的预测方法就叫移动平均法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移动平均法</span></span><br><span class="line">y_hat_avg = test.copy()</span><br><span class="line"><span class="comment">#利用时间窗函数rolling求平均值u</span></span><br><span class="line">y_hat_avg[<span class="string">&#x27;moving_avg_forecast&#x27;</span>] = train[<span class="string">&#x27;Count&#x27;</span>].rolling(<span class="number">60</span>).mean().iloc[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>其后续可视化与模型效果评估方法与上述一致，这里不再赘述，需要详细代码可以查看相关源码。得到RMSE值为1121</p>
<h2 id="指数平滑法"><a href="#指数平滑法" class="headerlink" title="指数平滑法"></a>指数平滑法</h2><p>在做时序预测时，一个显然的思路是：认为离着预测点越近的点，作用越大。比如我这个月体重100斤，去年某个月120斤，显然对于预测下个月体重而言，这个月的数据影响力更大些。</p>
<p>假设随着时间变化权重以指数方式下降——最近为0.8，然后0.8<strong>2，0.8</strong>3…，最终年代久远的数据权重将接近于0。将<strong>权重按照指数级进行衰减</strong>，这就是指数平滑法的基本思想。</p>
<p>指数平滑法有几种不同形式：一次指数平滑法针对没有趋势和季节性的序列，二次指数平滑法针对有趋势但没有季节性的序列，三次指数平滑法针对有趋势也有季节性的序列。“</p>
<p>所有的指数平滑法都要更新上一时间步长的计算结果，并使用当前时间步长的数据中包含的新信息。它们通过”混合“新信息和旧信息来实现，而相关的新旧信息的权重由一个可调整的参数来控制。</p>
<h3 id="一次指数平滑"><a href="#一次指数平滑" class="headerlink" title="一次指数平滑"></a>一次指数平滑</h3><p>一次指数平滑法的递推关系如下：</p>
<script type="math/tex; mode=display">
S_i = ax_i + (1 - a)s_{i-1},其中a \in (0, 1)</script><p>其中,$s_i$是时间步长i（理解为第i个时间点）上经过的平滑后的值，$x_i$是这个时间步长上的实际数据。</p>
<p>$a$可以是0，1之间的任意值，他控制的新旧信息之间的平衡：a接近1保留当前数据点，a接近0时，保留前面的平滑值。其递推关系式：</p>
<script type="math/tex; mode=display">
s_i = \alpha \sum_{j=0}^{i}(1-\alpha)^{j} x_{i-j}</script><p>可以看出，在指数平滑法中，所有先前的观测值都对当前的平滑值产生了影响，但它们所起的作用随着参数 α 的幂的增大而逐渐减小。那些相对较早的观测值所起的作用相对较小。同时，称α为记忆衰减因子可能更合适——因为α的值越大，模型对历史数据“遗忘”的就越快。从某种程度来说，指数平滑法就像是拥有无限记忆（平滑窗口足够大）且权值呈指数级递减的移动平均法。一次指数平滑</p>
<script type="math/tex; mode=display">
x_{i+h} = s_i</script><p>si已经是最后一个算出来的值，h等于1代表预测的下一个值。</p>
<p>我们可以通过statsmodels中的时间序列模型进行指数平滑建模。官方文档地址为：<br><a target="_blank" rel="noopener" href="https://www.statsmodels.org/stable/generated/statsmodels.tsa.holtwinters.SimpleExpSmoothing.html">https://www.statsmodels.org/stable/generated/statsmodels.tsa.holtwinters.SimpleExpSmoothing.html</a><br>具体代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一次指数平滑</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.api <span class="keyword">import</span> SimpleExpSmoothing</span><br><span class="line"> </span><br><span class="line">y_hat_avg = test.copy()</span><br><span class="line">fit = SimpleExpSmoothing(np.asarray(train[<span class="string">&#x27;Count&#x27;</span>])).fit(smoothing_level=<span class="number">0.6</span>, optimized=<span class="literal">False</span>)</span><br><span class="line">y_hat_avg[<span class="string">&#x27;SES&#x27;</span>] = fit.forecast(<span class="built_in">len</span>(test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>, <span class="number">8</span>))</span><br><span class="line">plt.plot(train[<span class="string">&#x27;Count&#x27;</span>], label=<span class="string">&#x27;Train&#x27;</span>)</span><br><span class="line">plt.plot(test[<span class="string">&#x27;Count&#x27;</span>], label=<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line">plt.plot(y_hat_avg[<span class="string">&#x27;SES&#x27;</span>], label=<span class="string">&#x27;SES&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201002144630712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjkyMzg2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="二次指数平滑-线性回归"><a href="#二次指数平滑-线性回归" class="headerlink" title="二次指数平滑(线性回归)"></a>二次指数平滑(线性回归)</h3><p>在介绍二次指数平滑前介绍一下趋势的概念。</p>
<p>趋势，或者说斜率的定义很简单b=Δy/Δx,</p>
<p>所以对于一个序列而言，相邻两个点的Δ x = 1 Δx=1Δx=1，因此)b=Δy=y(x)−y(x−1)。 除了用点的增长量表示，也可以用二者的比值表示趋势。比如可以说一个物品比另一个贵20块钱，等价地也可以说贵了5%，前者称为可加的（addtive），后者称为可乘的（multiplicative）。在实际应用中，可乘的模型预测稳定性更佳，但是为了便于理解，我们在这以可加的模型为例进行推导。</p>
<p>指数平滑考虑的是数据的baseline，二次指数平滑在此基础上将趋势作为一个额外考量，保留了趋势的详细信息。即我们保留并更新两个量的状态：平滑后的信号和平滑后的趋势。公式如下：<br>基准等式:</p>
<script type="math/tex; mode=display">
s_i = ax_i + (1 - a)(s_{i-1} + t_{i-1})</script><p>趋势等式：</p>
<script type="math/tex; mode=display">
t_i = \beta(s_i- s_{i-1}) + (1 - \beta)t_{i-1}</script><p>第二个等式描述了平滑后的趋势。当前趋势的未平滑“值” ($t<em>{i}$)是当前平滑值（$s</em>{i}$）和上一个平滑值$s<em>{i-1}$的差；<br>的差；也就是说，当前趋势告诉我们在上一个时间步长里平滑信号改变了多少。要想使趋势平滑，我们用一次指数平滑法对趋势进行处理，并使用参数 β<br>对($t</em>{i}$)的处理类似于一次平滑指数法中的（$s_{i}$），即对趋势也需要做一个平滑，临近的趋势权重大。</p>
<p>为获得平滑信号，我们像上次那样进行一次混合，但要同时考虑到上一个平滑信号及趋势。假设单个步长时间内保持着上一个趋势，那么第一个等式的最后那项就可以对当前平滑信号进行估计。</p>
<p>若要利用该计算结果进行预测，就取最后那个平滑值，然后每增加一个时间步长就在该平滑值上增加一次最后那个平滑趋势：<br><img src="https://img-blog.csdnimg.cn/20201005153225313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjkyMzg2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="三次指数平滑"><a href="#三次指数平滑" class="headerlink" title="三次指数平滑"></a>三次指数平滑</h3><p>在应用这种算法前，我们先介绍一个新术语。假如有家酒店坐落在半山腰上，夏季的时候生意很好，顾客很多，但每年其余时间顾客很少。因此，每年夏季的收入会远高于其它季节，而且每年都是这样，那么这种重复现象叫做“季节性”（Seasonality）。如果数据集在一定时间段内的固定区间内呈现相似的模式，那么该数据集就具有季节性。</p>
<p>二次指数平滑考虑了序列的基数和趋势，三次就是在此基础上<strong>增加了一个季节分量</strong>。类似于趋势分量，对季节分量也要做指数平滑。比如预测下一个季节第3个点的季节分量时，需要指数平滑地考虑当前季节第3个点的季节分量、上个季节第3个点的季节分量…等等。详细的有下述公式(累加法)：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&s_{i}=\alpha\left(x_{i}-p_{i-k}\right)+(1-\alpha)\left(s_{i-1}+t_{i-1}\right) \\
&t_{i}=\beta\left(s_{i}-s_{i-1}\right)+(1-\beta) t_{i-1} \\
&p_{i}=\gamma\left(x_{i}-s_{i}\right)+(1-\gamma) p_{i-k}
\end{aligned}</script><p>其中 pi是指“周期性”部分。预测公式如下：</p>
<script type="math/tex; mode=display">
x_{i+h} = s_i + ht_i +p_{i-k+h}</script><p>k 是这个周期的长度</p>
<p>在使用二次平滑模型与三次平滑模型前，我们可以使用sm.tsa.seasonal_decompose分解时间序列，可以得到以下分解图形——从上到下依次是原始数据、趋势数据、周期性数据、随机变量（残差值）</p>
<p><img src="https://img-blog.csdnimg.cn/20201206154401501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNjkyMzg2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>AR模型</p>
<p>AR(Auto Regressive Model)自回归模型是线性时间序列分析模型中最简单的模型。通过自身前面部分的数据与后面部分的数据之间的<strong>相关关系（自相关）来建立回归方程</strong>，从而可以进行预测或者分析。服从p阶的自回归方程表达式AR(p)如下：</p>
<script type="math/tex; mode=display">
x_{t}=\phi_{1} x_{t-1}+\phi_{2} x_{t-2}+\cdots+\phi_{p} x_{t-p}+\mu_{t}</script><p>其中：</p>
<ul>
<li>$u_t$为白噪声，是时间序列中的数值的随机波动，但是这些波动会相互抵消，最终是0。</li>
<li>$\phi$为自回归系数。</li>
</ul>
<p>所以当只有一个时间记录点时，称为一阶自回归过程，即AR(1)。其表达式为：$ x<em>t = \phi x</em>{t-1} + u_t$</p>
<p>利用Python建立AR模型一般会用到我们之后会说到的ARIMA模型（AR模型中的p是ARIMA模型中的参数之一，只要将其他的参数设置为0即为AR模型）。您可以先阅读后续ARIMA模型的内容并参考文件中的代码查看具体的内容</p>
<h2 id="MA模型"><a href="#MA模型" class="headerlink" title="MA模型"></a>MA模型</h2><p>MA(Moving Average Model)移动平均模型通过将一段时间序列中白噪声(误差)进行加权和，可以得到移动平均方程。如下模型为q阶移动平均过程，表示为MA(q)。</p>
<script type="math/tex; mode=display">
x_{t}=\mu+\mu_{t}+\theta_{1} \mu_{t-1}+\theta_{2} \mu_{t-2}+\cdots+\theta_{q} \mu_{t-q}</script><p>其中</p>
<ul>
<li><p>$x_t$ ：t期的值，当期的值由前q期的误差值来决定</p>
</li>
<li><p><em>μ</em>：常数项，相当于普通回归中的截距项</p>
</li>
<li><p>μt: 当期的随机误差。</p>
<p>核心思想是每一期的随机误差都会影响当期值，把前q期的所有误差加起来就是对t期值的影响。</p>
</li>
</ul>
<p>同样，利用Python建立MA模型一般会用到我们之后会说到的ARIMA模型,您可以先阅读后续ARIMA模型的内容并参考文件中的代码查看具体的内容</p>
<h2 id="ARMA模型"><a href="#ARMA模型" class="headerlink" title="ARMA模型"></a>ARMA模型</h2><p>ARMA(Auto Regressive and Moving Average Model)自回归移动平均模型是与自回归和移动平均模型两部分组成。所以可以表示为ARMA(p, q)。p是自回归阶数，q是移动平均阶数。</p>
<script type="math/tex; mode=display">
x_{t}=\phi_{1} x_{t-1}+\phi_{2} x_{t-2}+\cdots+\phi_{p} x_{t-p}+\mu_{t}+\theta_{1} \mu_{t-1}+\theta_{2} \mu_{t-2}+\cdots+\theta_{q} \mu_{t-q}</script><p>从式子中就可以看出，自回归模型结合了两个模型的特点，其中，AR可以解决当前数据与后期数据之间的关系，MA则可以解决随机变动也就是噪声的问题。</p>
<p>ARIMA模型<br>ARIMA(Auto Regressive Integrate Moving Average Model)差分自回归移动平均模型是在ARMA模型的基础上进行改造的，ARMA模型是针对t期值进行建模的，而ARIMA是针对t期与t-d期之间差值进行建模，我们把这种不同期之间做差称为差分，这里的d是几就是几阶差分。ARIMA模型也是基于平稳的时间序列的或者差分化后是稳定的，另外前面的几种模型都可以看作ARIMA的某种特殊形式。表示为ARIMA(p, d, q)。p为自回归阶数，q为移动平均阶数，d为时间成为平稳时所做的差分次数，也就是Integrate单词的在这里的意思。</p>
<script type="math/tex; mode=display">
x_{t}=\phi_{1} w_{t-1}+\phi_{2} w_{t-2}+\cdots+\phi_{p} w_{t-p}+\mu_{t}+\theta_{1} \mu_{t-1}+\theta_{2} \mu_{t-2}+\cdots+\theta_{q} \mu_{t-q}</script><h2 id="SARIMA模型"><a href="#SARIMA模型" class="headerlink" title="SARIMA模型"></a>SARIMA模型</h2><p>SARIMA季节性自回归移动平均模型模型在ARIMA模型的基础上添加了季节性的影响，结构参数有七个：SARIMA(p,d,q)(P,D,Q,s)<br>其中p,d,q分别为之前ARIMA模型中我们所说的p:趋势的自回归阶数。d:趋势差分阶数。q:趋势的移动平均阶数。<br>P:季节性自回归阶数。<br>D:季节性差分阶数。<br>Q:季节性移动平均阶数。<br>s:单个季节性周期的时间步长数。</p>
<h2 id="时间序列的平稳性、随机性检验"><a href="#时间序列的平稳性、随机性检验" class="headerlink" title="时间序列的平稳性、随机性检验"></a>时间序列的平稳性、随机性检验</h2><p>本篇文章我们介绍时间序列的平稳性、随机性检验及相关时间序列数据处理方法。  </p>
<p>在拿到时间序列数据后，首先要对数据的随机性和平稳性进行检测， 这两个检测是时间序列预测的重要部分。根据不同检测结果需要采取不同的分析方法。  </p>
<p>为什么时间序列要求平稳性呢？</p>
<p>平稳性就是要求由样本拟合出的曲线在未来一段时间内仍然能够以现有的形态和趋势发展下去，这样预测结果才会有意义。  </p>
<p>对于平稳声序列， 它的均值和方差是常数， 现已有一套非常成熟的平稳序列的建模方法。 通常是建立一个线性模型来拟合该序列的发展 借此提取该序列的有用信息。  </p>
<p>对于非平稳序列， 由于它的均值和方差不稳定， 处理方法一般是将其转变为平稳序列，这样就可以应用有关平稳时间序列的分析方法， 如建立 ARIMA模型来进行相应的研究，或者分解趋势与季节性等并根据情况应用指数平滑模型等。  </p>
<p>于它的均值和方差不稳定， 处理方法一般是将其转变为平稳序列，这样就可以应用有关平稳时间序列的分析方法， 如建立 ARIMA模型来进行相应的研究，或者分解趋势与季节性等并根据情况应用指数平滑模型等。<br>对于纯随机序列， 又称为白噪声序列， 序列的各项之间没有任何相关关系， 序列在进行完全无序的随机波动， 可以终止对该序列的分析。 白噪声序列是没有信息可提取的平稳序列。  </p>
<p>在讲解平稳性和随机性的定义之前，我们先介绍一下时间序列中常用的几个特征统计量。 </p>
<h2 id="时间序列的特征统计量"><a href="#时间序列的特征统计量" class="headerlink" title="时间序列的特征统计量"></a>时间序列的特征统计量</h2><p>对于一个时间序列任意时刻的序列值{Xt,t∈T}{Xt,t∈T}  </p>
<p>任意时刻的序列值  X t Xt都是一个随机变量，记其分布函数为 F t ( x ) Ft(x),则其特征统计量均值、方差、自协方差函数、自相关系数的定义分别如下:  </p>
<p><strong>均值：</strong> 表示时间序列在各个时刻取值的平均值，其定义如下：</p>
<script type="math/tex; mode=display">
u_t =EX_t = \int_{-\infty}^{+\infty}{xdF_t(x)}</script><p><strong>方差</strong>：表示时间序列在各个时刻围绕其均值波动的平均程度，其定义如下：</p>
<script type="math/tex; mode=display">
\sigma_t^2 = DX_t = E(X_t +u_t)^2 = \int_{-\infty}^{+\infty}{(x-u_t)^2dF_t(x)}</script><p><strong>自协方差：</strong>表示时间序列任意两个时刻直接的相关性，任取t,s其定义如下：</p>
<script type="math/tex; mode=display">
\tau(t,s) = E[(X_t - u_t)(X_s - u_s)]</script><p><strong>自相关系数：</strong>同自协方差函数，其定义如下：</p>
<script type="math/tex; mode=display">
\rho(t,s) = \frac {\gamma(t,s)}{\sqrt{DX_t · DX_s}}</script><h2 id="平稳时间序列的定义与检验"><a href="#平稳时间序列的定义与检验" class="headerlink" title="平稳时间序列的定义与检验"></a>平稳时间序列的定义与检验</h2><p><strong>严平稳时间序列</strong>： 指时间序列的所有统计性质不会随着时间的推移而发生变化，即其联合概率分布在任何时间间隔都是相同的。  </p>
<p><strong>宽平稳时间序列</strong>： 宽平稳时间序列则认为只要时间序列的低阶距（二阶）平稳，则该时间序列近似平稳。    应该如何对其进行平稳性的检验呢？目前，对时间序列的平稳性检验主要有两种方法，一种是图检法，即根据时序图和自相关图进行直观判断，另一种是构造检验统计量的方法，有单位根检验法等方法。 </p>
<ul>
<li>图检法</li>
<li>统计检验法</li>
<li>ADF检验</li>
</ul>
<p>后进行平稳化操作。去看博客吧吐了，。</p>
<p><a target="_blank" rel="noopener" href="http://smilecoc.vip/2021/01/15/time_series_part1_introduction_and_models/">一</a></p>
<p><a target="_blank" rel="noopener" href="http://smilecoc.vip/2021/01/15/time_series_part2_stability/">二</a></p>
<p><a target="_blank" rel="noopener" href="http://smilecoc.vip/2021/01/15/time_series_part3_arima_models/">三</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://cjh0220.github.io">CJH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cjh0220.github.io/2022/09/09/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/">http://cjh0220.github.io/2022/09/09/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cjh0220.github.io" target="_blank">CJH's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/">时间序列</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/09/%E5%9B%BE%E8%AE%BA/"><img class="prev-cover" src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图论</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/08/%E6%8E%92%E9%98%9F%E8%AE%BA/"><img class="next-cover" src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">排队论</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/09/08/vbOo6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CJH</div><div class="author-info__description">Hello,my friends</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cjh0220"><i class="fab fa-github"></i><span>Gihhub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cjh0220" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1005741898@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97-ARIMA-%E6%A1%88%E4%BE%8B%E8%B6%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">时间序列(ARIMA)案例超详细讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.1.</span> <span class="toc-text">时间序列概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ARIMA%EF%BC%88%E5%B7%AE%E5%88%86%E8%87%AA%E5%9B%9E%E5%BD%92%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E6%A8%A1%E5%9E%8B%EF%BC%89%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1 ARIMA（差分自回归移动平均模型）简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 适用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%86%E9%87%8F%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 分量解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 模型基本步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-31-%E5%BA%8F%E5%88%97%E5%B9%B3%E7%A8%B3%E5%8C%96%E6%A3%80%E9%AA%8C%EF%BC%8C%E7%A1%AE%E5%AE%9Ad%E5%80%BC"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.31 序列平稳化检验，确定d值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-32-%E7%A1%AE%E5%AE%9Ap%E5%80%BC%E5%92%8Cq%E5%80%BC"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.32 确定p值和q值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-33-%E6%8B%9F%E5%90%88ARIMA%E6%A8%A1%E5%9E%8B-p-d-q"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">1.33 拟合ARIMA模型 (p,d,q)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-34-%E9%A2%84%E6%B5%8B%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">1.34 预测未来的值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">2 案例介绍及操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BA%8F%E5%88%97%E5%B9%B3%E7%A8%B3%E5%8C%96%E6%A3%80%E9%AA%8C%EF%BC%8C%E7%A1%AE%E5%AE%9Ad%E5%80%BC"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 序列平稳化检验，确定d值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A1%AE%E5%AE%9Ap%E5%80%BC%E5%92%8Cq%E5%80%BC"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 确定p值和q值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-21-%E7%BB%98%E5%88%B6ACF-%E3%80%81PACF%E5%9B%BE"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.21 绘制ACF 、PACF图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-22-AIC%E3%80%81BIC%E5%87%86%E5%88%99"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.22 AIC、BIC准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8B%9F%E5%90%88ARIMA%E6%A8%A1%E5%9E%8B-p-d-q"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 拟合ARIMA模型 (p,d,q)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%A2%84%E6%B5%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 预测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">3 案例工具实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1使用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-%E6%A1%88%E4%BE%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.11 案例操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C%E8%A7%A3%E8%AF%BB"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.12 分析结果解读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BB%93%E8%AE%BA"><span class="toc-number">1.4.</span> <span class="toc-text">4 结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">时间序列（一）：时间序列数据与时间序列预测模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">朴素法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B9%B3%E5%9D%87%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">简单平均法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">移动平均法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">指数平滑法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91"><span class="toc-number">2.4.1.</span> <span class="toc-text">一次指数平滑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">2.4.2.</span> <span class="toc-text">二次指数平滑(线性回归)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8C%87%E6%95%B0%E5%B9%B3%E6%BB%91"><span class="toc-number">2.4.3.</span> <span class="toc-text">三次指数平滑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MA%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">MA模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARMA%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">ARMA模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SARIMA%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">SARIMA模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%B9%B3%E7%A8%B3%E6%80%A7%E3%80%81%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%A3%80%E9%AA%8C"><span class="toc-number">2.8.</span> <span class="toc-text">时间序列的平稳性、随机性检验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E7%89%B9%E5%BE%81%E7%BB%9F%E8%AE%A1%E9%87%8F"><span class="toc-number">2.9.</span> <span class="toc-text">时间序列的特征统计量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E7%A8%B3%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A3%80%E9%AA%8C"><span class="toc-number">2.10.</span> <span class="toc-text">平稳时间序列的定义与检验</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/08/%E5%AB%A6%E5%A8%A5%E5%A5%94%E6%9C%88%E6%94%B9%E5%8F%98%E7%89%88/" title="嫦娥奔月改编版"><img src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嫦娥奔月改编版"/></a><div class="content"><a class="title" href="/2023/03/08/%E5%AB%A6%E5%A8%A5%E5%A5%94%E6%9C%88%E6%94%B9%E5%8F%98%E7%89%88/" title="嫦娥奔月改编版">嫦娥奔月改编版</a><time datetime="2023-03-08T13:53:05.000Z" title="发表于 2023-03-08 21:53:05">2023-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/20/24%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92/" title="24考研计划"><img src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24考研计划"/></a><div class="content"><a class="title" href="/2023/02/20/24%E8%80%83%E7%A0%94%E8%AE%A1%E5%88%92/" title="24考研计划">24考研计划</a><time datetime="2023-02-20T12:55:52.000Z" title="发表于 2023-02-20 20:55:52">2023-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/29/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5/" title="数据预处理概念"><img src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据预处理概念"/></a><div class="content"><a class="title" href="/2023/01/29/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5/" title="数据预处理概念">数据预处理概念</a><time datetime="2023-01-29T02:27:42.000Z" title="发表于 2023-01-29 10:27:42">2023-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/15/%E5%9B%BE%E7%89%87%E7%88%AC%E5%8F%96/" title="图片爬取"><img src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图片爬取"/></a><div class="content"><a class="title" href="/2022/12/15/%E5%9B%BE%E7%89%87%E7%88%AC%E5%8F%96/" title="图片爬取">图片爬取</a><time datetime="2022-12-15T08:12:00.000Z" title="发表于 2022-12-15 16:12:00">2022-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/29/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%BB%8E%E4%B8%9A%E8%80%85%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="腾讯云从业者认证学习笔记"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.ithome.com%2Fnewsuploadfiles%2F2021%2F5%2Ff97e2c7e-5c84-413f-9917-2ff9472b1c04.png&amp;refer=http%3A%2F%2Fimg.ithome.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1672297509&amp;t=b42e24265f6575e03e2d50cd3a5b5145" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="腾讯云从业者认证学习笔记"/></a><div class="content"><a class="title" href="/2022/11/29/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%BB%8E%E4%B8%9A%E8%80%85%E8%AE%A4%E8%AF%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="腾讯云从业者认证学习笔记">腾讯云从业者认证学习笔记</a><time datetime="2022-11-29T07:02:54.000Z" title="发表于 2022-11-29 15:02:54">2022-11-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s1.ax1x.com/2022/09/08/vqpCng.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By CJH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎欢迎，热烈欢迎</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>