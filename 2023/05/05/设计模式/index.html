<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>设计模式 | CJH's blog</title><meta name="keywords" content="设计模式"><meta name="author" content="CJH"><meta name="copyright" content="CJH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="以下参考自珠海科技学院PPT和广东工业大学。 0 设计模式学习步骤&#x2F;考试结构  1.模式动机与定义 2.模式结构与分析 3.模式实例与解析 4.模式效果与应用 5.模式扩展  考试题目结构：  概念题：3道*5分 &#x3D; 15 简答题：4*15 &#x3D; 60 设计题：1* 25 &#x3D; 25  1 设计模式概念 1.1 模式 模式是在特定环境中解决问题的一种方案。 模式的经典定义（ Alexander ）：每">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://cjh0220.github.io/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="CJH&#39;s blog">
<meta property="og:description" content="以下参考自珠海科技学院PPT和广东工业大学。 0 设计模式学习步骤&#x2F;考试结构  1.模式动机与定义 2.模式结构与分析 3.模式实例与解析 4.模式效果与应用 5.模式扩展  考试题目结构：  概念题：3道*5分 &#x3D; 15 简答题：4*15 &#x3D; 60 设计题：1* 25 &#x3D; 25  1 设计模式概念 1.1 模式 模式是在特定环境中解决问题的一种方案。 模式的经典定义（ Alexander ）：每">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/09/08/vqpCng.jpg">
<meta property="article:published_time" content="2023-05-05T12:35:49.000Z">
<meta property="article:modified_time" content="2023-05-09T12:46:01.825Z">
<meta property="article:author" content="CJH">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/09/08/vqpCng.jpg"><link rel="shortcut icon" href="/img/CJH.png"><link rel="canonical" href="http://cjh0220.github.io/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-09 20:46:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/09/08/vbOo6J.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2022/09/08/vqpCng.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CJH's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-05-05T12:35:49.000Z" title="发表于 2023-05-05 20:35:49">2023-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A7%91%E7%9B%AE%E5%AD%A6%E4%B9%A0/">科目学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>以下参考自珠海科技学院PPT和广东工业大学。</p>
<h1>0 设计模式学习步骤/考试结构</h1>
<blockquote>
<p>1.模式动机与定义</p>
<p>2.模式结构与分析</p>
<p>3.模式实例与解析</p>
<p>4.模式效果与应用</p>
<p>5.模式扩展</p>
</blockquote>
<p>考试题目结构：</p>
<ul>
<li>概念题：3道*5分 = 15</li>
<li>简答题：4*15 = 60</li>
<li>设计题：1* 25 = 25</li>
</ul>
<h1>1 设计模式概念</h1>
<h2 id="1-1-模式">1.1 模式</h2>
<p><strong>模式</strong>是在特定环境中解决问题的一种方案。</p>
<p>模式的<strong>经典定义</strong>（ Alexander ）：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，我们可以无数次地重用那些已有的解决方案，无需再重复相同的工作。</p>
<p><strong>软件模式</strong>是模式概念在软件开发领域中的应用，它是对软件开发中某种特定“问题”的“解法”的统一表示，它和 Alexander 所描述的模式定义完全相同，即软件模式等于一定条件下出现的问题以及解决方案。</p>
<p>软件模式并非仅限于<strong>设计模式</strong>，还包括<strong>架构模式</strong>、<strong>分析模式</strong>和<strong>过程模式</strong>等。</p>
<h2 id="1-2-模式要素与结构">1.2 模式要素与结构</h2>
<p><strong>模式三要素：</strong></p>
<p>Context（模式可适用的前提条件）</p>
<p>Theme或Problem（在特定条件下要解决的目标问题）</p>
<p>Solution（对目标问题求解过程中各种物理关系的记述）。</p>
<p>软件模式的<strong>基本结构</strong>由4个部分构成：</p>
<p>模式名称</p>
<ul>
<li>问题描述</li>
<li>前提条件（环境或约束条件）</li>
<li>解法</li>
<li>效果</li>
</ul>
<h2 id="1-3-定义与要素">1.3 定义与要素</h2>
<p>**设计模式（Design Pattern）**定义：是一套被反复使用、多数人知晓、经过分类编目的代码设计经验的总结。</p>
<p>使用设计模式是为了可重用代码、让代码更<strong>容易被他人理解、保证代码可靠性</strong>。</p>
<p>设计模式的要素有名称、问题、目的、解决方案、效果和实例代码等，其中的关键元素包括以下四个方面：</p>
<p><strong>模式名称 (Pattern name)</strong></p>
<p><strong>问题 (Problem)</strong></p>
<p><strong>解决方案 (Solution)</strong></p>
<p><strong>效果(Consequences)</strong></p>
<h2 id="1-4-设计模式的分类">1.4 设计模式的分类</h2>
<h3 id="1-4-1-根据使用目的划分">1.4.1 根据使用目的划分</h3>
<p>根据模式的使用目的，可分为如下三种：</p>
<p><strong>1.创建型（Creational）模式，用于创建对象，将对象的创建与使用分离。</strong></p>
<p><strong>2.结构型(Structural)模式，用于处理类或对象的组合，将类或对象按某种布局组成更大的结构。</strong></p>
<p><strong>3.行为型（Behavioral）模式，用于描述对类或对象怎样交互和怎样分配职责。</strong></p>
<h3 id="1-4-2-根据范围划分">1.4.2 根据范围划分</h3>
<p>根据处理类之间关系还是对象之间的关系，可分为<strong>类模式</strong>和<strong>对象模式</strong>两种。</p>
<ol>
<li>类模式处理类之间的关系，通过继承（或实现）建立，在编译时刻就被确定下来，具有静态性。</li>
<li>对象模式处理对象间的关系，这些关系在运行时刻变化，具有动态性。</li>
</ol>
<h3 id="1-4-3-设计模式23类">1.4.3 设计模式23类</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9t72NV"><img src="https://s1.ax1x.com/2023/05/04/p9t72NV.md.png" alt="p9t72NV.md.png"></a></p>
<p>另一种表达方式：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9t7X9O"><img src="https://s1.ax1x.com/2023/05/04/p9t7X9O.png" alt="p9t7X9O.png"></a></p>
<h2 id="1-5-设计模式优点">1.5 设计模式优点</h2>
<p>软件开发过程中，合理使用设计模式， 使程序呈现高内聚、低耦合的特性，具有如下优点：</p>
<p>1.更好地实现代码重用</p>
<p>2.系统易于扩展（方便增加新的功能，也称可维护）</p>
<p>3.高可靠性 （增加新的功能时，对原有功能没有影响）</p>
<p>4.程序易于理解和交流（因为可以使用UML类图来交流）</p>
<h1>2 七大设计原则</h1>
<p><strong>设计原则</strong>是程序员在编程时应当遵守的原则，也是各种设计模式的基础（或者说是设计的依据）。</p>
<p>面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。</p>
<p>目的是提高可维护性和可靠性。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9tbYJf"><img src="https://s1.ax1x.com/2023/05/04/p9tbYJf.png" alt="p9tbYJf.png"></a></p>
<p>1 开闭原则（OCP）</p>
<p>2 依赖倒置原则（DIP）</p>
<p>3 里氏代换原则（LSP）</p>
<p>4 合成-聚合复用原则（CARP）</p>
<p>5 单一职责原则（SRP）</p>
<p>6 迪米特法则（LoD 或 PLK）</p>
<p>7 接口隔离原则（ISP）</p>
<h1>3 类间关系（不考）</h1>
<p>在Java语言（以下默认）中，普通类使用关系字class定义，类方法都需要使用一对花括号{…}表示方法体（方法的实现代码）。</p>
<p>抽象类使用<code>abstract class</code>定义，必须包含有使用abstract定义的抽象方法。抽象方法没有使用一对花括号{…}定义的方法体，抽象类也可以包含有方法体的普通方法。</p>
<p>接口使用关键字<code>interface</code>定义，它定义的所有方法默认是抽象方法（尽管通常省略了关键字abstract）</p>
<p>注意：设计模式研究类间关系时，当然会涉及类与类、类与抽象类、类与接口之间的关系，并认为接口是一种特殊的类。</p>
<h2 id="3-1-泛化关系">3.1 泛化关系</h2>
<p>使用泛化关系（Generalization）也就是继承关系，也称为“is-a”关系。泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。</p>
<p>在代码实现时，使用面向对象的继承机制来实现泛化关系。在Java语言中，使用extends关键字；在C++ 、C#中，使用冒号“：”来实现。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9tvMy8"><img src="https://s1.ax1x.com/2023/05/04/p9tvMy8.png" alt="p9tvMy8.png"></a></p>
<h2 id="3-2-实现关系">3.2 实现关系</h2>
<p>实现关系（Realization）是指接口与实现类之间的实现关系，接口实现类需要实现接口中声明的所有抽象方法。</p>
<p>在Java语言中，使用关键字implements来表示实现关系。</p>
<p>示例：类Ship和类Car都实现了接口Vehicle。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9tvJFs"><img src="https://s1.ax1x.com/2023/05/04/p9tvJFs.png" alt="p9tvJFs.png"></a></p>
<h2 id="3-3-关联关系">3.3 关联关系</h2>
<p>关联关系（Association）表示一类对象与另一类对象之间的有（has a）联系，它是一种表示整体与部分的结构化关系。</p>
<p>在使用C#、C++和Java等编程语言中，关联关系通常是将一个类（接口）类型的对象作为另一个类的属性 。代码中，部分类对象表现为全局变量。</p>
<p>关联关系可分为单向关联和双向关联。</p>
<p>单向关联示例： Customer与Address（顾客与快递地址）</p>
<p>双向关联示例： Employee与Department（员工—部门）</p>
<p>关联关系通常有聚合与组合2种使用方式，它们通过代码加以区分。</p>
<h3 id="3-3-1-聚合">3.3.1 聚合</h3>
<p>聚合（Aggregation）关系表现在部分类对象可以脱离整体类对象而独立存在。</p>
<p>在代码实现时，部分类对象通过它的构造器或setter方法注入。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9tvBmF"><img src="https://s1.ax1x.com/2023/05/04/p9tvBmF.png" alt="p9tvBmF.png"></a></p>
<h3 id="3-3-2-组合">3.3.2 组合</h3>
<p>组合（Composition）关系中，部分类对象与整体类对象具有统一的生存期。当整体类对象消亡时，部分类对象也将消亡。或者说，整体类对象控制了部分类对象的生命周期。</p>
<p>在代码实现时，部分类对象在整体类属性声明时或它的构造方法里实例化。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9tvTkd"><img src="https://s1.ax1x.com/2023/05/04/p9tvTkd.png" alt="p9tvTkd.png"></a></p>
<h3 id="3-3-3-自关联">3.3.3 自关联</h3>
<p>在系统中，可能会存在一些类的属性对象类型为该类本身，这种建立自身关联的关系称为自关联。例如：单链表中的结点类。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9tvO6f"><img src="https://s1.ax1x.com/2023/05/04/p9tvO6f.png" alt="p9tvO6f.png"></a></p>
<h2 id="3-4-依赖关系">3.4 依赖关系</h2>
<p>依赖关系（Dependency）是指两个事物之间的<strong>使用</strong>关系。</p>
<p>一个类只要用（using）到了另一个类，那么它们之间就存在依赖关系。如果没有对方，连编译都通过不了（IDE是自动编译，此时有波浪线提示）。</p>
<p>在代码中，依赖关系通过如下三种方式来体现依赖类：</p>
<p>（1）方法参数类型</p>
<p>（2）方法返回值类型</p>
<p>（3）在方法代码里使用了另外的类。</p>
<h2 id="3-5-UML类图表示">3.5 UML类图表示</h2>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NS50U"><img src="https://s1.ax1x.com/2023/05/04/p9NS50U.png" alt="p9NS50U.png"></a></p>
<ul>
<li><strong>泛化关系用带空心三角形的直线</strong></li>
<li><strong>实现关系用带空心三角形的虚线</strong></li>
<li><strong>关联关系用实线连接有关联的两个类</strong></li>
<li><strong>依赖关系用带箭头的虚线表示</strong></li>
</ul>
<h1>4 创建型模式</h1>
<p>创建型模式(Creational Pattern)对<strong>类的实例化过程进行了抽象</strong>，能够将软件模块中<strong>对象的创建和对象的使用分离。</strong></p>
<p>为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>
<p>创建型模式在创建什么（What），由谁创建（Who），何时创建（When）等方面都为软件设计者提供了尽可能大的灵活性。</p>
<p>创建型模式<strong>隐藏了类的实例的创建细节</strong>，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p>
<p>创建型设计模式（Creational Design Pattern）描述如何创建对象，将对象的创建和对象的使用分离开，因而符合单一职责原则。由于创建型模式封装了对象的创建细节，客户端无需关心对象的创建细节，这就降低了系统耦合度，因而便于扩展，符合开闭原则。</p>
<p>创建型模式可划分为类创建型模式和对象创建型模式。在GoF23的5种创建型模式中，只有工厂方法模式属于类创建型模式；而抽象工厂、单例、原型和建造者等都属于对象创建型模式。</p>
<h2 id="4-1-工厂模式">4.1 工厂模式</h2>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NpJBT"><img src="https://s1.ax1x.com/2023/05/04/p9NpJBT.png" alt="p9NpJBT.png"></a></p>
<h3 id="4-1-1-简单工厂模式（不属于23类）">4.1.1 简单工厂模式（不属于23类）</h3>
<p>简单工厂模式（Simple Factory Pattern）定义：又称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式。在简单工厂模式中，根据参数的不同返回不同类的实例。</p>
<blockquote>
<p>模式动机：</p>
<p>只需要知道水果的名字，就能得到相应的水果。</p>
<p>再考虑一种场景。客户端需要创建和使用不同类型的电视机对象，不同品牌的电视机都源自同一个电视机抽象类。我们希望客户端不需要知道这些具体的品牌电视机名字，只需要知道电视品牌名称并提供一个调用方便的方法，把参数传入方法就可返回一个相应的电视机对象，以实现电视机对象创建与使用的分离。</p>
</blockquote>
<p>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用<code>new</code>关键字来直接创建产品对象。</p>
<p>在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。</p>
<p>在客户端代码中，我们通过调用工厂类的静态方法即可得到产品对象。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NpTDf"><img src="https://s1.ax1x.com/2023/05/04/p9NpTDf.png" alt="p9NpTDf.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Npsu6"><img src="https://s1.ax1x.com/2023/05/04/p9Npsu6.png" alt="p9Npsu6.png"></a></p>
<h3 id="4-1-2-工厂方式模式（类创建型）">4.1.2 工厂方式模式（类创建型）</h3>
<p>模式动机：简单工厂模式如果需要增加新的产品类型，那么需要修改工厂类的代码，这就使得整个设计在一定程度上违反了“开放封闭原则”。我们定义一个抽象工厂类，并在具体工厂类里重写这个抽象按钮工厂类中定义的抽象方法。抽象化的结果使这种结构可以在不修改已有具体工厂类的情况下引进新的产品。</p>
<p>工厂方法模式（<strong>Factory Method Pattern</strong>）定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p>
<p>在工厂方法模式中，父类负责定义创建对象的公共接口，而子类则负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。</p>
<p>工厂方法模式属于类创建型模式。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NpR4H"><img src="https://s1.ax1x.com/2023/05/04/p9NpR4H.png" alt="p9NpR4H.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NCkef"><img src="https://s1.ax1x.com/2023/05/04/p9NCkef.png" alt="p9NCkef.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NCETS"><img src="https://s1.ax1x.com/2023/05/04/p9NCETS.png" alt="p9NCETS.png"></a></p>
<h3 id="4-1-3-抽象工厂模式">4.1.3 抽象工厂模式</h3>
<p>**模式动机：**在工厂方法模式中，每个具体工厂对应一种具体产品。有时，我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p>
<p>抽象工厂模式（<strong>Abstract Factory Pattern</strong>）<strong>定义</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>抽象工厂模式属于对象创建型模式</p>
<p><strong>抽象工厂模式与访问者模式</strong>有一定的相似性。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NPVnx"><img src="https://s1.ax1x.com/2023/05/04/p9NPVnx.png" alt="p9NPVnx.png"></a></p>
<blockquote>
<p>如果增加新的品牌，即增加一个抽象工厂的子类，则只需要相应地增加该工厂生产的产品类。因此，抽象工厂模式符合开闭原则（如同工厂方法模式）。</p>
<p>如果增加新的产品类型，则需要添加相应的抽象产品及其子类。同时，还需要在抽象工厂里添加新的抽象方法，在具体工厂重写新增的抽象方法。因此，抽象工厂模式属于对象创建型模式，且不支持添加新的产品类型。</p>
<p>由于工厂方法模式只有一个产品类型，因此，工厂方法模式是抽象工厂模式的退化。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NPnAO"><img src="https://s1.ax1x.com/2023/05/04/p9NPnAO.png" alt="p9NPnAO.png"></a></p>
<h2 id="4-2-单例模式">4.2 单例模式</h2>
<h3 id="模式动机："><strong>模式动机</strong>：</h3>
<p>对于系统中的某些类来说，有且只能有一个实例。</p>
<p>（1）一个系统只能有一个窗口管理器。</p>
<p>（2）系统中可以有许多打印机，但是只能有一个打印机正在工作。</p>
<h3 id="模式定义：">模式定义：</h3>
<p>单例模式（Singleton Pattern）定义：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。</p>
<p>单例模式属于对象创建型模式。</p>
<p>单例负责类的实例的创建，且是唯一的。因此，在单例类的外部无法使用new创建。否则，该类的实例对象就不是单例。</p>
<h3 id="模式结构：">模式结构：</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NPa4g"><img src="https://s1.ax1x.com/2023/05/04/p9NPa4g.png" alt="p9NPa4g.png"></a></p>
<h3 id="模式示例">模式示例</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NPyD0"><img src="https://s1.ax1x.com/2023/05/04/p9NPyD0.png" alt="p9NPyD0.png"></a></p>
<h2 id="4-3-原型模式">4.3 原型模式</h2>
<h3 id="模式动机">模式动机</h3>
<p>有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是原型模式的动机。</p>
<h3 id="模式应用场景：">模式应用场景：</h3>
<p>原型模式用以实现类型相同、内存地址不同的对象复制。</p>
<p>原型模式通过复制一个已有实例简化对象的创建过程。</p>
<p>很多软件提供的复制、粘贴功能都是原型模式的应用。</p>
<h3 id="模式定义">模式定义</h3>
<p>原型模式（Prototype Pattern）定义：采用原型实例指定创建对象的种类，并且通过<strong>拷贝</strong>这些原型创建新的对象。原型模式允许<strong>一个对象再创建另外一个可定制的对象</strong>，无需知道任何创建的细节。</p>
<h3 id="模式结构：-2">模式结构：</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NiFIS"><img src="https://s1.ax1x.com/2023/05/04/p9NiFIS.png" alt="p9NiFIS.png"></a></p>
<h3 id="模式实现">模式实现</h3>
<p>原型模式的实现表现在重写的抽象方法，可以划分为通用和专用两种实现方式。</p>
<p>原型模式的通用实现方式是在抽象方法里使用new运算符创建原型对象，将相关参数传入新建的原型对象后再返回。</p>
<p>通过克隆方法创建的对象是全新的对象，在内存中拥有新的地址。</p>
<p>原型模式的专用实现方式使用Java语言中顶级对象Object定义的克隆方法clone()和不含任何抽象方法的克隆接口java.lang. Cloneable。</p>
<h2 id="4-4-建造者模式">4. 4 建造者模式</h2>
<blockquote>
<p><strong>建造者模式</strong>考虑复杂产品的构建，实现产品构建与它的表示分离。</p>
<p>使得同样的构建过程可以创建不同的表示。</p>
<p>允许用户通过指定复杂对象的类型和内容就可以构建完成，而不需要知道内部的具体构建细节。</p>
<p>建造者模式与工厂方法模式的出发点不同、类图部分相同（泛化-依赖） 。</p>
<p><strong>装饰模式</strong>属于结构型，用于动态地给已有对象添加额外的功能。</p>
<p>建造者模式与命令模式有一定的相似性（存在三种关系：聚合-泛化-依赖）。</p>
</blockquote>
<h3 id="模式动机-2">模式动机</h3>
<p>模式动机：在某些情况下，一个对象会有一些重要的属性，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，至少收件人地址未被赋值之前，这个电子邮件不能发出。</p>
<h3 id="模式定义-2">模式定义</h3>
<p>建造者模式（<strong>Builder Pattern</strong>）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者模式是一步一步创建一个复杂的对象，它允许用户通过指定复杂对象的类型和内容就可以构建完成，而不需要知道内部的具体构建细节。</p>
<h3 id="模式结构">模式结构</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NFeYD"><img src="https://s1.ax1x.com/2023/05/04/p9NFeYD.png" alt="p9NFeYD.png"></a></p>
<p><strong>产品指挥者****Director</strong>的引入，使得客户端不需要了解产品的构建细节。</p>
<p>通过<strong>Director</strong>控制复杂产品的建造过程。相同的建造过程，通过使用不同的建造者，可以得到不同的产品表示。</p>
<p>实际应用本模式时，需要在ConcreteBuilder里定义与Product相同的字段，以便返回完整的产品。</p>
<h1>5 结构型模式</h1>
<p>在GoF提出的23种设计模式中，依次包含了<strong>外观、适配器、组合、代理、桥接、装饰和享元</strong>七种。</p>
<p>结构型设计模式描述如何<strong>将类或对象结合在一起形成更大的结构，并可划分为类结构型模式和对象结构型模式</strong>。只有类适配器模式是类结构型，其他结构型模式都是对象结构型模式。</p>
<p>类结构型模式关心类的组合，由多个类可以组合成更大的系统，一般只存在继承关系和实现关系。</p>
<p>对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。</p>
<p>根据合成-聚合复用原则，在系统中尽量使用关联关系来替代继承关系。</p>
<h2 id="5-1-外观模式">5.1 外观模式</h2>
<h3 id="模式动机-3">模式动机</h3>
<p>只需要与外观对象打交道，不需要与子系统内部的很多对象打交道。</p>
<blockquote>
<p>一台计算机由CPU、内存和硬盘等子系统组成，机箱聚合了其它子系统，只需要按机箱上的电源就可以让整个系统正常工作。</p>
<p>外观类屏蔽了各个子系统的内部细节，客户端Client只需要与外观类Façade对象打交道。</p>
<p>外观模式是迪米特法则的典型应用。其中，外观类对象充当Client各个与SubSystem的第三者。参见<strong>中介者</strong>模式。</p>
</blockquote>
<h3 id="模式定义-3">模式定义</h3>
<p>外观模式（<strong>Facade  Pattern</strong>）又称门面模式，定义：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>在外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户端与子系统的内部复杂性隔离开，使得客户端只需要与外观类角色打交道，而不需要与子系统内部的许多对象打交道。</p>
<h3 id="模式结构与角色">模式结构与角色</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NFr7V"><img src="https://s1.ax1x.com/2023/05/04/p9NFr7V.png" alt="p9NFr7V.png"></a></p>
<h3 id="示例">示例</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NFOcd"><img src="https://s1.ax1x.com/2023/05/04/p9NFOcd.png" alt="p9NFOcd.png"></a></p>
<h2 id="5-2-适配器模式">5.2 适配器模式</h2>
<h3 id="模式动机-4">模式动机</h3>
<p>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些对象可以一起工作。例如，笔记本电脑的工作电压是DC 20V，我们的生活用电是220V。正常使用笔记本电脑，必须有一个电源适配器。</p>
<p>在软件开发中，适配器模式将现有的接口<strong>转换</strong>为客户类期望的接口，用以保证对现有类的重用，或扩展现有类的功能。</p>
<h3 id="模式定义-4">模式定义</h3>
<p>适配器模式（<strong>Adapter Pattern</strong>）定义：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。</p>
<p>在使用上，适配器模式可以划分为类适配器和对象适配器两种。类适配器使用类继承方式，对象适配器不使用类继承方式，而是使用关联（通常是组合或聚合）方式。</p>
<p>角色1：适配者Adaptee，是已存在且具有特定功能但不符合目标接口的类，表示需要被适配的对象。</p>
<p>角色2：目标Target，表示被适配后的对象。</p>
<p>角色3：适配器Adapter，表示适配器对象。</p>
<h3 id="类适配器">类适配器</h3>
<p>适配器模式将现有的接口<strong>转换</strong>为客户类期望的接口，用以保证对现有类的重用，或扩展现有类的功能。</p>
<p>适配器模式有2种使用方式：类适配器和对象适配器。</p>
<p>类适配器的特点是：Adapter继承Adaptee。与桥接模式辨析。</p>
<p>适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。装饰模式的别名也是<strong>包装器</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9NFxBt"><img src="https://s1.ax1x.com/2023/05/04/p9NFxBt.png" alt="p9NFxBt.png"></a></p>
<h3 id="对象适配器">对象适配器</h3>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/p9Nki9g"><img src="https://s1.ax1x.com/2023/05/04/p9Nki9g.png" alt="p9Nki9g.png"></a></p>
<p>对象适配器与类适配器角色相同，而类（接口）间关系不同。</p>
<p>​    Adapter是Target的子类， Adapter聚合Adaptee。</p>
<p>对象适配器模式中的Target也可以被设计为接口。</p>
<h2 id="5-3-组合模式">5.3 组合模式</h2>
<h3 id="模式动机-5">模式动机</h3>
<p>树形结构在软件开发中随处可见，如操作系统的文件目录结构、应用软件中的菜单结构和公司组织机构等。</p>
<h3 id="模式定义-5">模式定义</h3>
<p>组合模式（<strong>Composite Pattern</strong>）定义：组合多个对象形成<strong>树形结构</strong>以表示具有部分—整体关系的层次结构。组合模式让客户端可以统一地对待单个对象和组合对象。</p>
<p>组合模式又称部分—整体（Part—Whole）模式，它将对象组织到树形结构中，用以描述整体与部分的关系。</p>
<p>组合模式存在子类聚合父类，参见<strong>装饰</strong>模式和解释器模式。</p>
<p>组合模式是对象结构型模式。</p>
<p>组合模式根据抽象构件的定义形式，可划分为透明组合模式和安全组合模式。</p>
<h3 id="透明组合模式">透明组合模式</h3>
<p>透明组合模式<strong>一致地看待</strong>叶子结点和容器结点。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/04/62eb3e1c0c5ee913.png" alt=""></p>
<h3 id="安全组合模式">安全组合模式</h3>
<p><strong>在安全组合模式里，<strong>叶子结点和容器结点拥有的</strong>方法有差异</strong>。</p>
<p>在测试程序里，使用Composite创建容器结点。</p>
<p>安全组合模式中“<strong>安全</strong>”的含义是叶子构件不具有容器构件特有的add(component)等方法。</p>
<p>根据透明组合模式的代码，<strong>改写</strong>成安全组合模式的代码，是重点。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/04/e19c592d90db5754.png" alt=""></p>
<h2 id="5-4-代理模式">5.4 代理模式</h2>
<h3 id="模式动机-6">模式动机</h3>
<p>模式动机：在网页上查看一张图片，由于网速等原因图片不能立即显示，我们可以在图片传输过程中先把一些简单的用于描述图片的文字传输到客户端，此时这些文字就成为了图片的代理。</p>
<h3 id="应用场景">应用场景</h3>
<p>一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用，去掉客户不能看到的内容和服务或者增添客户需要的额外服务。</p>
<h3 id="模式定义-6">模式定义</h3>
<p>n代理模式（<strong>Proxy Pattern</strong>）定义： 给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate。</p>
<h3 id="模式结构-2">模式结构</h3>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/04/7848fbe2ccaa1b3a.png" alt=""></p>
<p>**静态代理：**代理类所实现的接口和代理方法都已确定，代理类在编译后都会生成一个.class文件，我们称这种代理为静态代理（Static Proxy）。</p>
<p>静态代理使用的局限性主要表现在如下方面：</p>
<p>（1）如果需要为不同的真实主题类提供代理或者代理一个真实主题类中的不同方法，都需要增加新的代理类，即静态代理可能产生类爆炸。</p>
<p>（2）如果需要代理的方法很多且使用增强方法，则导致代理类的不同方法里存在大量相同的代码，即静态代理的重用性不强。</p>
<p><strong>动态代理</strong>可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的目标类及不同的方法。</p>
<p>动态代理在事务管理和AOP（Aspect Oriented Programming，面向切面编程）等领域都有很广泛的应用。</p>
<p><strong>远程代理</strong>（Remote Proxy）是一种常见的代理模式，它隐藏了网络的通信细节，使得客户端可以访问在远程主机里的对象。通俗地说，远程代理是远程对象的本地代表，更一般地说，远程代理是在不同地址空间运行的远程对象。</p>
<h2 id="5-5-桥接模式">5.5 桥接模式</h2>
<h3 id="模式动机-7">模式动机</h3>
<p>以使用手机打电话功能为例：从<strong>品牌</strong>和<strong>外观样式</strong>实现两个维度考虑。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/04/8e6dbc44ce1f2f02.png" alt=""></p>
<h3 id="模式定义-7">模式定义</h3>
<p>桥接模式（<strong>Bridge Pattern</strong>）定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<p>多层继承可能引起类爆炸，桥接模式是比多层继承更好的解决方案。</p>
<h3 id="模式结构-3">模式结构</h3>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/04/4014814bef637f12.png" alt=""></p>
<h2 id="5-6-装饰">5.6 装饰</h2>
<p>**模式动机/定义：**不改变原有对象的前提下，给某个对象而不是整个类添加一些功能。</p>
<p><strong>应用背景</strong>：例如，一个图形用户界面工具箱允许对任意一个用户界面组件添加一些特性，如边框、或是一些行为（如窗口滚动）。</p>
<p>装饰模式在运行时动态扩展一个对象的功能，比使用继承（编译时期就已经确定关系）更加灵活，在Java IO中有广泛的应用。</p>
<p>装饰模式与组合模式和解释器模式类似，也存在子类（装饰器）聚合抽象的父类。</p>
<p>与适配器模式一样，装饰模式的别名也是<strong>包装器</strong>。</p>
<blockquote>
<p>n抽象类Decorator作为抽象类Component的子类，可以不重写父类的抽象方法，而是延迟到具体类！</p>
<p>n抽象装饰类Decorator 是装饰模式的核心类，维护一个抽象构件（父类Component ）的成员对象，并使用构造器注入。</p>
<p>n装饰者和被装饰者可以独立变化。用户可以根据需要增加新的装饰类，在使用时再对其进行组合，原有代码无须改变，符合开闭原则。</p>
<p>n装饰者模式可以在运行时动态扩展一个对象的功能，比继承（编译时期就已经确定关系）更加灵活。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/04/486fd80431ffd825.png" alt=""></p>
<h2 id="5-7-享元">5.7 享元</h2>
<p><strong>模式动机</strong>：在进行共享单车平台软件设计时，按照单车的种类创建对象，需要使用享元模式，以减少创建对象的数量和内存消耗。</p>
<p>享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很近，状态变化很小，对象使用次数增多。</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/04/90f82e8ec5ea0c6b.png" alt=""></p>
<h1>6. 行为型模式</h1>
<p>在GoF 23种设计模式中，依次包含了<strong>策略、模板方法、备忘录、观察者、迭代器、命令、状态、职责链、中介者、访问者和解释器</strong>等11种行为型设计模式（Behavioral Design Pattern） ，它们的使用频率由高向低，学习难度由低向高。</p>
<p>行为型设计模式关注系统中对象的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。行为型模式不仅关注类与对象本身，还重点关注它们之间的相互作用和职责划分。</p>
<p>行为型模式可划分为<strong>类行为型模式</strong>和<strong>对象行为型</strong>模式两种。类行为型模式使用继承关系在若干类之间分配行为，主要通过多态等方式来分配父类与子类的职责，模板方法和解释器模式属于类行为型模式。对象行为型模式使用对象之间的关联关系来分配行为。由于要坚持合成-聚合复用原则，因此，大部分行为型模式属于对象行为型设计模式。</p>
<blockquote>
<p>行为型设计模式主要解决的就是“类或对象之间的交互”问题。</p>
<p>策略模式用于算法的自由切换和扩展。</p>
<p>模板方法模式是基于继承的代码复用技术，可以引入钩子方法使得子类可以控制父类的行为。</p>
<p>命令模式和备忘录模式都可以实现多次的撤销和恢复功能。</p>
<p>观察者模式是一种使用频率非常高的设计模式，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。MVC架构是观察者模式的典型应用。</p>
<p>命令模式和职责链模式都实现了请求发送者与处理者的解耦。例如：命令模式中的Invoker调用Command, Command调用Receiver。</p>
<p>中介者模式是迪米特法则的典型应用，只是做一系列对象之间的消息转发，本身不产生消息。</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/7a592150063bd6e5.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/8f1a79a88ff0b342.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/10fe2b63fef0fb94.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/16360774f787893a.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/04c103ca1c42da46.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/d38b985ec33b2e5d.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/bfa1818d8bd11251.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/f725f113768b3ff3.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/16628ffc96d08a8d.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/e31e13732df25c2b.png" alt=""></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/05/05/e8f7eb4483938cce.png" alt=""></p>
<h1>复习</h1>
<h2 id="继承、合成、聚合的差别">继承、合成、聚合的差别</h2>
<p>继承、合成和聚合是三种常见的代码复用方式，它们之间的区别如下：</p>
<ol>
<li>继承（Inheritance）：子类继承父类的属性和方法，子类可以重载父类的方法或者新增自己的方法。继承使得子类与父类之间形成一种“is-a”(是一个)的关系，即子类是父类的一种具体化。</li>
<li>合成（Composition）：通过将多个对象实例组合在一起，来实现新的功能。例如，一个“汽车”对象由“发动机”、“轮胎”、“座位”等组成。合成使得对象之间形成了一种“has-a”（有一个）的关系。</li>
<li>聚合（Aggregation）：聚合与合成相似，但聚合的组成部分是可以单独存在的，不一定依赖于组合对象。例如一个“公司”对象由多个“员工”对象组成，但员工可以独立于公司存在。聚合也是“has-a”关系。</li>
</ol>
<p>继承具有类似“父子”间的层级关系，而合成和聚合则更多地强调“组合”关系。在具体的设计和实现中，应选择合适的代码复用方式。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://cjh0220.github.io">CJH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cjh0220.github.io/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">http://cjh0220.github.io/2023/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cjh0220.github.io" target="_blank">CJH's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/14/HOG%E5%92%8CLBP/"><img class="prev-cover" src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HOG和LBP</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/"><img class="next-cover" src="https://s1.ax1x.com/2022/09/08/vqpCng.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">腐蚀与膨胀</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/09/08/vbOo6J.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CJH</div><div class="author-info__description">Hello,my friends</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">85</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cjh0220"><i class="fab fa-github"></i><span>Gihhub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cjh0220" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1005741898@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">0 设计模式学习步骤&#x2F;考试结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">1 设计模式概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%A8%A1%E5%BC%8F%E8%A6%81%E7%B4%A0%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 模式要素与结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%A6%81%E7%B4%A0"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 定义与要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 设计模式的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E6%A0%B9%E6%8D%AE%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.4.1 根据使用目的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E6%A0%B9%E6%8D%AE%E8%8C%83%E5%9B%B4%E5%88%92%E5%88%86"><span class="toc-number">2.4.2.</span> <span class="toc-text">1.4.2 根据范围划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F23%E7%B1%BB"><span class="toc-number">2.4.3.</span> <span class="toc-text">1.4.3 设计模式23类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">1.5 设计模式优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">2 七大设计原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">3 类间关系（不考）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 泛化关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 实现关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E8%81%9A%E5%90%88"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.3.1 聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E7%BB%84%E5%90%88"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.3.2 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E8%87%AA%E5%85%B3%E8%81%94"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3.3 自关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 依赖关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-UML%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 UML类图表示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">4 创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8D%E5%B1%9E%E4%BA%8E23%E7%B1%BB%EF%BC%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">4.1.1 简单工厂模式（不属于23类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%B7%A5%E5%8E%82%E6%96%B9%E5%BC%8F%E6%A8%A1%E5%BC%8F%EF%BC%88%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">4.1.2 工厂方式模式（类创建型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">4.1.3 抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">模式动机：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">模式定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">模式结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">模式示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">模式应用场景：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">5.3.3.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%EF%BC%9A-2"><span class="toc-number">5.3.4.</span> <span class="toc-text">模式结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.5.</span> <span class="toc-text">模式实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">4. 4 建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-2"><span class="toc-number">5.4.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-2"><span class="toc-number">5.4.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.3.</span> <span class="toc-text">模式结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">5 结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-3"><span class="toc-number">6.1.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-3"><span class="toc-number">6.1.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E4%B8%8E%E8%A7%92%E8%89%B2"><span class="toc-number">6.1.3.</span> <span class="toc-text">模式结构与角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.1.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-4"><span class="toc-number">6.2.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-4"><span class="toc-number">6.2.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">6.2.3.</span> <span class="toc-text">类适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">6.2.4.</span> <span class="toc-text">对象适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-5"><span class="toc-number">6.3.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-5"><span class="toc-number">6.3.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.3.</span> <span class="toc-text">透明组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.4.</span> <span class="toc-text">安全组合模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-6"><span class="toc-number">6.4.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.4.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-6"><span class="toc-number">6.4.3.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-2"><span class="toc-number">6.4.4.</span> <span class="toc-text">模式结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8A%A8%E6%9C%BA-7"><span class="toc-number">6.5.1.</span> <span class="toc-text">模式动机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89-7"><span class="toc-number">6.5.2.</span> <span class="toc-text">模式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-3"><span class="toc-number">6.5.3.</span> <span class="toc-text">模式结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E8%A3%85%E9%A5%B0"><span class="toc-number">6.6.</span> <span class="toc-text">5.6 装饰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E4%BA%AB%E5%85%83"><span class="toc-number">6.7.</span> <span class="toc-text">5.7 享元</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">6. 行为型模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E3%80%81%E5%90%88%E6%88%90%E3%80%81%E8%81%9A%E5%90%88%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="toc-number">8.1.</span> <span class="toc-text">继承、合成、聚合的差别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/08/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%EF%BC%88%E5%9B%9B%EF%BC%893DGS%E9%AB%98%E6%96%AF%E6%B3%BC%E6%BA%85/" title="论文精读（四）3DGS高斯泼溅"><img src="https://s21.ax1x.com/2024/08/08/pkzVbMd.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文精读（四）3DGS高斯泼溅"/></a><div class="content"><a class="title" href="/2024/08/08/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%EF%BC%88%E5%9B%9B%EF%BC%893DGS%E9%AB%98%E6%96%AF%E6%B3%BC%E6%BA%85/" title="论文精读（四）3DGS高斯泼溅">论文精读（四）3DGS高斯泼溅</a><time datetime="2024-08-08T06:32:59.000Z" title="发表于 2024-08-08 14:32:59">2024-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/07/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89NeRF%E7%A5%9E%E7%BB%8F%E8%BE%90%E5%B0%84%E5%9C%BA/" title="论文精读（三）NeRF神经辐射场"><img src="https://s3.bmp.ovh/imgs/2024/08/07/1abb397a4866f0c4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文精读（三）NeRF神经辐射场"/></a><div class="content"><a class="title" href="/2024/08/07/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89NeRF%E7%A5%9E%E7%BB%8F%E8%BE%90%E5%B0%84%E5%9C%BA/" title="论文精读（三）NeRF神经辐射场">论文精读（三）NeRF神经辐射场</a><time datetime="2024-08-07T03:07:54.000Z" title="发表于 2024-08-07 11:07:54">2024-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/07/Ablation-study%E6%B6%88%E8%9E%8D%E5%AE%9E%E9%AA%8C/" title="Ablation_study消融实验"><img src="https://s21.ax1x.com/2024/08/07/pkx6rLQ.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ablation_study消融实验"/></a><div class="content"><a class="title" href="/2024/08/07/Ablation-study%E6%B6%88%E8%9E%8D%E5%AE%9E%E9%AA%8C/" title="Ablation_study消融实验">Ablation_study消融实验</a><time datetime="2024-08-07T02:44:06.000Z" title="发表于 2024-08-07 10:44:06">2024-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/06/nnU-net/" title="nnU-net"><img src="https://s21.ax1x.com/2024/08/06/pkxlEYq.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nnU-net"/></a><div class="content"><a class="title" href="/2024/08/06/nnU-net/" title="nnU-net">nnU-net</a><time datetime="2024-08-06T09:03:41.000Z" title="发表于 2024-08-06 17:03:41">2024-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/06/U-net/" title="U-net"><img src="https://s21.ax1x.com/2024/08/07/pkxg5VJ.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="U-net"/></a><div class="content"><a class="title" href="/2024/08/06/U-net/" title="U-net">U-net</a><time datetime="2024-08-06T09:01:32.000Z" title="发表于 2024-08-06 17:01:32">2024-08-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s1.ax1x.com/2022/09/08/vqpCng.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By CJH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎欢迎，热烈欢迎</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>