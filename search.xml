<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排队论</title>
      <link href="/2022/09/08/%E6%8E%92%E9%98%9F%E8%AE%BA/"/>
      <url>/2022/09/08/%E6%8E%92%E9%98%9F%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>排队论</h1><p><a href="http://t.csdn.cn/3CuW7">博客1</a></p><p><a href="http://t.csdn.cn/Idc3N">博客2</a></p><p><a href="https://www.zhihu.com/column/c_1431554775167324160">优秀博主的专栏</a></p><h2 id="零-排队论简述">零.排队论简述</h2><h3 id="什么是排队论：">什么是排队论：</h3><p>排队论（queueing theory）是专门研究带有随机因素产生拥挤现象的优化理论，是有关于服务设施与被服务者构成的排队服务系统的理论。</p><p>亦称<strong>随机服务系统理论</strong>。因为被服务者到达系统的时间是不确定的。</p><p>排队论是计算机通信网络和计算机系统中通信信息量研究的基础理论，信息系统通信问题的定量研究往往要求借助于排队论才能得到解决。</p><p>经典模型：</p><p><img src="https://img-blog.csdn.net/20171012191405316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTQ5MzgyMzg4Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><h2 id="一-基本组成">一.基本组成</h2><p><img src="https://pic3.zhimg.com/80/v2-01ebdd2e0be3b3fe17e62fd274e65cce_720w.jpg" alt="img"></p><h3 id="1-输入过程">1.输入过程</h3><p>顾客到达的方式通常是一个给一个到达的，也可能是成批的。顾客到达总是有一定规律，即到达的过程或到达时间间隔符合一定的分布，称<strong>到达分布</strong>。</p><p>顾客到达或到达时间通常假定为相互独立的且遵从同一分布的随机变</p><ul><li>顾客来源：有限/无限</li><li>顾客数量：有限/无限</li><li>经常性的顾客来源：顾客到达间隔时间服从某一概率分布</li><li>顾客的行为假定：在未服务之前不会离开、当看到队列很长的时候离开、从一个队列移到另一个队列</li></ul><h3 id="2-服务规则">2.服务规则</h3><ul><li>服务规则<ul><li>服务台数量：单服务台、多服务台、无限服务台</li><li>服务协议：FCFS、LCFS、RSS、PR、PS、IS<ul><li>先来先服务：<strong>FCFS</strong>（First-Come-First-Served）</li><li>后来后服务：<strong>LCFS</strong>（Last-Come-First-Served）队列是一种堆栈形式，如果队列中有两个以上等待的顾客，则把最后到达的顾客作为下一个服务对象。</li><li>随机服务系统：<strong>RSS</strong>（Random Service System）在服务时从等待顾客中随意抽取一个进行服务。</li><li>优先服务和动态优先服务：<strong>PR</strong>（Priority Service）预先规定优先顺序位的类别，且给到达顾客规定优先顺序位作为标记的优先权。通常按照FCFS服务，优先权分为三类：排队优先权、中断优先权、动态优先权。如计算机中断的优先级。</li><li>处理器共享：<strong>PS</strong>（Processor Sharing）服务台的处理能力被平均分配给队列中的所有顾客，没有排队现象出现，当顾客的数量增加时，只是顾客的服务时间边长。如：网络服务系统。</li><li>无限服务台：<strong>IS</strong>（Infinite Server）在这种情况下，队列中的每个顾客接收完全相同的服务，而且就好像它是唯一的一个顾客一样。好像对于每个顾客都可以“克隆”出一个心得服务台，而且克隆的数目可以无限。</li></ul></li><li>服务时间分布：指数、常熟、k阶爱尔朗分布</li></ul></li></ul><h3 id="3-排队规则">3.排队规则</h3><ul><li>队列容量：有限/无限</li><li>排队方式：单队列、并联式多队列、串联式多队列、杂乱队列</li></ul><h3 id="4-数量指标">4.数量指标</h3><ul><li>平均队长：排队系统中顾客数的平均值， <img src="https://www.zhihu.com/equation?tex=%5Csmall+L_s" alt="[公式]"> 。</li><li>平均队列长：排队系统中等待服务的顾客数的平均值， <img src="https://www.zhihu.com/equation?tex=%5Csmall+L_q" alt="[公式]"> 。</li><li>平均逗留时间：一个顾客在系统中停留的时间的平均值， <img src="https://www.zhihu.com/equation?tex=%5Csmall+W_s" alt="[公式]"> 。</li><li>平均等待时间：一个顾客在系统中排队等待的时间的平均值， <img src="https://www.zhihu.com/equation?tex=%5Csmall+W_q" alt="[公式]"> 。</li><li>稳态顾客数： <img src="https://www.zhihu.com/equation?tex=%5Csmall+P_n" alt="[公式]"> ,表示当稳定时有 <img src="https://www.zhihu.com/equation?tex=%5Csmall+n" alt="[公式]"> 位顾客的概率。</li><li>平均到达率：单位时间内到达顾客的平均数 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Clambda" alt="[公式]"> 。</li><li>平均服务率：单位时间内被服务顾客的平均数 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Cmu" alt="[公式]"> 。</li><li>服务强度：单位时间内的服务强度， <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Crho%3D%5Clambda+%2F%5Cmu" alt="[公式]"> 。</li></ul><h2 id="二。常见的分布">二。常见的分布</h2><h3 id="1-泊松分布">1.泊松分布</h3><ul><li>需要满足的条件：</li><li><ul><li>在 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5CDelta+t" alt="[公式]"> 时间内，有一个顾客到达的概率为 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Clambda%5CDelta+t" alt="[公式]"> 。</li><li>没有一个顾客到达的概率 <img src="https://www.zhihu.com/equation?tex=%5Csmall+1-%5Clambda%5CDelta+t" alt="[公式]"></li><li>不可能多于一个顾客到达。</li><li>注意这里直接将 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5CDelta+t" alt="[公式]"> 视为无穷小量</li></ul></li><li>顾客到达服从参数为 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Clambda" alt="[公式]"> 的泊松流。</li></ul><h3 id="2-负指数分布">2.负指数分布</h3><ul><li>需要满足的条件：</li><li><ul><li>在 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5CDelta+t" alt="[公式]"> 时间内，有一个顾客被服务完的概率为 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Cmu%5CDelta+t" alt="[公式]"> 。</li><li>没有一个顾客被服务完的概率 <img src="https://www.zhihu.com/equation?tex=%5Csmall+1-%5Cmu%5CDelta+t" alt="[公式]"></li><li>不可能多于一个顾客被服务完。</li><li>注意这里直接将 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5CDelta+t" alt="[公式]"> 视为无穷小量</li></ul></li><li>服务时间服从参数为 <img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="[公式]"> 。</li></ul><h2 id="三。排队模型记号">三。排队模型记号</h2><p>一般形式：<strong>X/Y/Z/A/B/X</strong></p><ul><li><ul><li><strong>X</strong>顾客到达时间间隔分布。</li><li><strong>Y</strong>服务时间分布。</li><li><strong>Z</strong>服务台数目。</li><li><strong>A</strong>排队系统允许的最大顾客容量。</li><li><strong>B</strong>顾客总体数量。</li><li><strong>C</strong>排队规则(一般情况为先到先服务)。</li></ul></li></ul><h2 id="四。单服务台模型">四。单服务台模型</h2><h3 id="0-Little公式">0.Little公式</h3><p>运行指标之间的关系：</p><ul><li><ul><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+L_s%3D%5Clambda+W_s" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+L_q%3D%5Clambda+W_q" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+L_s%3DL_q%2B%5Cdisplaystyle%5Cfrac%7B%5Clambda%7D%7B%5Cmu%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+W_s%3DW_q%2B%5Cdisplaystyle%5Cfrac%7B1%7D%7B%5Cmu%7D" alt="[公式]"></li></ul></li></ul><h3 id="1-标准型M-M-1-公式">1.标准型M/M/1/ <img src="https://www.zhihu.com/equation?tex=%5Cinfin%2F%5Cinfin" alt="[公式]"></h3><ul><li>特点：</li><li><ul><li>顾客源为无限的，顾客的到达相互独立，到达规律服从参数为 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="[公式]"> 的泊松分布。</li><li>单服务台、队长无限、先到先服务。</li><li>各顾客的服务时间相互独立，且同服从于参数为 <img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="[公式]"> 的负指数分布。</li></ul></li><li>首先计算出来对应的P值：</li></ul><p><img src="https://www.zhihu.com/equation?tex=P_0%3D1-%5Crho%5C%5C+P_n%3D%281-%5Crho%29%5Crho%5E%7Bn%7D%5C%5C" alt="[公式]"></p><ul><li>计算出的参数结果：</li></ul><p><img src="https://www.zhihu.com/equation?tex=%E5%B9%B3%E5%9D%87%E9%98%9F%E9%95%BF%EF%BC%9AL_s%3D%5Cfrac%7B%5Clambda%7D%7B%5Cmu-%5Clambda%7D%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E9%95%BF%EF%BC%9AL_q+%3D%5Cfrac%7B%5Crho%5Clambda%7D%7B%5Cmu-%5Clambda%7D%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E9%80%97%E7%95%99%E6%97%B6%E9%97%B4%EF%BC%9AW_s%3D%5Cfrac%7B1%7D%7B%5Cmu-%5Clambda%7D%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%EF%BC%9AW_q%3D%5Cfrac%7B%5Crho%7D%7B%5Cmu-%5Clambda%7D" alt="[公式]"></p><h3 id="2-系统容量有限型M-M-1-N-公式">2.系统容量有限型M/M/1/N/ <img src="https://www.zhihu.com/equation?tex=%5Cinfin" alt="[公式]"></h3><p>损失制:当顾客到达时，所有的服务台均被占用，顾客随即离去。 首先计算出来对应的P值：</p><p><img src="https://pic2.zhimg.com/80/v2-fde7e480f8b042202e760ddf666b4c99_720w.jpg" alt="img"></p><ul><li>计算出的参数结果：</li></ul><p><img src="https://www.zhihu.com/equation?tex=%E6%9C%89%E6%95%88%E5%88%B0%E8%BE%BE%E7%8E%87%EF%BC%9A%5Clambda_e%3D%5Clambda%281-P_N%29%5C%5C+~~%5C%5C+%E6%9C%89%E6%95%88%E6%9C%8D%E5%8A%A1%E5%BC%BA%E5%BA%A6%EF%BC%9A%5Cfrac%7B%5Clambda_e%7D%7B%5Cmu%7D%3D1-P_0%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E9%98%9F%E9%95%BF%EF%BC%9AL_s%3D%5Cfrac%7B1%7D%7B1-%5Crho%7D-%5Cfrac%7B%28N%2B1%29%5Crho%5E%7BN%2B1%7D%7D%7B1-%5Crho%5E%7BN%2B1%7D%7D%28%5Crho%5Cnot+%3D%7B1%7D%2C%E5%BD%93%5Crho%3D1%E6%97%B6%E8%AF%B4%E6%98%8E%E6%B5%81%E5%85%A5%E5%92%8C%E6%B5%81%E5%87%BA%E7%9B%B8%E7%AD%89%EF%BC%8C%E6%B2%A1%E6%9C%89%E6%8E%92%E9%98%9F%E7%8E%B0%E8%B1%A1%E4%BA%A7%E7%94%9F%29%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E9%95%BF%EF%BC%9AL_q+%3DL_s-%281-P_0%29%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E9%80%97%E7%95%99%E6%97%B6%E9%97%B4%EF%BC%9AW_s%3D%5Cfrac%7BL_s%7D%7B%5Clambda_e%7D%3D%5Cfrac%7BL_s%7D%7B%5Clambda%281-P_N%29%7D%3D%5Cfrac%7BL_q%7D%7B%5Clambda%281-P_N%29%7D%2B%5Cfrac%7B1%7D%7B%5Cmu%7D%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%EF%BC%9AW_q%3D%5Cfrac%7BL_q%7D%7B%5Clambda_e%7D%3D%5Cfrac%7BL_q%7D%7B%5Clambda%281-P_N%29%7D%3DW_s-%5Cfrac%7B1%7D%7B%5Cmu%7D" alt="[公式]"></p><h3 id="3-顾客源有限型M-M-1-公式-M">3.顾客源有限型M/M/1/ <img src="https://www.zhihu.com/equation?tex=%5Cinfin" alt="[公式]"> /M</h3><p>首先说明一下，因为顾客源只有m，所以最多的情况就是来m个顾客，因此这个模型和 <strong>M/M/1/m/m</strong> 其实是完全一样的。 但是注意这里的 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Clambda" alt="[公式]"> 的定义和前面有一些区别，这里的 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Clambda" alt="[公式]"> 定义为单位时间内该顾客来到系统请求服务的次数。</p><ul><li>下面首先计算出来对应的P值：</li></ul><p><img src="https://pic1.zhimg.com/80/v2-01b056e2b104c01f2dc1d64674268aa8_720w.jpg" alt="img"></p><ul><li>计算出的参数结果：</li></ul><p><img src="https://www.zhihu.com/equation?tex=%E5%B9%B3%E5%9D%87%E9%98%9F%E9%95%BF%EF%BC%9AL_s%3Dm-%5Cfrac%7B%5Cmu%7D%7B%5Clambda%7D%281-P_0%29%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E9%98%9F%E5%88%97%E9%95%BF%EF%BC%9AL_q+%3D+m-%5Cfrac%7B%28%5Clambda%2B%5Cmu%29%281-P_0%29%7D%7B%5Clambda%7D%3DL_s-%281-P_0%29%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E9%80%97%E7%95%99%E6%97%B6%E9%97%B4%EF%BC%9AW_s%3D%5Cfrac%7Bm%7D%7B%5Cmu%281-P_0%29%7D-%5Cfrac%7B1%7D%7B%5Clambda%7D%5C%5C+~~%5C%5C+%E5%B9%B3%E5%9D%87%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%EF%BC%9AW_q%3DW_s-%5Cfrac%7B1%7D%7B%5Cmu%7D" alt="[公式]"></p><h2 id="五。多服务台模型">五。多服务台模型</h2><h3 id="1-多服务台标准型M-M-c">1.多服务台标准型M/M/c/</h3><ul><li>顾客流为泊松流，平均到达率为 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="[公式]"> ,各个服务台的平均服务率是 <img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="[公式]"> 。</li><li>整个服务机构的平均服务率为 <img src="https://www.zhihu.com/equation?tex=n%5Cmu%28n%3Cc%29" alt="[公式]"> 或 <img src="https://www.zhihu.com/equation?tex=c%5Cmu%28n%5Cge+c%29" alt="[公式]"> 。</li><li>系统服务强度为（当 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Crho%3E1" alt="[公式]">会产生排队现象） <img src="https://www.zhihu.com/equation?tex=%5Crho+%3D+%5Cfrac%7B%5Clambda%7D%7Bc%5Cmu%7D%5C%5C" alt="[公式]"></li><li>首先计算出来对应的P值：</li></ul><p><img src="https://pic2.zhimg.com/80/v2-f0736771d31c8aef843453700761f0b5_720w.jpg" alt="img"></p><ul><li>计算出系统的运行指标：</li></ul><p><img src="https://pic1.zhimg.com/80/v2-acd7c0d6d5c32b4869365c187433cd78_720w.jpg" alt="img"></p><ul><li><strong>一个有用的结论</strong>： 顾客逗留时间服从 <img src="https://www.zhihu.com/equation?tex=%5Cmu-%5Clambda" alt="[公式]"> 的指数分布(参考平均逗留时间 <img src="https://www.zhihu.com/equation?tex=W_s" alt="[公式]"> )。</li></ul><h3 id="2-多服务台M-M-c-N-公式">2.多服务台M/M/c/N/ <img src="https://www.zhihu.com/equation?tex=%5Cinfin" alt="[公式]"></h3><ul><li>首先计算出来对应的P值：</li></ul><p><img src="https://pic1.zhimg.com/80/v2-249b3e5b98110b36fde8e0f2a4b0ff04_720w.jpg" alt="img"></p><ul><li>计算出系统的运行指标：</li></ul><p><img src="https://pic4.zhimg.com/80/v2-b6e751da8288b5250fed299a16323b33_720w.jpg" alt="img"></p><h3 id="3-多服务台M-M-c-公式-m">3.多服务台M/M/c/ <img src="https://www.zhihu.com/equation?tex=%5Cinfin" alt="[公式]"> /m</h3><ul><li>首先计算出来对应的P值：</li></ul><p><img src="https://pic2.zhimg.com/80/v2-19a64d463ac9768d88dc4e32cee71ed1_720w.jpg" alt="img"></p><ul><li>计算出系统的运行指标：</li></ul><p><img src="https://pic3.zhimg.com/80/v2-0466641cacb485039571528583af9d1a_720w.jpg" alt="img"></p><h2 id="六。排队系统最优化">六。排队系统最优化</h2><h3 id="1-标准M-M-1系统的最优服务率">1.标准M/M/1系统的最优服务率</h3><ul><li>参数引入：</li><li><ul><li><img src="https://www.zhihu.com/equation?tex=C_s" alt="[公式]"> :对每个顾客的单位时间服务费。</li><li><img src="https://www.zhihu.com/equation?tex=C_w" alt="[公式]"> :为每个顾客在系统停留单位时间的损失费。</li><li><img src="https://www.zhihu.com/equation?tex=G" alt="[公式]"> :单位时间对每位顾客服务的收入。</li><li><img src="https://www.zhihu.com/equation?tex=z" alt="[公式]"> :总费用。</li></ul></li><li>优化目标(单位时间费用最小)： <img src="https://www.zhihu.com/equation?tex=%5Cmin%7Bz%7D%3DC_s%5Cmu%2BC_wL_s" alt="[公式]"></li><li>求得最优取值： <img src="https://www.zhihu.com/equation?tex=%5Cmu%5E%7B%2A%7D%3D%5Clambda%2B%5Csqrt%7B%5Cdfrac%7BC_w%7D%7BC_s%7D%5Clambda%7D%5C%5C" alt="[公式]"></li><li>优化目标(服务利润最大)： <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Cmax%7Bz%7D%3D%5Cmu%281-P_0%29G-C_s%5Cmu" alt="[公式]"> ( <img src="https://www.zhihu.com/equation?tex=%5Csmall+1-P_0" alt="[公式]"> 表示排除没有人的情况)</li></ul><h3 id="2-系统容量有限M-M-1-N-公式-的最优服务率">2.系统容量有限M/M/1/N/ <img src="https://www.zhihu.com/equation?tex=%5Cinfin" alt="[公式]"> 的最优服务率</h3><ul><li>与标准情况的差别：这里相当于如果系统中已经有 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 个顾客了，那么后来的都会被拒绝，所以说这里实际进入(稳定状态下服务完)的客户多一个 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%281-P_N%29" alt="[公式]"> 的系数，为 <img src="https://www.zhihu.com/equation?tex=%5Csmall+%5Clambda%281-P_N%29" alt="[公式]"></li><li>优化目标为： <img src="https://www.zhihu.com/equation?tex=%5Cmin%7Bz%7D%3D%5Clambda%281-P_N%29G-C_s%5Cmu%3D%5Clambda+G%5Cfrac%7B1-%5Crho%5E%7BN%7D%7D%7B1-%5Crho%5E%7BN%2B1%7D%7D-C_s%5Cmu%5C%5C" alt="[公式]"></li><li>求得结果：</li></ul><p><img src="https://www.zhihu.com/equation?tex=%5Crho%5E%7BN%2B1%7D%5Cfrac%7BN-%28N%2B1%29%5Crho%2B%5Crho%5E%7BN%2B1%7D%7D%7B%281-%5Crho%5E%7BN%2B1%7D%29%5E2%7D%3D%5Cfrac%7BC_s%7D%7BG%7D%5C%5C" alt="[公式]"></p><p>注意这里面 <img src="https://www.zhihu.com/equation?tex=%5Cdisplaystyle%5Crho%3D%5Cfrac%7B%5Clambda%7D%7B%5Cmu%7D" alt="[公式]"> ，其他的参量也都知道，因此最后只需要通过数值方法求解 <img src="https://www.zhihu.com/equation?tex=%5Cmu%5E%7B%2A%7D" alt="[公式]"> 。</p><h3 id="3-顾客源有限M-M-1-m-m的最优服务率">3.顾客源有限M/M/1/m/m的最优服务率</h3><ul><li>根据之前的模型可知，单位时间服务完的顾客数为 <img src="https://www.zhihu.com/equation?tex=%5Clambda%28m-L_s%29" alt="[公式]"> 。</li><li>优化目标(服务利润最大)： <img src="https://www.zhihu.com/equation?tex=%5Cmax%7Bz%7D%3D%5Clambda%28m-L_s%29G-C_s%5Cmu" alt="[公式]"> ( <img src="https://www.zhihu.com/equation?tex=1-P_0" alt="[公式]"> 表示排除没有人的情况)</li><li>优化结果为：</li></ul><p><img src="https://pic1.zhimg.com/80/v2-cf12f236c40810435ef73972995b732c_720w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-2cbcea02bdd9d6ca4a49282740bd21f8_720w.jpg" alt="img"></p><h3 id="4-标准M-M-c的最优服务台数">4.标准M/M/c的最优服务台数</h3><ul><li>优化目标(单位时间费用最小)： <img src="https://www.zhihu.com/equation?tex=%5Cmin%7Bz%7D%3DC_s%5Cmu%2BC_wL_s" alt="[公式]"> ，注意这里因为 <img src="https://www.zhihu.com/equation?tex=L_s%3DL_s%28c%29" alt="[公式]"> 所以个服务台的个数有关。</li><li>由于 <img src="https://www.zhihu.com/equation?tex=c" alt="[公式]"> 是离散的取值，因此采用边际分析法求解，假定 <img src="https://www.zhihu.com/equation?tex=c" alt="[公式]"> 的最优值为 <img src="https://www.zhihu.com/equation?tex=c%5E%7B%2A%7D" alt="[公式]"> ，此时 <img src="https://www.zhihu.com/equation?tex=z%28c%5E%7B%2A%7D%29" alt="[公式]"> 为最少费用。</li><li>根据最小值的特性可以得到如下的不等式：</li></ul><p><img src="https://www.zhihu.com/equation?tex=z%28c%5E%7B%2A%7D%29%5Cle+z%28c%5E%7B%2A%7D-1%29%5C%5C+z%28c%5E%7B%2A%7D%29%5Cle+z%28c%5E%7B%2A%7D%2B1%29" alt="[公式]"></p><ul><li>化简得到结果：</li></ul><p><img src="https://pic3.zhimg.com/80/v2-8ee32a73ae69f1be691ddfb901471b6a_720w.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排队模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法</title>
      <link href="/2022/09/08/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>遗传算法</h1><p>遗传算法（Genetic Algorithm，GA）是由John Holland于20世纪70年代提出，该算法是根据大自然中生物体进化规律而设计提出的，来模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p><p><img src="http://m.qpic.cn/psc?/V12XQ1QV3cpyPD/ruAMsa53pVQWN7FLK88i5hxcI9YFYZf8uDa7rxRl27GqrEcJMDcHY2GuI2qlJdngDf8ZeMeq0APTSwS5WYkEohohtoTj*yg4ETbgh4pHw*c!/b&amp;bo=ywAIAQAAAAABB.I!&amp;rf=viewer_4" alt="img"></p><h2 id="遗传算法的流程：">遗传算法的流程：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.评估每条染色体所对应个体的适应度</span><br><span class="line">While（未找到满意的解）：</span><br><span class="line">2.遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方</span><br><span class="line">3.抽取父母双方的染色体，进行交叉，产生子代</span><br><span class="line">4.对子代的染色体进行变异</span><br></pre></td></tr></table></figure><h2 id="优点：">优点：</h2><p>1） 遗传算法具有广泛的应用领域<br>2） 遗传算法具有群体搜索的特性<br>3） 遗传算法基于概率规则，搜索更为灵活</p><p>4） 遗传算法直接以目标函数作为搜索信息，不涉及目标函数值求微分的过程</p><h2 id="缺点：">缺点：</h2><p>1） 遗传算法效率比较低</p><p>2） 遗传算法容易过早收敛<br>3） 遗传算法在编码时容易出现不规范不准确的问题</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遗传算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分分析法</title>
      <link href="/2022/09/08/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2022/09/08/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>主成分分析法(PCA)</h1><p>参考资料：</p><p><a href="https://bbs.spsspro.com/news/121">spssspro</a></p><p><a href="https://blog.csdn.net/qq_38262266/article/details/100592330">PCA(主成分分析)过程详解</a></p><p><a href="https://www.jianshu.com/p/9176c2f92057">简书</a></p><p><img src="https://img-blog.csdnimg.cn/20190907122225372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjYyMjY2,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>数据降维大法–主成分分析法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主成分分析法是运用“降维”思想，把多个指标变换成少数综合指标的多元统计方法，这里的综合指标就是主成分。每个主成分都是原始变量的线性组合，彼此相互独立，并保留了原始变量绝大部分信息。其本质是通过原始变量的相关性，寻求相关变量的综合替代对象，并且保证了转化过程中的信息损失最小 。</span><br></pre></td></tr></table></figure><p><strong>前言废话篇：</strong></p><p>什么，老板既然让我一天内分析完今年公司的经营状态？？</p><p>光是公司财务数据就已经包含20+个变量，固定资产、流动资金、每一笔借贷的数额和期限、各种税费、工资支出、原料消耗、产值、利润、等等，何况公司还有其他的部门！</p><p><img src="https://bbs.spsspro.com/api/v2/files/1255" alt="image.png"></p><p>老板虐我千百遍，我待老板如初恋，再见了，我也该去寻找真正属于我的幸福了。可是工作做不完，晚上就没时间去寻找幸福了，作为一名专业首席财务官（公司唯一的会计），偷懒这件事情上我还没有输过谁，既然那么多变量，那我就把20个变量偷偷的变成5个变量，四舍五入我只要分析5个变量的数据，是时候打开微信约妹子了。</p><p><strong>废话结束，开启正文模式</strong></p><p>那哪些才是可选择的重要指标呢？这就是我们所说的数据降维，将原来20多个变量降到用3个或者5个变量来解释，并且这几个变量可以解释原数据的大部分信息（比如85%以上），且各个指标保持独立。</p><p>达到降维目的的方法有：主成分分析法和因子分析法，并且可以认为主成分分析法是因子分析的一个特例。</p><p>那么今天我们来详细讲解一下主成分分析法，包含原理+案例+操作，不想看原理的宝宝可直接跳到后面看案例。</p><h3 id="1-1-主成分分析法-PCA-的原理">1.1 主成分分析法(PCA)的原理</h3><p>主成分分析法是运用“降维”思想，把多个指标变换成少数综合指标的多元统计方法，这里的综合指标就是主成分。每个主成分都是原始变量的线性组合，彼此相互独立，并保留了原始变量绝大部分信息。其本质是通过原始变量的相关性，寻求相关变量的综合替代对象，并且保证了转化过程中的信息损失最小 。</p><p>主成分与原始变量之间的关系：</p><ol><li>主成分是原始变量的线性组合</li><li>主成分的数量相对于原始数量更少</li><li>主成分保留了原始变量的大部分信息</li><li>主成分之间相互独立</li></ol><h3 id="1-2-主成分分析法的应用步骤">1.2 主成分分析法的应用步骤</h3><h4 id="1-21-根据标准化后的数据集计算协方差矩阵Z">1.21 根据标准化后的数据集计算协方差矩阵Z:</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1258" alt="image.png"> <img src="https://bbs.spsspro.com/api/v2/files/1257" alt="image.png"></p><p>相关系数程度区分列如下面两个表所示：</p><p><img src="https://bbs.spsspro.com/api/v2/files/1259" alt="image.png"></p><h4 id="1-22-计算R的特征值及对应特征向量">1.22 计算R的特征值及对应特征向量</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1260" alt="image.png"></p><p>主成分分析的一个关键问题是：主成分的个数选多少个比较合适？</p><p>有3个主要的衡量标准：</p><ol><li>保留的主成分使得方差贡献率达到85%以上</li><li>保留的主成分的方差（特征值）大于1</li><li>碎石图绘制了关于各主成分及其特征值的图形，我们只需要保留图形中变化最大之处以上的主成分即可</li></ol><h2 id="2-主成分分析法应用实例">2 主成分分析法应用实例</h2><h3 id="2-1-背景介绍">2.1 背景介绍</h3><p>某金融服务公司为了了解贷款客户的信用程度，评价客户的信用等级，采用信用评级常用的 5C(能力，品格 ，担保 ，资本，环境)方法对15名客户进行打分， 由此判断客户违约的可能性。</p><ul><li>品格:指客户的名誉；</li><li>能力:指客户的偿还能力；</li><li>资本:指客户的财务实力和财务状况；</li><li>担保:指对申请贷款项担保的覆盖程度；</li><li>环境:指外部经济政策环境对客户的影响；</li></ul><p><img src="https://bbs.spsspro.com/api/v2/files/1261" alt="image.png"> 由于各项指标的难易程度不同，因此需要对5项指标进行赋权，以便能够更加合理的对15名客户进行评价。</p><h3 id="2-2-数据处理">2.2 数据处理</h3><h4 id="2-21-计算每一列的平均值">2.21 计算每一列的平均值</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1262" alt="image.png"></p><h4 id="2-22-计算每一列的标准差">2.22 计算每一列的标准差</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1263" alt="image.png"></p><p>例如能力该指标，我们计算其标准差</p><p><img src="https://bbs.spsspro.com/api/v2/files/1264" alt="image.png"></p><h4 id="2-23-数据标准化处理">2.23 数据标准化处理</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1265" alt="image.png"></p><p>例如客户1的能力该项指标，使用公式:</p><p><img src="https://bbs.spsspro.com/api/v2/files/1266" alt="image.png"></p><h4 id="2-24-计算相关系数矩阵">2.24 计算相关系数矩阵</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1267" alt="image.png"></p><p>例如品格与能力的相关系数，使用公式 :</p><p><img src="https://bbs.spsspro.com/api/v2/files/1268" alt="image.png"></p><h4 id="2-25-计算特征值">2.25 计算特征值</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1269" alt="image.png"></p><h4 id="2-26-计算特征向量">2.26 计算特征向量</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1270" alt="image.png"></p><h4 id="2-27-计算贡献率">2.27 计算贡献率</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1271" alt="image.png"></p><p>例如能力，我们使用公式</p><p><img src="https://bbs.spsspro.com/api/v2/files/1272" alt="image.png"></p><h4 id="2-28-计算累积贡献率">2.28 计算累积贡献率</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1273" alt="image.png"></p><h2 id="3、案例工具实现">3、案例工具实现</h2><h3 id="3-1使用工具">3.1使用工具</h3><h4 id="3-11-SPSSPRO—-【统计建模—-主成分分析（PCA）】">3.11 SPSSPRO—&gt;【统计建模—&gt;主成分分析（PCA）】</h4><h4 id="3-12案例操作">3.12案例操作</h4><p><img src="https://bbs.spsspro.com/api/v2/files/1274" alt="image.png"></p><p>Step1：新建项目；</p><p>Step2：上传数据；</p><p>Step3：选择对应数据打开后进行预览，确认无误后点击开始分析；</p><p><img src="https://bbs.spsspro.com/api/v2/files/1275" alt="image.png"></p><p>step4：选择【主成分分析】；</p><p>step5：查看对应的数据数据格式，【主成分分析】要求输入数据为放入 [定量] 自变量 X（变量数 ≥2）。</p><p>step6：选择主成分个数（注意：主成分个数的选择，依赖于个人能接受的最大主成分个数，而特征根选择则是根据设定的阈值为界限，以大于该界限对应的主成分个数作为选取的主成分个数，默认为 1。）</p><p>step7：点击【开始分析】，完成全部操作。</p><h4 id="3-13-分析结果解读">3.13 分析结果解读</h4><p>以下生成的结果来源于SPSSPRO软件的分析结果导出</p><p><strong>输出结果1：KMO检验和Bartlett的检验</strong></p><p><img src="https://bbs.spsspro.com/api/v2/files/1276" alt="image.png"></p><p>*这两项检验是用来判断是否可以进行主成分分析。 对于KMO值：0.8上非常合适做主成分分析，0.7-0.8之间一般适合，0.6-0.7之间不太适合，0.5-0.6之间表示差，0.5下表示极不适合，对于 Bartlett的检验（p &lt; 0.05,严格来说p &lt; 0.01），若显著性小于0.05或0.01，拒绝原假设，则说明可以做主成分分析</p><p>KMO检验的结果显示，KMO的值为0.713，同时，Bartlett球形检验的结果显示，显著性P值为0.000***，水平上呈现显著性，拒绝原假设，各变量间具有相关性，主成分分析有效，程度为一般。</p><p><strong>输出结果2：方差解释表格</strong>*</p><p><img src="https://bbs.spsspro.com/api/v2/files/1277" alt="image.png"></p><p>方差解释表中，在主成分3时，总方差解释的特征根低于1.0，变量解释的贡献率达到97.1%，所以我们选择三个主成分是有效的。</p><p>在这里，特征根的值是按照从大到小进行排序。</p><p><strong>输出结果3：碎石图</strong>*</p><p><img src="https://bbs.spsspro.com/api/v2/files/1278" alt="image.png"></p><p>碎石图是根据特征值下降的坡度来确认需要选择的主成分个数，当曲线变得平缓时，对应的因子数就可以作为参考因子数。由图可知，从第三个主成分开始，主成分的特征根值开始缓慢的下降，且在满足主成分累积解释的贡献率达到 90%的情况下，我们可以选择三个主成分。</p><p><strong>输出结果4：因子载荷系数表</strong></p><p><img src="https://bbs.spsspro.com/api/v2/files/1279" alt="image.png"></p><p>上表可以分析到每个主成分中隐变量的重要性。 第一个主成分与能力、品格、资本、担保这四个变量的相关程度较大，可以概括为“个人信用品质”；第二个主成分主与环境这一个变量的相关程度较大，可以概括为“外部政策影响”。</p><p><strong>输出结果5：因子载荷矩阵热力图</strong></p><p><img src="https://bbs.spsspro.com/api/v2/files/1280" alt="image.png"></p><p>上图可以分析到每个主成分中隐变量的重要性，热力图颜色越深说明相关性越大。第一个主成分与能力、品格、资本、担保这四个变量的相关程度较大，第二个主成分主与环境这一个变量的相关程度较大。</p><p><strong>输出结果6：因子载荷象限分析</strong></p><p><img src="https://bbs.spsspro.com/api/v2/files/1281" alt="image.png"></p><p>因子载荷图通过将多因子降维成双主成分或者三主成分，通过象限图的方式呈现主成分的空间分布。如果提取 3 个主成分时，则呈现三维载荷因子散点图。（二维图三维图可以自行选择）</p><p><strong>输出结果7：成分矩阵表</strong></p><p><img src="https://bbs.spsspro.com/api/v2/files/1282" alt="image.png"></p><p>由上表可得到主成分分析降维后的计算公式：</p><p>F1=0.259×能力+0.276×品格+0.244×担保+0.276×资本+0.102×环境</p><p>F2=-0.301×能力-0.12×品格+0.355×担保-0.185×资本+0.743×环境</p><p>F3=1.004×能力+0.254×品格-1.724×担保-0.128×资本+1.238×环境</p><p>由上可以得到： F=(0.691/0.971)×F1+(0.245/0.971)×F2+(0.036/0.971)×F3</p><p><strong>输出结果8：因子权重分析</strong>*</p><p><img src="https://bbs.spsspro.com/api/v2/files/1283" alt="image.png"></p><p>主成分分析的权重计算结果显示，主成分1的权重为71.126%、主成分2的权重为25.192%、主成分3的权重为3.681%。</p><p><strong>输出结果9：综合得分表</strong></p><p><img src="https://bbs.spsspro.com/api/v2/files/1284" alt="image.png"></p><p>由图可知，其中第10位客户的综合得分最高，也就是他的信用等级最高，其次是第15位客户。</p><p><strong>注：</strong></p><p>主成分要求变量之间的共线性或相关关系比较强，否则不能通过 KMO 检验和 Bartlett 球形检验； 主成分分析倾向于降维，从而达到简化系统结构，抓住问题实质的目的。（可侧重于输出结果 2、输出结果 3、输出结果 8）； 主成分分析时通常需要综合自己的专业知识，以及软件结果进行综合判断，即使是特征根值小于 1，也一样可以提取主成分； KMO 值为 null 不存在可能导致的原因为：1）样本量过少容易导致相关系数过高，一般希望分析样本量大于 5 倍分析项个数； （2）各个分析项之间的相关关系过高或过低。</p><h2 id="4-结论">4.结论</h2><p>主成分分析作为一个非监督学习的降维方法，它只需要特征值分解，就可以对数据进行压缩，去噪。因此在实际场景应用很广泛。通过对原始变量进行综合与简化，可以客观地确定各个指标的权重，避免主观判断的随意性。并且不要求数据呈正态分布，其就是按数据离散程度最大的方向对基组进行旋转，这特性扩展了其应用范围，比如，用于人脸识别。但同时，其适用于变量间有较强相关性的数据，若原始数据相关性弱，则起不到很好的降维作用（必须通过KMO和Bartlett的检验），并且降维后，存在少量信息丢失，不可能包含100%原始数据，原始数据经过标准化处理之后，含义会发生变化，且主成分的解释含义较原始数据比较模糊。</p><h2 id="5-PCA过程讲解">5.PCA过程讲解</h2><p>当数据维度太大时，我们通常需要进行降维处理，降维处理的方式有很多种，PCA主成分分析法是一种常用的一种降维手段，它主要是基于方差来提取最有价值的信息，虽然降维之后我们并不知道每一维度的数据代表什么意义，但是它将主要的信息成分保留了下来，那么PCA是如何实现的呢？</p><p>我们首先要知道基坐标的概念，基坐标其实就是我们定义的坐标轴，我们平时最常用的基坐标便是X，Y坐标轴，如果我们重新定义了一个基坐标，那么原来的点就需要和新的坐标轴的单位向量做内积，这样才能得到新的坐标轴上点的坐标，这个过程就是基变换，其实就是把原来的点投影到我们重新定义的基坐标轴上。</p><p>因为上面我们说了基坐标的概念，那么我们如何选择一个基坐标才能尽量保留更多的信息呢？一种直观的看法就是希望投影后的投影值尽可能分散，为什么呢？因为我们把原来的数据投影到新的坐标轴上，数据只有尽可能分散，那么我们才能更好的将数据区分开来，所以我们就要寻找一个基，使得所有数据变换为这个基上的坐标后，方差值最大，其实就是数据最分散。</p><p>但是还有一个问题，如果我们单纯只是选择方差最大的方向，后续方向应该会和方差最大的方向接近重合，其实就是我们的基坐标轴会重合在一起，听不懂也没关系，我们只需要知道我们需要让基坐标的各个坐标轴垂直，不垂直就不好就可以了。</p><p>我们需要让基坐标的各个坐标轴垂直的话，那么就有了协方差的概念，协方差其实就是判断两个特征之间的关系，如果我们让协方差等于0，那么两个特征就不相关了，也就是它们对应的基坐标其实就垂直了。</p><p>这就是我们优化的目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将一组N维向量降为K维（K大于0，小于N），目标是选择K个单位正交基，使 原始数据变换到这组基上后，各字段两两间协方差为0，字段的方差则尽可能大。</span><br></pre></td></tr></table></figure><h2 id="6-Q-A">6.Q&amp;A</h2><h4 id="Q-A">Q&amp;A</h4><p><strong>Q：为什么要做中心化</strong><br>**A：**中心化并不属于预处理，而是 PCA 本身流程的一部分。如果数据其中某一特征（矩阵的某一列）的数值特别大，那么它在整个误差计算的比重上就很大，那么可以想象在投影到低维空间之后，为了使低秩分解逼近原数据，整个投影会去努力逼近最大的那一个特征，而忽略数值比较小的特征。因为在建模前我们并不知道每个特征的重要性，这很可能导致了大量的信息缺失。为了“公平”起见，防止过分捕捉某些数值大的特征，我们会对每个特征先进行标准化处理，使得它们的大小都在相同的范围内，然后再进行PCA。</p><p>减去均值等同于坐标移动，这样就能把原始数据点的中心移到与原点重合。</p><p>附：<br>标准化是将每个特征(即矩阵的每一列)减去均值并除以标准差。除以标准差是为了统一并消除量纲。<br>归一化仅仅是指除以标准差或类似意思。</p><p><strong>Q：为什么选协方差矩阵</strong><br>**A：**因为目标函数就是要让方差最大，让协方差最小</p><p><strong>Q：为什么要找特征值和特征向量</strong><br>**A：**当协方差矩阵分解为特征向量和特征值之后，特征向量表示着变换方向，而特征值表示着伸缩尺度。在PCA中，特征值描述着数据间的协方差。我们可以按照特征值的大小降序排列特征向量，如此我们就按照重要性的次序得到了主成分排列。</p><p><strong>Q：为什么要让协方差最小</strong><br>**A：**如果我们单纯只选择方差最大的方向，很明显，第二个选择的维度与第一个维度应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让不同尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个维度不是完全独立，必然存在重复表示的信息。</p><p><strong>Q：主元成份分析（PCA）对输入数据的要求?</strong><br><strong>A：</strong><br>1.线形性假设。<br>PCA的内部模型是线性的。这也就决定了它能进行的主元分析之间的关系也是线性的。现在比较流行的kernel-PCA的一类方法就是使用非线性的权值对原有PCA技术的拓展。<br>2.使用中值和方差进行充分统计。<br>使用中值和方差进行充分的概率分布描述的模型只限于指数型概率分布模型。（例如高斯分布），也就是说，如果我们考察的数据的概率分布并不满足高斯分布或是指数型的概率分布，那么PCA将会失效。在这种模型下，不能使用方差和协方差来很好的描述噪音和冗余，对教化之后的协方差矩阵并不能得到很合适的结果。事实上，去除冗余的最基础的方程是：其中 代表概率分布的密度函数。基于这个方程进行冗余去除的方法被称作独立主元分析(ICA)方法(Independent Component Analysis)。不过，所幸的是，根据中央极限定理，现实生活中所遇到的大部分采样数据的概率分布都是遵从高斯分布的。所以PCA仍然是一个使用于绝大部分领域的稳定且有效的算法。<br>3.大方差向量具有较大重要性。<br>PCA方法隐含了这样的假设：数据本身具有较高的信噪比，所以具有最高方差的一维向量就可以被看作是主元，而方差较小的变化则被认为是噪音。这是由于低通滤波器的选择决定的。<br>4.主元正交。PCA方法假设主元向量之间都是正交的，从而可以利用线形代数的一系列有效的数学工具进行求解，大大提高了效率和应用的范围。</p><p><strong>Q：输入需要满足高斯么？</strong><br>**A：**这个问题请教了大牛，因为有时数据的分布并不是满足高斯分布。在非高斯分布的情况下，PCA方法得出的主元可能并不是最优的。在寻找主元时不能将方差作为衡量重要性的标准。要根据数据的分布情况选择合适的描述完全分布的变量，然后根据概率分布式来计算两个向量上数据分布的相关性。等价的，保持主元间的正交假设，寻找的主元同样要使。这一类方法被称为独立主元分解(ICA)。</p><p><strong>Q：样本数和特征维数有要求么？</strong><br>**A：**pca降维不需要样本的个数大于特征的维数，没有特别要求，如果降维到30*29，这个是因为映射到另一个空间了，无需担心丢失了很多信息，并非特征选择直接丢掉了特征了，只是在另一个空间而已表达出原空间的高维。因此，要保证训练样本和测试样本被映射到同一个特征空间，这样才能保证数据的一致性。</p><p><strong>Q：样本数小于特征维数怎么办？</strong><br>**A：**假设在3维空间中有N=2个点，N个点来自维度为N-1的manifold，因为2个点必然在一条直线上，即这2个点得到1维子空间，它们的方差是“spread”在这个1维子空间上的，和样本的维度并没有什么关系。也就是说，N个样本的方差是spread在N-1维子空间上，即只有N-1个components。</p><p>举个例子来说，有两个点(1,1,1),(2,2,2)，根据PCA的投影步骤：<br>(1)找到新的坐标系统的原点(1.5,1.5,1.5)<br>(2)两个点到新坐标轴的投影距离尽可能小，此处为0<br>(3)第一个component将是从(0,0,0)到(3,3,3)的直线，这个直线是使样本点投影到它后方差最大的一条线<br>(4)第二个component方向必须和第一个component正交，这条线可能是从(0,0,3)到(3,3,0)，或者(0,3,0)到(3,0,3)，但无论向谁投影，这两个点投影后它们的方差为0.<br>当样本数小于样本维度时，出现的这种现象就是“the curse of dimensionality”</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分析模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊综合评价</title>
      <link href="/2022/09/08/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/"/>
      <url>/2022/09/08/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<h1>模糊综合评价</h1><p>模糊综合评价的实质是通过“<a href="https://www.zhihu.com/search?q=%E9%9A%B6%E5%B1%9E%E5%BA%A6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%2265802503%22%7D">隶属度</a>”的概念，来计算每一个要素的隶属度向量：虽不能给出准确的答案，但是可以给出要素处于某一状态的概率。<strong>个人的感觉，很像薛定谔方程用波函数来描述单个粒子处于某一位置的概率。</strong></p><p>模糊综合评价法并非是让二值逻辑的结果更客观，<strong>而是彻底摒弃了{0,1}的二值逻辑，改用[0,1]的区间取值来描述要素的状态</strong>，能把主观性的数据尽量客观化，<strong>方法的核心是模糊算子的选择</strong>，本质是一种数据处理的方法。</p><blockquote><p><strong>1.建立综合评价的因素集</strong><br><a href="https://i.loli.net/2020/02/04/iWFAPeQa3kc96Kt.png"><img src="https://i.loli.net/2020/02/04/iWFAPeQa3kc96Kt.png" alt="image.png"></a><br><strong>2.建立综合评价的评价集</strong><br><a href="https://i.loli.net/2020/02/04/Ar3expYbJXVCj7L.png"><img src="https://i.loli.net/2020/02/04/Ar3expYbJXVCj7L.png" alt="image.png"></a><br><strong>3.进行单元素模糊评价，获得评价矩阵</strong><br><a href="https://i.loli.net/2020/02/04/pH26unJlESLYKZ9.png"><img src="https://i.loli.net/2020/02/04/pH26unJlESLYKZ9.png" alt="image.png"></a><br><strong>4.确定因素权向量</strong><br><a href="https://i.loli.net/2020/02/04/WN4a9Knukd5oh1H.png"><img src="https://i.loli.net/2020/02/04/WN4a9Knukd5oh1H.png" alt="image.png"></a><br><strong>5.建立综合评价模型</strong><br><a href="https://i.loli.net/2020/02/04/OIoYlxQjsV1greF.png"><img src="https://i.loli.net/2020/02/04/OIoYlxQjsV1greF.png" alt="image.png"></a><br><a href="https://i.loli.net/2020/02/04/njQg5yq93vuCXYN.png"><img src="https://i.loli.net/2020/02/04/njQg5yq93vuCXYN.png" alt="image.png"></a><br><strong>6.确定系统总得分</strong><br><a href="https://i.loli.net/2020/02/04/dLfOj9tx2JHqBP5.png"><img src="https://i.loli.net/2020/02/04/dLfOj9tx2JHqBP5.png" alt="image.png"></a><br><strong><a href="https://zhuanlan.zhihu.com/p/32666445">https://zhuanlan.zhihu.com/p/32666445</a></strong></p></blockquote><h3 id="隶属度函数选取与构造">隶属度函数选取与构造</h3><blockquote><p>常用的方法：<strong>直觉方法，二元对比排序法，模糊统计试验法，最小模糊度法</strong>（根据先验知识和采集的数据，确定出描述模糊概念的候选隶属函数，利用最小化模糊度的原则计算相关的参数，进而获得合适的隶属函数）。<br>下面介绍三种最常用的隶属度函数：<strong>三角形隶属度函数、梯形隶属度函数、高斯型隶属度函数：</strong><br><strong>三角形隶属度函数</strong><br><a href="https://i.loli.net/2020/02/04/GUTEVZDzRcYHXv3.png"><img src="https://i.loli.net/2020/02/04/GUTEVZDzRcYHXv3.png" alt="image.png"></a><br><strong>梯形隶属度函数</strong><br><a href="https://i.loli.net/2020/02/04/TmEJY6WvuNxO23t.png"><img src="https://i.loli.net/2020/02/04/TmEJY6WvuNxO23t.png" alt="image.png"></a><br><strong>高斯型隶属度函数</strong><br><a href="https://i.loli.net/2020/02/04/uqkzCd7jrvbMpmw.png"><img src="https://i.loli.net/2020/02/04/uqkzCd7jrvbMpmw.png" alt="image.png"></a><br><strong><a href="https://zhuanlan.zhihu.com/p/37616833">https://zhuanlan.zhihu.com/p/37616833</a></strong></p></blockquote><h1>模糊综合评价是用各个区别来评价，具体权重可使用层次分析法。</h1><p>各个取权重方法：</p><p><img src="https://pic2.zhimg.com/80/v2-58abf2aa3dc8ecb23ed28cffe9ceb18f_720w.jpg" alt="img"></p><h2 id="可参考论文：">可参考论文：</h2><p><a href="http://www.huaxuejia.cn/ism/good_paper/001.pdf">001.pdf (huaxuejia.cn)</a></p><p>上面一篇就是模糊综合评价的论文。</p><p>用ANP求得权重。</p><p><img src="https://pic1.zhimg.com/80/v2-0e82c7b05571dc08cd34edda35396c38_720w.jpg?source=1940ef5c" alt="img"></p><p>第58页开始就是模糊综合评价。</p><p>上面是10个专家的评分情况，把牛逼，非常好，垃圾等评语转化成数值型。</p><p><img src="https://pic1.zhimg.com/50/v2-1517f943bc858fc6659c038d23ef37ea_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-1517f943bc858fc6659c038d23ef37ea_720w.jpg?source=1940ef5c" alt="img"></p><p>63页就是给出结果。</p><h2 id="优缺点">优缺点</h2><h3 id="优点：">优点：</h3><ul><li>结果清晰，</li><li>系统性强</li><li>能较好地解决模糊的、难以量化的问题</li><li>适合各种非确定性问题的解决。</li></ul><p>模糊综合评价法的优点</p><p>(1)模糊评价通过精确的数字手段处理模糊的评价对象，能对蕴藏信息呈现模糊性的资料作出比较科学、合理、贴近实际的量化评价；</p><p>(2)评价结果是一个矢量，而不是一个点值，包含的信息比较丰富，既可以比较准确的刻画被评价对象，又可以进一步加工，得到参考信息。</p><h3 id="缺点：">缺点：</h3><p>(1)计算复杂，对指标权重矢量的确定主观性较强；</p><p>(2)当指标因素集U UU较大，即指标集个数凡较大时，在权矢量和为1的条件约束下，相对隶属度权系数往往偏小，权矢量与模糊矩阵R不匹配，结果会出现超模糊现象，分辨率很差，无法区分谁的隶属度更高，甚至造成评判失败，此时可用分层模糊评估法加以改进。</p><h2 id="相关术语">相关术语</h2><p>1．评价因素（F）：是指对招标项目评议的具体内容（例如，价格、各种指标、参数、规范、性能、状况，等等）。</p><p>为便于权重分配和评议，可以按评价因素的属性将评价因素分成若干类（例如，商务、技术、价格、伴随服务，等），把每一类都视为单一评价因素，并称之为第一级评价因素（F1）。第一级评价因素可以设置下属的第二级评价因素（例如，第一级评价因素“商务”可以有下属的第二级评价因素：交货期、付款条件和付款方式，等）。第二级评价因素可以设置下属的第三级评价因素（F3）。依此类推。</p><p>2．评价因素值（Fv）：是指评价因素的具体值。例如，某投标人的某技术参数为120，那么，该投标人的该评价因素值为120。</p><p>3．评价值（E）：是指评价因素的优劣程度。评价因素最优的评价值为1（采用百分制时为100分）；欠优的评价因素，依据欠优的程度，其评价值大于或等于零、小于或等于1（采用百分制时为100分），即0≤E≤1（采用百分制时0≤E≤100）。</p><p>4．平均评价值（Ep）：是指评标委员会成员对某评价因素评价的平均值。</p><p>平均评价值（Ep）=全体评标委员会成员的评价值之和÷评委数</p><p>5．权重（W）：是指评价因素的地位和重要程度。</p><p>第一级评价因素的权重之和为1；每一个评价因素的下一级评价因素的权重之和为1 。</p><p>6．加权平均评价值（Epw）：是指加权后的平均评价值。</p><p>加权平均评价值（Epw）=平均评价值（Ep）×权重（W）。</p><p>7．综合评价值（Ez）：是指同一级评价因素的加权平均评价值（Epw）之和。综合评价值也是对应的上一级评价。</p><h2 id="推荐博客">推荐博客</h2><p><a href="http://t.csdn.cn/H7LGr">http://t.csdn.cn/H7LGr</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 评价模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规划算法</title>
      <link href="/2022/09/08/%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>规划算法</h1><h2 id="前言">前言</h2><p>随着机器人技术、智能控制技术、硬件传感器的发展，机器人在工业生产、军事国防以及日常生活等领域得到了广泛的应用。而作为机器人行业的重要研究领域之一，移动机器人行业近年来也到了迅速的发展。移动机器人中的路径规划便是重要的研究方向。移动机器人的路径规划方法主要分为传统的路径规划算法、基于采样的路径规划算法、智能仿生算法。传统的路径规划算法主要有A算法、Dijkstra算法、D算法、人工势场法，基于采样的路径规划算法有PRM算法、RRT算法，智能仿生路径规划算法有神经网络算法、蚁群算法、遗传算法等。</p><p><img src="http://a1.qpic.cn/psc?/V12XQ1QV3cpyPD/ruAMsa53pVQWN7FLK88i5uGjm7E2E.Xd6x6VWLqZ6JH73cViDfxum2J5dBYHYTWczBVrOka0RsbahR9ZOZCEcrjHR9i50rrB3.qj42RA25o!/c&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=NwIpAQAAAAADFy8!&amp;tl=1&amp;vuin=1005741898&amp;tm=1658455200&amp;dis_t=1658457012&amp;dis_k=80974f44f7c70f3bf82f7beb7b877ba9&amp;sce=60-2-2&amp;rf=viewer_4" alt="img"></p><h2 id="传统路径规划算法">传统路径规划算法</h2><h2 id="1-Dijkstra算法">1.<a href="https://so.csdn.net/so/search?q=Dijkstra%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">Dijkstra算法</a></h2><p>Dijkstra算法是Edsger Wybe Dijkstra在1956年提出的一种用来寻找图形中结点之间最短路径的算法。Dijkstra算法的基本思想是贪心思想，主要特点是以起始点为中心向外层层扩展，直到扩展到目标点为止。Dijkstra算法在扩展的过程中，都是取出未访问结点中距离该点距离最小的结点，然后利用该结点去更新其他结点的距离值。<br>Dijkstra算法流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.将初始点s放入到集合S中，初始时集合S中只有s；</span><br><span class="line">2.无自环的初始点s到自己的最短路径为0；</span><br><span class="line">3.For（目标点ei不在集合S中）：</span><br><span class="line">4.   计算集合S中以外的所有结点到集合S中结点的最短距离，即从s出发，到达所有结点且只允许通过初始点s的最短路径。如果没有直达的通路，那么就设置为无穷，意味着暂时到达不了的结点。</span><br><span class="line">5.While（集合V-S不是空集）：</span><br><span class="line">6.   选出第一次for循环之后在集合V-S中，且相对于集合S的最短路径中距离最短的目标点ej。</span><br><span class="line">7.   将该目标点ej并入到集合S中。</span><br><span class="line">8.   将目标点ej并入集合S之后会对V-S以外的顶点相对于集合S的最短路径长度产生影响。</span><br><span class="line">9.   For（更新S中的结点路径）</span><br><span class="line">10.      If（dist[s,ej]+wj,i &lt; dist[s,ei]）</span><br><span class="line">11.         dist[s,ei] = dist[s,ej]+wj,i</span><br></pre></td></tr></table></figure><p>注：该算法不允许图中存在负权边。</p><p><img src="http://m.qpic.cn/psc?/V12XQ1QV3cpyPD/ruAMsa53pVQWN7FLK88i5rjTJ4P3sWPbRRBCHCNSeW94NYcHm9fev2BvFSd1FAiZhzDKRv1LjT6nKNUjIhArcqhngXz9YEb3ELz94NQ4dgg!/b&amp;bo=0AJdAQAAAAACN50!&amp;rf=viewer_4" alt="img"></p><p>优点：<br>1） 如果最优路径存在，那么一定能找到最优路径<br>缺点：<br>1） 有权图中可能是负边<br>2） 扩展的结点很多，效率低</p><h3 id="2-A-算法">2.A*算法</h3><p>A<em>算法发表于1968年，A</em>算法是将Dijkstra算法与广度优先搜索算法（BFS）二者结合而成，通过借助启发式函数的作用，能够使该算法能够更快的找到最优路径。A<em>算法是静态路网中求解最短路径最有效的直接搜索方法。A</em>算法的启发式函数：f(n)=g(n)+h(n)</p><p>f(n)表示结点的综合优先级，在选择结点时考虑该结点的综合优先级；<br>g(n)表示起始点到当前结点的代价值；<br>h(n)表示当前结点到目标点的代价估计值，启发式函数。</p><p>当h(n)趋近于0时，此时算法退化为Dijkstra算法，路径一定能找到，但速度比较慢；当g(n)趋近于0时，算法退化为BFS算法，不能保证一定找到路径，但速度特别快。我们可以通过调节h(n)的大小来调整算法的精度与速度。<br>在A算法中，采用最多的是欧几里得距离，即dist = srqt((y2-y1)2+(x2-x1)2)。<br>A算法流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.将起始点s加入到开启列表openlist中</span><br><span class="line">2.重复以下过程：</span><br><span class="line">a)遍历开启列表openlist，寻找F值最小的结点，并将其作为当前要处理的结点</span><br><span class="line">b)将要处理的结点移到关闭列表closelist</span><br><span class="line">c)对当前结点的8个相邻结点的每个结点：</span><br><span class="line">i.如果他是不可抵达的或者已经在关闭列表closelist中，忽略； </span><br><span class="line">ii.如果他不在开启列表openlist中，将其加入openlist，并把当前结点设置为其父节点，记录当前结点的F、G、H值；</span><br><span class="line">iii.如果他已经在开启列表openlist中，检查这条路径（即经由当前结点到达相邻结点）是否更好，用G值做参考，更小的G值表示这个更好的路径，如果是这样，将其父节点设置为当前结点，并重新计算他的G值和F值，如果开启列表openlist是按F值进行排序，改变后需要重新排序。</span><br><span class="line">d)停止，当</span><br><span class="line">i.终点加入到了开启列表openlist中，此时路径已经找到</span><br><span class="line">ii.查找重点失败，并且开启列表openlist中是空的，此时没有路径</span><br><span class="line">3.保存路径，从终点开始，每个结点沿着其父节点移动直到起点。</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5qzWZEsi8M92IMB.cuIBcBTKuyDnt.I7i3ZnjKM3JynMNUVotCRUokba9So9NPVxASW6BvEYbDGvyJuk4uk2vIs!/b&amp;bo=JgHdAAAAAAABB9o!&amp;rf=viewer_4" alt="img"></p><p><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5qrzfmRpXP9qnoSM4GDTu3IPKQJ67CSeR41gFzWLm738ksZLxmPVuEJp4B5BGteBp8yxrPzHig.o7XviQhcMCCk!/mnull&amp;bo=.gDjAAAAAAABBzk!&amp;rf=photolist&amp;t=5" alt="img"></p><p><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5qrzfmRpXP9qnoSM4GDTu3KmcEC1F9M0V5LQMFO.RJfAXeJwyutv140OWhrOTTx8dfawULjWKQfA7HJX*JSc4D8!/mnull&amp;bo=FAEgAQAAAAABBxQ!&amp;rf=photolist&amp;t=5" alt="img"></p><p>优点：<br>1） 利用启发式函数，搜索范围小，提高了搜索效率<br>2） 如果最优路径存在，那么一定能找到最优路径<br>缺点：<br>1） A<em>算法不适用于动态环境2） A</em>算法不太适合于高维空间，计算量大<br>3） 目标点不可达时会造成大量性能消耗</p><h3 id="3-D算法">3.D算法</h3><p>D算法是卡耐基梅隆机器人中心的Stentz在1994年提出的主要用于机器人探路，并且美国火星探测器上就是应用的D<em>路径规划算法。A</em>算法适用于在静态路网中寻路，在环境变化后，往往需要replan，由于A<em>不能有效利用上次计算的信息，故计算效率较低。D</em>算法由于储存了空间中每个点到终点的最短路径信息，故在重规划时效率大大提升。A*是正向搜索，而D特点是反向搜索，即从目标点开始搜索过程。在初次遍历时候，与Dijkstra算法一致，它将每个节点的信息都保存下来。</p><p><code>D*</code>算法流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.先用Dijkstra算法从目标节点G向起始节点搜索。储存路网中目标点到各个节点的最短路和该位置到目标点的实际值h，k（k为所有变化h之中最小的值，当前为k=h）原OPEN和CLOSE中节点信息保存。</span><br><span class="line">2.机器人沿最短路开始移动，在移动的下一节点没有变化时，无需计算，利用上一步Dijkstra计算出的最短路信息从出发点向后追述即可，当在Y点探测到下一节点X状态发生改变，如堵塞。机器人首先调整自己在当前位置Y到目标点G的实际值h（Y），h（Y）=X到Y的新权值C（X，Y）+X的原实际值h（X）。X为下一节点（到目标点方向Y-&gt;X-&gt;G），Y是当前点。K值去h值变化前后的最小。</span><br><span class="line">3.用A*或其他算法计算，这里假设用A*算法，遍历Y的子节点，放入CLOSE，调整Y的子节点a的h值，h（a）=h（Y）+Y到子节点a的权重C（Y，a），比较a点是否存在于OPEN和CLOSE中，方法如下：用A*或者其他算法计算，这里假设用A*算法，遍历Y的子节点，放入CLOSE，调整Y的子节点a的h值，h（a）=h（Y）+Y到子节点a的权重C（Y，a），比较a点是否存在于OPEN和CLOSE中，方法如下：</span><br><span class="line">while()</span><br><span class="line">&#123;</span><br><span class="line">从OPEN表中取k值最小的节点Y;</span><br><span class="line">遍历Y的子节点a,计算a的h值 h(a)=h(Y)+Y到子节点a的权重C(Y,a)</span><br><span class="line">&#123;</span><br><span class="line">    if(a in OPEN)     比较两个a的h值 </span><br><span class="line">    if( a的h值小于OPEN表a的h值 )</span><br><span class="line">    &#123;</span><br><span class="line">更新OPEN表中a的h值;k值取最小的h值</span><br><span class="line">          有未受影响的最短路经存在</span><br><span class="line">          break; </span><br><span class="line">    &#125;</span><br><span class="line">    if(a in CLOSE) 比较两个a的h值 //注意是同一个节点的两个不同路径的估价值</span><br><span class="line">    if( a的h值小于CLOSE表的h值 )</span><br><span class="line">    &#123;</span><br><span class="line">更新CLOSE表中a的h值; k值取最小的h值;将a节点放入OPEN表</span><br><span class="line">       有未受影响的最短路经存在</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a not in both)</span><br><span class="line">        将a插入OPEN表中;　//还没有排序</span><br><span class="line">&#125;</span><br><span class="line">放Y到CLOSE表；</span><br><span class="line">OPEN表比较k值大小进行排序；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5jdxg7pj4rCA2IeLJrAGjYOl0XyBZ*auzyYB6qjDWBjob2jrum*f8vqGcg5F8FRROWo8wRQO.xmMEdVKR2D12uU!/mnull&amp;bo=fgLMAQAAAAACB5I!&amp;rf=photolist&amp;t=5" alt="img"></p><p>优点：<br>1）适用于动态环境的路径规划，搜索效率高<br>缺点：<br>1） 不适用于高维空间，计算量大<br>2） 不太适用于在距离较远的最短路径上发生变化的场景</p><h3 id="4-人工势场法">4.人工势场法</h3><p>人工势场法是由Khatib在1985年提出的一种基于虚拟力场的局部路径规划算法，该算法的基本思想是当机器人在周围环境中运动时，将环境设计成一种抽象的人造引力场，目标点对移动机器人产生“引力”，障碍物对移动机器人产生“斥力”，最后通过二者的合力来控制移动机器人的运动。应用人工势场法规划出来的路径一般是比较平滑并且安全的，但是存在着局部最优的问题。<br>利用势场函数U来建立人工势场，势场函数是一种可微函数，空间中某点处势场函数值的大小，代表了该点的势场强度。我们采用引力势场函数与斥力势场函数，用U（q）表示二者之和。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>U</mi><mrow><mi>a</mi><mi>t</mi><mi>t</mi></mrow></msub><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>U</mi><mrow><mi>r</mi><mi>e</mi><mi>p</mi></mrow></msub><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(q)=U_{a t t}(q)+U_{r e p}(q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">tt</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></span></p><p>引力势场函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>U</mi><mtext>attr </mtext></msub><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>ξ</mi><msup><mi>ρ</mi><mn>2</mn></msup><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><msub><mi>q</mi><mtext>goal </mtext></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">U_{\text {attr }}(q)=\frac{1}{2} \xi \rho^{2}\left(q, q_{\text {goal }}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">attr </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">goal </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>e表示引力增益，p(q,qgoal)表示当前点到目标点的距离；<br>斥力势场函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>U</mi><mrow><mi>r</mi><mi>e</mi><mi>p</mi></mrow></msub><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>ρ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><msub><mi>q</mi><mrow><mi>o</mi><mi>b</mi><mi>s</mi></mrow></msub><mo fence="true">)</mo></mrow><mo>&gt;</mo><msub><mi>ρ</mi><mn>0</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>η</mi><msup><mrow><mo fence="true">(</mo><mfrac><mn>1</mn><mrow><mi>ρ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><msub><mi>q</mi><mrow><mi>o</mi><mi>b</mi><mi>s</mi></mrow></msub><mo fence="true">)</mo></mrow></mrow></mfrac><mo>−</mo><mfrac><mn>1</mn><msub><mi>ρ</mi><mn>0</mn></msub></mfrac><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>ρ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><msub><mi>q</mi><mrow><mi>o</mi><mi>b</mi><mi>s</mi></mrow></msub><mo fence="true">)</mo></mrow><mo>≤</mo><msub><mi>ρ</mi><mn>0</mn></msub></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">U_{r e p}(q)\left\{\begin{array}{cc}0 &amp; \rho\left(q, q_{o b s}\right)&gt;\rho_{0} \\\frac{1}{2} \eta\left(\frac{1}{\rho\left(q, q_{o b s}\right)}-\frac{1}{\rho_{0}}\right)^{2} &amp; \rho\left(q, q_{o b s}\right) \leq \rho_{0}\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.204em;vertical-align:-1.352em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.852em;"><span style="top:-4.366em;"><span class="pstrut" style="height:3.354em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.652em;"><span class="pstrut" style="height:3.354em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.354em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.352em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.852em;"><span style="top:-4.366em;"><span class="pstrut" style="height:3.354em;"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.652em;"><span class="pstrut" style="height:3.354em;"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.352em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>n表示斥力增益，p(q,qgoal)表示当前点到障碍物的距离，p0表示障碍物作用距离阈值。</p><p>优点：<br>1） 规划出的路径一般是比较平滑且安全<br>2） 人工势场法是一种反馈控制策略，具有一定的鲁棒性<br>缺点：<br>1） 容易陷入局部最优的问题<br>2） 距离目标点较远时，引力特别大，斥力相对较小，可能会发生碰撞<br>3） 当目标点附近有障碍物时，斥力非常大，引力较小，很难到达目标点</p><h2 id="二、基于采样路径规划算法">二、基于采样路径规划算法</h2><h2 id="1-PRM算法">1.PRM算法</h2><p>随机路线图（PRM）算法是一种基于图搜索的算法，可以将连续状态空间转换成离散状态空间，在利用A＊等搜索算法在路线图上寻找路径，提高搜索效率。PRM算法是概率完备且不是最优的算法。<br>PRM算法流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.初始化，设G（V，E）为一个无向图，其中顶点集V代表无碰撞的状态点，连线集E代表无碰撞的路径。初始状态为空。</span><br><span class="line">2.状态点采样，在状态空间中采样无碰撞的状态点加入到无碰撞的状态点V中。</span><br><span class="line">3.邻域计算，定义距离p，对于已经存在于无碰撞的状态点V中的点，如果他与无碰撞的点的距离小于p，则将其称作无碰撞状态点的邻域点。</span><br><span class="line">4.边线连接，将无碰撞的状态点与其邻域相连，生成连线。</span><br><span class="line">5.碰撞检测，检测连线是否与障碍物发生碰撞，如果无碰撞，则将其加入到连线集E中。</span><br><span class="line">6.结束条件，当所有采样点均已完成上述步骤后结束，否则重复2~5。</span><br><span class="line">7.最后使用A*算法在路线图上寻找最优路径。</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5rT.6XgE9qMbv7qpZkbprTfwyRg3E3mDhswFma4S2xFbRuuDMmuAt4xOnu3Zy.HAMeB0AXBpZlFq93ew7VAuxYA!/b&amp;bo=*AFnAQAAAAACF6g!&amp;rf=viewer_4" alt="img"></p><p>优点：<br>1） 适用于高维空间和复杂约束的路径规划问题<br>2） 搜索效率高，搜索速度快<br>缺点：<br>1）概率完备但不是最优</p><h3 id="2-RRT算法">2.RRT算法</h3><p>RRT算法是适用于高维空间，通过对状态空间中的采样点进行碰撞检测，避免了对空间的建模，较好的处理带有非完整约束的路径规划问题，有效的解决了高维空间和复杂约束的路径规划问题。该算法是概率完备但不是最优的算法。</p><p>RRT算法以初始点qinit作为根节点，通过随机采样增加叶子节点的方式，生成一个随机扩展树，当目标点位于随机扩展树上时，能够找到一天初始点到目标点的路径。首先，需要从状态空间中随机选择一个采样点qrand，然后从随机树中选择一个距离qrand最近的结点qnearest，从qnearest向qrand扩展一个步长的距离，得到一个新的结点qnew，如果qnew与障碍物发生碰撞，则返回空；否则，将qnew加入到随机树中，重复上述步骤直到qnearest和qgoal距离小于一个阈值。<br><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5uGjm7E2E.Xd6x6VWLqZ6JH5zhpzqlttYZubIi9IOMELsUwqSaYIRpKv1RNsmj5Fd7uE0ib1t8U*hIm.DLL5zUc!/b&amp;bo=wgHCAQAAAAACByM!&amp;rf=viewer_4" alt="img"></p><p><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5pdu5oCPm1yC.xULnWwGncroHqZODzppCOYIpBpHNchglD2XgUH96hGvcloGfIFA*bQFcjFR8l.WzbpnkKxrC.M!/b&amp;bo=wgHCAQAAAAACByM!&amp;rf=viewer_4" alt="img">优点：</p><p>优点：</p><p>1） 搜索效率比较高，搜索速度比较快<br>2） 适用于高维空间，不会产生维度灾难的问题<br>3） 只需对状态空间采样点进行碰撞检测，避免了对空间的建模</p><p>缺点：</p><p>1） 规划出的路径质量一般，可能存在棱角、不够光滑<br>2） RRT算法不太适用于存在狭长空间的环境<br>3） 规划出的路径可能不是最优路径<br>4） 不适用于动态环境的路径规划</p><h2 id="三、智能仿生算法">三、智能仿生算法</h2><h3 id="1-神经网络算法">1.神经网络算法</h3><p>优点：<br>1） 适合于动态复杂环境<br>2） 适用于高维空间，避免维度灾难的问题<br>缺点：<br>1） 对硬件的要求比较高<br>2） 参数调节比较困难</p><h3 id="2-蚁群算法">2.蚁群算法</h3><p>蚁群算法（Ant Colony Optimization，ACO）是Dorigo在1992年提出的一种用来寻找优化路径的概率型算法，是由一群无智能或有轻微智能的个体通过相互写作而表现出智能行为，为求解复杂问题提供了一个新的可能性。该算法的主要思想是蚂蚁在寻找食物过程中发现路径的行为。该算法具有分布计算、信息正反馈和启发式搜索的特征，本质上是进化算法中的一种启发式全局优化算法。<br>蚁群算法的基本原理是利用蚂蚁在觅食过程中会释放信息素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.初始时刻，路径没有任何信息素，蚂蚁会以一定的随机性选择任意方向</span><br><span class="line">2.更新信息素矩阵，当有信息素时，蚂蚁会优先选择信息素浓度高的路径</span><br><span class="line">3.那么在相同时间内，信息素的浓度与路径长度成反比，越短的路径会有更多的信息素，那么后续的蚂蚁会选择信息素浓度高的路径，最优路径上的信息素浓度会越来越高</span><br><span class="line">4.随着时间的推移，信息素会自行挥发</span><br><span class="line">5.最终，能选择出一条最优路径即信息素浓度高的路径</span><br></pre></td></tr></table></figure><p>影响蚁群算法的因素：<br>1） 信息素如何撒播<br>2） 信息素如何挥发<br>3） 以何种方式让蚂蚁选择运动方向，减少盲目性和不必要性<br>4） 给予蚂蚁和环境一定的记忆能力能够帮助减少搜索空间<br>个体分布越均匀，种群多样性就越好，得到全局最优解的概率就越大，但是寻优时间就越长；个体分布越集中，种群多样性就越差，不利于发挥算法的探索能力。正反馈加快了蚁群算法的收敛速度，却使算法较早地集中于部分候选解，因此正反馈降低了种群的多样性，也不利于提高算法的全局寻优能力。<br><img src="http://m.qpic.cn/psc?/V12XQ1QV2XlKPv/ruAMsa53pVQWN7FLK88i5pdu5oCPm1yC.xULnWwGncqpYaAMKuNoQeVXoYsKZPOBpjgJ1fDr3cJKT49AFYogelVv1gPBy.T7b8HZoAZw6jg!/mnull&amp;bo=WwH0AAAAAAADB4w!&amp;rf=photolist&amp;t=5" alt="img"></p><p>优点：<br>1） 蚁群算法的鲁棒性强<br>2） 采用正反馈机制，能够逼近最优解<br>3） 易与其他算法进行结合<br>缺点：<br>1） 盲目的随机搜索，搜索时间较长，搜索速度慢<br>2） 蚁群算法容易陷入局部最优<br>3） 蚁群算法参数的选择依赖于经验或试错</p><h3 id="3-遗传算法">3.遗传算法</h3><p>遗传算法（Genetic Algorithm，GA）是由John Holland于20世纪70年代提出，该算法是根据大自然中生物体进化规律而设计提出的，来模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p><p><img src="http://m.qpic.cn/psc?/V12XQ1QV3cpyPD/ruAMsa53pVQWN7FLK88i5hxcI9YFYZf8uDa7rxRl27GqrEcJMDcHY2GuI2qlJdngDf8ZeMeq0APTSwS5WYkEohohtoTj*yg4ETbgh4pHw*c!/b&amp;bo=ywAIAQAAAAABB.I!&amp;rf=viewer_4" alt="img"></p><p>遗传算法的流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.评估每条染色体所对应个体的适应度</span><br><span class="line">While（未找到满意的解）：</span><br><span class="line">2.遵照适应度越高，选择概率越大的原则，从种群中选择两个个体作为父方和母方</span><br><span class="line">3.抽取父母双方的染色体，进行交叉，产生子代</span><br><span class="line">4.对子代的染色体进行变异</span><br></pre></td></tr></table></figure><p>优点：</p><p>1） 遗传算法具有广泛的应用领域<br>2） 遗传算法具有群体搜索的特性<br>3） 遗传算法基于概率规则，搜索更为灵活</p><p>4） 遗传算法直接以目标函数作为搜索信息，不涉及目标函数值求微分的过程</p><p>缺点：</p><p>1） 遗传算法效率比较低</p><p>2） 遗传算法容易过早收敛<br>3） 遗传算法在编码时容易出现不规范不准确的问题</p><h2 id="优秀博客">优秀博客</h2><p><a href="https://blog.csdn.net/qq_45875106/article/details/121314604">https://blog.csdn.net/qq_45875106/article/details/121314604</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规划算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次分析法ahp</title>
      <link href="/2022/09/08/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95ahp/"/>
      <url>/2022/09/08/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95ahp/</url>
      
        <content type="html"><![CDATA[<h1>层次分析法(AHP)</h1><h2 id="定义：">定义：</h2><p>通过构建一套多层次的评价指标体系，完成对定性指标的定量化分析。</p><h2 id="运用范围：">运用范围：</h2><p>运用于多目标、多准则、多要素、多层次的非结构化的复杂决策问题，特别是战略决策问题，可以较好地解决多要素相互关联、相互制约的复杂系统的评价。</p><p>比如： 旅游出行，评定信用，多角度评价产品优劣。</p><p>举个栗子：如TA爱你的程度，可以用联系你的频率、关心你的程度、为你付出时间、为你付出的购买力等因素。先对这几个指标进行权重赋值，随后结合你的TA这些指标相应的得分，进行权重*得分的乘积运算，并将所有要素进行加和，即可得到TA爱你的程度（指数，手动狗头·-·）</p><p>在实际工作中，层次分析法经常和德尔菲法、百分权重法结合，用于确定评价指标的权重。</p><h2 id="历史案例">历史案例</h2><p>1971年AHP首次应用于美国国防部研究“应急计划”，随后又开展了多项研究，奠定了AHP在定性研究领域的基础，1982年AHP在“中美能源、资源、环境”学术会议上被首次介绍到中国。</p><p>喵博士结合相关研究现状，梳理了当前主要涉及领域应用如下：适宜性评价、环境保护措施评价、安全性评价、危化物危害性评价、城市应急灾害能力评价、空间格局安全性评价。同时，亦可用于指导消费者在生活领域决策提供一定指导，如购房影响因素评价、购车影响因素评价、专业选择与就业倾向评价等，均可以发挥其优秀的功效。</p><p><img src="https://pics5.baidu.com/feed/4ec2d5628535e5ddac99dde8547069eacf1b628f.jpeg?token=256692222f730ac8d72ecd9c8bd9af5a&amp;s=1E2870238D2178135A7CB1DB0100C0B2" alt=""></p><p>如在居住区适宜性评价（如上图）时，根据既有研究成效，居住区园林景观适宜性评价可以划分为：绿化种植景观、道路景观、场所景观、硬质景观、水景景观和庇护性景观等六个一级指标（准则层），每个一级指标又可以细分为若干二级指标，以完成定性指标的定量化分析。</p><h2 id="分析方法">分析方法</h2><p>基于层次分析法（AHP）先分解后综合的基本工作思路，先将要分析的要素进行层次化、步骤化，构建形成多层次分析评价模型，最终确定各层级指标的重要程度（权重），或优先次序。</p><p>AHP把一个复杂的问题表示为一个有序的递阶层次结构，并通过主管判断和科学计算给出备选方案的优劣顺序（或权重）。简而言之，层次分析法人如其名，首先要构建合理的层次，其次要分析层次内部各因素的优劣。</p><p>层次分析法的使用流程：</p><ol><li><p>根据需求对目标层进行分解，如适宜性可以分解为6个一级指标；</p></li><li><p>建立层次结构图，及判断矩阵；</p></li><li><p>计算权重系数（主要基于德尔菲法，或曰专家打分，对各指标要素的权重进行赋值）；</p></li><li><p>进行一致性检验（在AHP软件中可自行设定），若一致性指标CR&lt;0.1，则满足研究需要，进入下一环节。不满足时则需要对各指标权重重新赋值（重新进行第三步分析）；</p></li><li><p>层次总排序，选出最优方案。</p></li></ol><p>分三层一般：目标层，准则层，方案层</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d476b972c13221d3e1223b1fd5d6782b.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/30dd8e4cdafed2d56d337794fa610dcb.png" alt="img"></p><p><img src="https://pics1.baidu.com/feed/21a4462309f7905213c9b0422e4519cf7acbd530.jpeg?token=1678b5a7bb443bebefbcd12957df63e3&amp;s=5AA8346319DFC0CA5E5DB1CB0000E0B1" alt=""></p><p>如在评价购房影响要素时，可以细分为房价要素、区位要素、户型要素、口碑要素等一级指标，并分别对各一级要素进行深度开发，构建相应的二级评价指标以完成对一级指标的评价。</p><h2 id="步骤分解">步骤分解</h2><p><strong>1）建立层次结构模型</strong></p><p>将决策的目标（城市空间格局安全）、考虑的决策准则因素（空间结构安全、空间要素安全、空间环境安全）和决策对象按它们之间的相互关系分为最高层、中间层和最低层，绘出层次结构图。</p><p><img src="https://pics5.baidu.com/feed/cdbf6c81800a19d8ecaeddad114c4c8ea71e4620.jpeg?token=e56a2d51003c1713e9d7ea5fa5e99f5e&amp;s=A650E03387274D091E4198DB0300E0B2" alt="img"></p><p><strong>2）构造判断矩阵</strong></p><p>在确定各层次各因素之间的权重时，如果只是定性的结果，则常常不容易被别人接受，因而Saaty等人提出：一致矩阵法，即：不把所有因素放在一起比较，而是两两相互比较。对比时采用相对尺度，以尽可能减少性质不同因素相互比较的困难，以提高准确度。</p><p><img src="https://pics7.baidu.com/feed/eaf81a4c510fd9f91486fbdf079b1a2f2934a42b.jpeg?token=a55567265b678ff9a082d706ba530f30&amp;s=A5B07C329BCD68CA0859D0C30100F0A3" alt="img"></p><p>由专家对同一层次内N个指标的相对重要性（两两因素之间）进行打分。相对重要性的比例标度取1-9之间。同时，对各同级指标的重要性评价时，存在三种标度范畴（如下图），根据研究需要自行选择。</p><p><img src="https://pics0.baidu.com/feed/a71ea8d3fd1f413497fbf4c907a95bcfd3c85ef0.jpeg?token=e7e0432daba73983310646ed2803872b&amp;s=8652E13393DF41C804DD91CE000050B0" alt="img"></p><p>构建判断矩阵A（正交矩阵），用aij表示第i个因素相对于第j个因素的比较结果：</p><p><img src="https://pics6.baidu.com/feed/6a600c338744ebf8d2f4c2c0fb4f192f6259a780.jpeg?token=60fb9c332945a68609b40b4ce61d04fc&amp;s=7AA834629B424D414E5561DE0000A0B1" alt="img"></p><p><strong>3) 计算权重</strong></p><p>将矩阵A的各行向量进行几何平均（方根法），然后进行归一化，即得到各评价指标权重和特征向量W：</p><p><img src="https://pics0.baidu.com/feed/cf1b9d16fdfaaf5139b862e4aee25aebf11f7a4a.jpeg?token=9910950128cca81afb8ba7f598c6a5ce&amp;s=49A635733B404D411850D8C20000E0B1" alt="img"></p><p><strong>4) 一致性检验</strong></p><p>判断矩阵的一致性检验，所谓一致性是指判断思维的逻辑一致性。如当甲比丙是强烈重要，而乙比丙是稍微重要时，显然甲一定比乙重要。这就是判断思维的逻辑一致性，否则判断就会有矛盾。</p><p>计算最大特征根λmax：</p><p><img src="https://pics7.baidu.com/feed/6609c93d70cf3bc75bc7f4d7f3b674a4cc112a05.jpeg?token=5a509a4507cf313d3f89fcd87684b052&amp;s=00367D329DF179805CDD38C60000E0B1" alt="img"></p><p>计算一致性指标CI（Consistency Index）、随机一致性指标RI（Random Index）和一致性比例CR（Consistency Ratio）：</p><p><img src="https://pics0.baidu.com/feed/d53f8794a4c27d1e6b5627c73963636bdcc438f8.jpeg?token=79fe1577a730de6ff735de9db13728db&amp;s=80247D3284B079805C5911CE000070B3" alt="img"></p><p>一般情况下，当CR＜0.1时，即认为矩阵具有满意的一致性，否则需要对判断矩阵进行调整。</p><p><strong>5）层次排序</strong></p><p>层次排序，可分为层次单排序和层次总排序。所谓层次单排序是指，对于上一层某因素而言，本层次各因素的重要性的排序。层次总排序，确定某层所有因素对于总目标相对重要性的排序权值过程，称为层次总排序。这一过程是从最高层到最底层依次进行的。对于最高层而言，其层次单排序的结果也就是总排序的结果。</p><p>计算某一层次所有因素对于最高层（目标层）相对重要性的权值，称为层次总排 序。该过程是从最高层次向最低层次依次进行：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/24ef7c81898f7a9f1f0cc93977d32f16.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c99ce569167aa495ea026d1ae5d2bc87.png" alt="img"></p><p>当𝐶𝑅 &lt; 0.1时，认为层次总排序通过一致性检验，否则就需要重新调整判断矩阵 的元素取值。到此，根据最下层（决策层）的层次总排序做出最后的决策。</p><h2 id="案例分析">案例分析</h2><p><strong>1）构建评价结构</strong></p><p>一位顾客决定要买一套新住宅，经过初步调查研究确定了三套候选的房子A、B、C，问题是如何在这三套房子里选自一套较为满意的房子呢? 下面给出有关的数据和资料：</p><p>将影响购买新房的因素归纳为4个标准：</p><p>· 房子的地理位置及交通；</p><p>· 房子的居住环境；</p><p>· 房子结构、布局与设施；</p><p>· 房子的每平方米建筑面积地单价（模型如下）。</p><p><img src="https://pics7.baidu.com/feed/342ac65c103853433c80192eb1a57e7bcb8088aa.jpeg?token=762ceb4856c91df8daea51334d333018&amp;s=41F43C721F5743CA1EF158440300F0B0" alt="img"></p><p><strong>2）邀请专家（20-30名）打分</strong></p><p>对同一层次内4个指标的相对重要性（两两因素之间）进行打分。经过专家的打分，每个标准相对的权重，即标准的特征向量如下表。</p><p><img src="https://pics1.baidu.com/feed/b2de9c82d158ccbfc05f8d373b6e723bb0354113.jpeg?token=62541c032c0a9526a76e49e4769ec2e7&amp;s=8C30E51297A059030E5590CF000030B1" alt="img"></p><p><strong>3）用规范列平均法求权重</strong></p><p>第一步：先求出两两比较矩阵每一列的总和。</p><p><img src="https://pics6.baidu.com/feed/cefc1e178a82b90115e04281513b67723812ef6b.jpeg?token=4c50d289adc0c9a0d67d9d18730a7770&amp;s=88A67C3215D849C81ED1A0CA0000A0B1" alt="img"></p><p>第二步：把两两比较矩阵的每一元素除以其相应列的总和，所得商所组成的新的矩阵称之为标准两两比较矩阵。</p><p><img src="https://pics7.baidu.com/feed/83025aafa40f4bfb211e832521f9b6f5f6361834.jpeg?token=136179248096828e8afec5ada1015de2&amp;s=8DA6743297D04DCA1CD1A8CF000080B1" alt="img"></p><p>第三步：计算两两比较矩阵的每一行的平均值，这些平均值就是各方案在地理位置及交通方面的权重。</p><p><img src="https://pics3.baidu.com/feed/b812c8fcc3cec3fd03734e76f43e1a3a869427a4.jpeg?token=02393e9ff60a2c6d2dfb298bfc78cc2c&amp;s=08A07C328BD049C80E51F8CE0000A0B1" alt="img"></p><p>我们称最后求得的行平均值为房子选择问题中地理位置及交通方面的特征向量。三个方案在其它三个方面的特征向量。</p><p><img src="https://pics6.baidu.com/feed/54fbb2fb43166d225fd418e26495c7f29152d264.jpeg?token=3d88593a06ef3fa51aa48ad55aa74209&amp;s=84907C328FE04C031C55A4DB000050B0" alt="img"></p><p>每个标准相对的权重，即标准的特征向量。通过两两矩阵比较，可求得标准的特征向量如下：</p><p>地理位置及交通：0.398</p><p>居住环境：0.218</p><p>结构布局设施：0.085</p><p>每平米单价：0.299</p><p><strong>4）两两比较一致性检验</strong></p><p>两两比较矩阵的元素是通过两个因素比较得到的，而在很多这样的比较中，往往可能得到一些不一致性的结论。例如，当因素i、j、k的重要性很接近的时候，在两两比较时，可能得出i比j重要，j比k重要，而k又比i重要等矛盾的结论，这在因素的数目多的时候更容易发生。</p><p>第一步：由被检验的两两比较矩阵乘以其特征向量，所得的向量称之为赋权和向量。</p><p><img src="https://pics1.baidu.com/feed/b2de9c82d158ccbfc05f8d373b6e723bb0354113.jpeg?token=62541c032c0a9526a76e49e4769ec2e7&amp;s=8C30E51297A059030E5590CF000030B1" alt="img"></p><p>第二步:每个赋权和向量的分量分别除以对应的特征向量的分量。</p><p>1.803 / 0.593 =3.040</p><p>1.034 / 0.341 =3.032</p><p>0.197 / 0.066 =2.985</p><p>第三步：计算出第二步结果中的平均值，记为λmax。</p><p>λmax = (3.040+3.032+2.985)/ 3 = 3.019</p><p>第四步：计算一致性指标CI。</p><p>CI = (λmax– n ) / (n - 1)</p><p>CI = (3.019 – 3 ) / (3 – 1 ) = 0.010</p><p>第五步：计算一致性率CR</p><p>CR = CI / RI，在这里，RI是自由度指标（修正值）。</p><p><img src="https://pics5.baidu.com/feed/a044ad345982b2b7d8877bd4131b05ea77099bc5.jpeg?token=ae39fa2783afb9f34dd5546151e1c0b5&amp;s=80306C324D6661200A7565CB000080B3" alt="img"></p><p>本例中可计算得</p><p>CR = 0.01 / 0.58 = 0.017 &lt; 0.1</p><p>我们已经求出了四个标准的特征向量，以及四个在单一标准下的三个购房方案的特征向量，如表：</p><p><img src="https://pics7.baidu.com/feed/faf2b2119313b07ead1d6a482e615f2696dd8c0d.jpeg?token=b99cf8151e69d727d87b836426a09803&amp;s=8692642381B049820A79ECC60000C0B1" alt="img"></p><p><strong>5）最优方案求解</strong></p><p>方案 A：</p><p>0.398<em>0.593+0.218</em>0.123+0.085<em>0.087+0.299</em>0.265=0.349</p><p>方案 B（最优）</p><p>0.398<em>0.341+0.218</em>0.320+0.085<em>0.274+0.299</em>0.655=0.425</p><p>方案 C：</p><p>0.398<em>0.066+0.218</em>0.557+0.085<em>0.639+0.299</em>0.080=0.226</p><h2 id="优缺点">优缺点</h2><h3 id="层次分析法优点：">层次分析法优点：</h3><p><strong>· 系统性的分析方法</strong></p><p>层次分析法把研究对象作为一个系统，按照分解、比较判断、综合的思维方式进行决策，成为继机理分析、统计分析之后发展起来的系统分析的重要工具。系统的思想在于不割断各个因素对结果的影响，而层次分析法中每一层的权重设置最后都会直接或间接影响到结果，而且在每个层次中的每个因素对结果的影响程度都是量化的，非常清晰明确。这种方法尤其可用于对无结构特性的系统评价以及多目标、多准则、多时期等的系统评价。</p><p><strong>· 简洁实用的决策方法</strong></p><p>这种方法既不单纯追求高深数学，又不片面地注重行为、逻辑、推理，而是把定性方法与定量方法有机地结合起来，使复杂的系统分解，能将人们的思维过程数学化、系统化，便于人们接受，且能把多目标、多准则又难以全部量化处理的决策问题化为多层次单目标问题，通过两两比较确定同一层次元素相对上一层次元素的数量关系后，最后进行简单的数学运算。计算简便，并且所得结果简单明确，容易为决策者了解和掌握。</p><p><strong>· 所需定量数据信息较少</strong></p><p>层次分析法主要是从评价者对评价问题的本质、要素的理解出发，比一般的定量方法更讲求定性的分析和判断。由于层次分析法是一种模拟人们决策过程的思维方式的一种方法，层次分析法把判断各要素的相对重要性的步骤留给了大脑，只保留人脑对要素的印象，化为简单的权重进行计算。这种思想能处理许多用传统的最优化技术无法着手的实际问题。</p><h3 id="层次分析法缺点：">层次分析法缺点：</h3><p><strong>· 不能为决策提供新方法</strong></p><p>层次分析法的作用是从备选方案中选择较优者。在应用层次分析法的时候，可能就会有这样一个情况，就是我们自身的创造能力不够，造成了我们尽管在我们想出来的众多方案里选了一个最好的出来，但其效果仍然不够企业所做出来的效果好。而对于大部分决策者来说，如果一种分析工具能替我分析出在我已知的方案里的最优者，然后指出已知方案的不足，又或者甚至再提出改进方案的话，这种分析工具才是比较完美的。但显然，层次分析法还没能做到这点。</p><p><strong>· 定量数据较少，定性成分多，不易令人信服</strong></p><p>在如今对科学的方法的评价中，一般都认为一门科学需要比较严格的数学论证和完善的定量方法。但现实世界的问题和人脑考虑问题的过程很多时候并不是能简单地用数字来说明一切的。层次分析法是一种带有模拟人脑的决策方式的方法，因此必然带有较多的定性色彩。</p><p><strong>· 指标过多时，数据统计量大，且权重难以确定</strong></p><p>当我们希望能解决较普遍的问题时，指标的选取数量很可能也就随之增加。指标的增加就意味着我们要构造层次更深、数量更多、规模更庞大的判断矩阵。那么我们就需要对许多的指标进行两两比较的工作。由于一般情况下我们对层次分析法的两两比较是用1至9来说明其相对重要性，如果有越来越多的指标，我们对每两个指标之间的重要程度的判断可能就出现困难了，甚至会对层次单排序和总排序的一致性产生影响，使一致性检验不能通过。不能通过，就需要调整，在指标数量多的时候比较难调整过来。</p><p><strong>· 特征值和特征向量的精确求法比较复杂</strong></p><p>在求判断矩阵的特征值和特征向量时，所用的方法和我们多元统计所用的方法是一样的。在二阶、三阶的时候，我们还比较容易处理，但随着指标的增加，阶数也随之增加，在计算上也变得越来越困难。不过幸运的是这个缺点比较好解决，我们有三种比较常用的近似计算方法。第一种就是和法，第二种是幂法，还有一种常用方法是根法</p><h2 id="公式整理">公式整理</h2><p><strong>判断矩阵</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><msub><mrow><mo fence="true">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo fence="true">)</mo></mrow><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>11</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>12</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>21</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>22</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>n</mi><mn>2</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mrow><mi>n</mi><mi>n</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">A=\left(a_{i j}\right)_{n \times n}=\left(\begin{array}{cccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2 n} \\\vdots &amp; \vdots &amp; \cdots &amp; \vdots \\a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n}\end{array}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1441em;vertical-align:-0.3941em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0725em;"><span style="top:-2.3642em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3941em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.875em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='5.400em' viewBox='0 0 875 5400'><path d='M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,-36,557 l0,1884c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189l0,-1892c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">21</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-1.38em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">nn</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.875em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='5.400em' viewBox='0 0 875 5400'><path d='M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1809c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558l0,-1944c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>计算权重</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi></msub><mo>=</mo><msub><mover accent="true"><mi mathvariant="normal">W</mi><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">i</mi></msub><mi mathvariant="normal">/</mi><munderover><mo>∑</mo><mrow><mi mathvariant="normal">i</mi><mo>=</mo><mn>1</mn></mrow><mi mathvariant="normal">n</mi></munderover><msub><mover accent="true"><mi mathvariant="normal">w</mi><mo stretchy="true">‾</mo></mover><mi mathvariant="normal">i</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">W</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="normal">w</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi mathvariant="normal">w</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋅</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mover accent="true"><mi>w</mi><mo>˙</mo></mover><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\mathrm{w}_{\mathrm{i}}=\overline{\mathrm{W}}_{\mathrm{i}} / \sum_{\mathrm{i}=1}^{\mathrm{n}} \overline{\mathrm{w}}_{\mathrm{i}}, \mathrm{W}=\left\{\begin{array}{c}\mathrm{w}_{1} \\\mathrm{w}_{2} \\\cdot \\\dot{w}_{n}\end{array}\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:-0.0139em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9349em;vertical-align:-1.2835em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">W</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8665em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2835em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-1.9em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.892em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.616em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.616em' style='width:0.8889em' viewBox='0 0 888.89 616' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V616 H384z M384 0 H504 V616 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.616em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.616em' style='width:0.8889em' viewBox='0 0 888.89 616' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V616 H384z M384 0 H504 V616 H384z'/></svg></span></span><span style="top:-4.9em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0139em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0139em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">⋅</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.0556em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-1.9em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎭</span></span></span><span style="top:-1.892em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.616em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.616em' style='width:0.8889em' viewBox='0 0 888.89 616' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V616 H384z M384 0 H504 V616 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎬</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.616em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.616em' style='width:0.8889em' viewBox='0 0 888.89 616' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V616 H384z M384 0 H504 V616 H384z'/></svg></span></span><span style="top:-4.9em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>最大特征根</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>λ</mi><mi>max</mi><mo>⁡</mo><mo>=</mo><mfrac><mn>1</mn><mi mathvariant="normal">n</mi></mfrac><munderover><mo>∑</mo><mrow><mi mathvariant="normal">i</mi><mo>=</mo><mn>1</mn></mrow><mi mathvariant="normal">n</mi></munderover><mfrac><mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">W</mi></mrow><msub><mo stretchy="false">)</mo><mi mathvariant="normal">i</mi></msub></mrow><msub><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\lambda \max =\frac{1}{\mathrm{n}} \sum_{\mathrm{i}=1}^{\mathrm{n}} \frac{(\mathrm{AW})_{\mathrm{i}}}{\mathrm{w}_{\mathrm{i}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9349em;vertical-align:-1.2835em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8665em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2835em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:-0.0139em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">AW</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">C</mi><mi mathvariant="normal">I</mi></mrow><mo>=</mo><mfrac><mrow><mi>λ</mi><mi>max</mi><mo>⁡</mo><mo>−</mo><mi mathvariant="normal">n</mi></mrow><mrow><mi mathvariant="normal">n</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathrm{CI}=\frac{\lambda \max -\mathrm{n}}{\mathrm{n}-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">CI</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathrm">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathrm">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="参考资料">参考资料</h2><p><a href="https://blog.csdn.net/qq_41686130/article/details/122081827">用人话讲明白AHP层次分析法（非常详细原理+简单工具实现）_Halosec_Wei的博客-CSDN博客_ahp层次分析法</a></p><p><a href="https://baijiahao.baidu.com/s?id=1651259201959322004#:~:text=%20%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%88AHP%EF%BC%89%EF%BC%8C%E4%B8%80%E8%A8%80%E8%94%BD%E4%B9%8B%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E6%9E%84%E5%BB%BA%E4%B8%80%E5%A5%97%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB%EF%BC%8C%E5%AE%8C%E6%88%90%E5%AF%B9%E5%AE%9A%E6%80%A7%E6%8C%87%E6%A0%87%E7%9A%84%E5%AE%9A%E9%87%8F%E5%8C%96%E5%88%86%E6%9E%90%E3%80%82,%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%EF%BC%88AnalyticHierarchy%20Process%EF%BC%8CAHP%EF%BC%89%E7%94%B1%E7%BE%8E%E5%9B%BD%E8%BF%90%E7%AD%B9%E5%AD%A6%E5%AE%B6%E3%80%81%E5%8C%B9%E5%85%B9%E5%A0%A1%E5%A4%A7%E5%AD%A6%E6%95%99%E6%8E%88SattyT.L.%E4%BA%8E%E4%BA%8C%E5%8D%81%E4%B8%96%E7%BA%AA70%E5%B9%B4%E4%BB%A3%E6%8F%90%E5%87%BA%EF%BC%8C%E6%98%AF%E4%B8%80%E7%A7%8D%E5%B0%86%E4%B8%8E%E5%86%B3%E7%AD%96%E6%9C%89%E5%85%B3%E7%9A%84%E5%85%83%E7%B4%A0%E5%88%86%E8%A7%A3%E6%88%90%E7%9B%AE%E6%A0%87%E3%80%81%E5%87%86%E5%88%99%E3%80%81%E6%96%B9%E6%A1%88%E7%AD%89%E5%B1%82%E6%AC%A1%EF%BC%8C%E5%9C%A8%E6%AD%A4%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%AE%9A%E6%80%A7%E5%92%8C%E5%AE%9A%E9%87%8F%E5%88%86%E6%9E%90%E7%9A%84%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95%E3%80%82">百度百科-层次分析法</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 评价模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>描述性统计</title>
      <link href="/2022/09/08/%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1/"/>
      <url>/2022/09/08/%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>作者：hal3515</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/424763389">https://zhuanlan.zhihu.com/p/424763389</a></p><p>来源：知乎</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1>(1)描述性统计</h1><ul><li>所谓描述性统计，就是对已有的数据的多个特征(最小元素，最大元素，均值，中位数等)进行计算。</li></ul><h2 id="1-使用Matlab进行计算">1.使用Matlab进行计算</h2><ul><li><code>min</code>求最小值</li><li><code>max</code>求最大值</li><li><code>mean</code>求平均值</li><li><code>median</code>求中位数的值</li><li><code>skewness</code>求偏度</li><li><code>kurtosis</code>求峰度</li><li><code>std</code>求标准差</li></ul><h2 id="2-使用Excel计算">2.使用Excel计算</h2><p><img src="https://pic1.zhimg.com/v2-6e9289e6914fe1b66715c3bbb5c39830_b.jpg" alt="img"></p><h2 id="3-使用Spss计算">3.使用Spss计算</h2><p><img src="https://pic3.zhimg.com/v2-98721cb845f292f6f7f9bff041ef9502_b.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/v2-8a3b20b0eb85ab766cf137fc89d76dcd_b.jpg" alt="img"></p><p>(2)正态分布的检验</p><h2 id="0-偏度与峰度">0.偏度与峰度</h2><ul><li>偏度：是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。定义上偏度是样本的三阶标准化矩。（注意正态分布的偏度为0）</li></ul><p><img src="https://www.zhihu.com/equation?tex=S%3DE%5B%28%5Cdfrac%7BX-%5Cmu%7D%7B%5Csigma%7D%29%5E3%5D%5C%5C" alt="[公式]"></p><p><img src="https://pic2.zhimg.com/v2-9b12677df0b4169ff4436a19ba2e08bd_b.jpg" alt="img"></p><ul><li>峰度：表征概率密度分布曲线在平均值处峰值高低的特征数。直观看来，峰度反映了峰部的尖度。定义上偏度是样本的四阶标准化矩。（注意正态分布的峰度为3）</li></ul><p><img src="https://www.zhihu.com/equation?tex=K%3DE%5B%28%5Cdfrac%7BX-%5Cmu%7D%7B%5Csigma%7D%29%5E4%5D%5C%5C" alt="[公式]"></p><p><img src="https://pic1.zhimg.com/v2-7f22eec6469c6f0c2e13f98698635558_b.jpg" alt="img"></p><h2 id="1-JB-检验-大样本n-30">1. JB 检验(大样本n&gt;30)</h2><ul><li><strong>step 1</strong>：进行假设检验  <img src="https://www.zhihu.com/equation?tex=%5Csmall+H_0%3A" alt="[公式]"> 该变量服从正态分布， <img src="https://www.zhihu.com/equation?tex=%5Csmall+H_1%3A" alt="[公式]"> 该变量不服从正态分布。</li><li><strong>step 2</strong>：假设对一个随机变量  <img src="https://www.zhihu.com/equation?tex=%5Csmall+X_i" alt="[公式]">  ，其峰度为  <img src="https://www.zhihu.com/equation?tex=%5Csmall+K" alt="[公式]">  ，其偏度为  <img src="https://www.zhihu.com/equation?tex=%5Csmall+S" alt="[公式]"> ，则构造检验统计量</li></ul><p><img src="https://www.zhihu.com/equation?tex=JB%3D%5Cdfrac%7Bn%7D%7B6%7D%5BS%5E2%2B%5Cdfrac%7B%28K-3%29%5E2%7D%7B4%7D%5D%5Csim+%5Cchi%5E2%282%29%5C%5C" alt="[公式]"> 服从自由度为2的卡方分布。</p><ul><li><strong>step 3</strong>： 代入数据计算出  <img src="https://www.zhihu.com/equation?tex=%5Csmall+JB%5E%2A" alt="[公式]"> ，通过 <img src="https://www.zhihu.com/equation?tex=%5Csmall+JB%5E%2A" alt="[公式]"> 计算出对应的  <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">  值。</li><li><strong>step 4</strong>：通过  <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">  值检验得出结论。(一般取  <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">  为 0.05 )。</li><li>matlab中：<code>[h,p]=jbtest(x,alpha)</code>, <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]">  表示要检测的变量，只能取向量，alpha表示显著性水平，h=1表示拒绝原假设，h=0表示接受原假设，p表示返回的p值。</li></ul><h2 id="2-夏皮洛-威尔克检验">2. 夏皮洛-威尔克检验</h2><ul><li><strong>step 1</strong>：进行假设检验  <img src="https://www.zhihu.com/equation?tex=%5Csmall+H_0%3A" alt="[公式]"> 该变量服从正态分布， <img src="https://www.zhihu.com/equation?tex=%5Csmall+H_1%3A" alt="[公式]"> 该变量不服从正态分布。</li><li><strong>step 2</strong>：使用SPSS计算出相应的  <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">  值。</li><li><strong>step 3</strong>：通过相应的  <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">  值进行判断。</li></ul><p><img src="https://pic3.zhimg.com/v2-dd99d8e5a8567be1e026b732b57b89d6_b.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/v2-534886d79bdd1a613c17626ad40c466d_b.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/v2-be9f31cac2884b10839220463044e7d1_b.jpg" alt="img"></p><h1>(3)皮尔逊相关系数</h1><h2 id="1-总体皮尔逊Person相关系数">1.总体皮尔逊Person相关系数</h2><p><img src="https://www.zhihu.com/equation?tex=%5Crho_%7BXY%7D%3D%5Cdfrac%7BCov%28X%2CY%29%7D%7B%5Csigma_x%5Csigma_y%7D%5C%5C" alt="[公式]"></p><p>这里 <img src="https://www.zhihu.com/equation?tex=%5Csigma_x%3D%5Csqrt%7B%5Cdfrac%7B%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%28X_i-E%28X%29%29%5E2%7D%7Bn%7D%7D%5C%5C" alt="[公式]"> 与 <img src="https://www.zhihu.com/equation?tex=%5Csigma_y%3D%5Csqrt%7B%5Cdfrac%7B%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%28Y_i-E%28Y%29%29%5E2%7D%7Bn%7D%7D%5C%5C" alt="[公式]"> 分别是 <img src="https://www.zhihu.com/equation?tex=%5Csmall+X" alt="[公式]"> 总体与 <img src="https://www.zhihu.com/equation?tex=%5Csmall+Y" alt="[公式]"> 总体的方差。</p><p><img src="https://www.zhihu.com/equation?tex=Cov%28X%2CY%29%3D%5Cdfrac%7B%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%28X_i-E%28X%29%29%28Y_i-E%28Y%29%29%7D%7Bn%7D%5C%5C" alt="[公式]"> 为总体的协方差。</p><h2 id="2-样本皮尔逊Person相关系数">2.样本皮尔逊Person相关系数</h2><p><img src="https://www.zhihu.com/equation?tex=r_%7BXY%7D%3D%5Cdfrac%7BCov%28X%2CY%29%7D%7BS_xS_y%7D%5C%5C" alt="[公式]"></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>r</mi><mrow><mi>X</mi><mi>Y</mi></mrow></msub><mo>=</mo></mrow><annotation encoding="application/x-tex">r_{XY} = </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="mord mathnormal mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span></span></span></span></p><p>这里 <img src="https://www.zhihu.com/equation?tex=S_x%3D%5Csqrt%7B%5Cdfrac%7B%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%28X_i-%5Coverline%7BX%7D%29%5E2%7D%7Bn-1%7D%7D%5C%5C" alt="[公式]"> 与 <img src="https://www.zhihu.com/equation?tex=S_y%3D%5Csqrt%7B%5Cdfrac%7B%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%28Y_i-%5Coverline%7BY%7D%29%5E2%7D%7Bn-1%7D%7D%5C%5C" alt="[公式]"> 分别是 <img src="https://www.zhihu.com/equation?tex=%5Csmall+X" alt="[公式]"> 样本与 <img src="https://www.zhihu.com/equation?tex=%5Csmall+Y" alt="[公式]"> 样本的方差。</p><p><img src="https://www.zhihu.com/equation?tex=Cov%28X%2CY%29%3D%5Cdfrac%7B%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%28X_i-%5Coverline%7BX%7D%29%28Y_i-%5Coverline%7BY%7D%29%7D%7Bn-1%7D%5C%5C" alt="[公式]"> 为样本的协方差。</p><h2 id="3-使用皮尔逊Person相关系数的注意事项">3.使用皮尔逊Person相关系数的注意事项</h2><ul><li>先要判断变量是否大致满足线性关系，可以采用画散点图的方式。当两个变量本来就大致满足线性的关系时，皮尔逊相关系数的绝对值越大，两个变量的相关性越强，但是如果本来就不满足线性关系，就算皮尔逊系数很大也没有意义。</li></ul><p><img src="https://pic2.zhimg.com/v2-bfcfd3b2712c6ed9fe503ca7eff6fa71_b.jpg" alt="img"></p><p>上面的几个图的皮尔逊相关系数都为0.816，但是明显小样本对最终结果产生巨大的影响。 *</p><ul><li>如果计算出皮尔逊系数为0，不代表两个变量之间不存在关系。比如下面的温度-冰糕之间必然存在相关性，但是不是线性关系。</li></ul><p><img src="https://pic3.zhimg.com/v2-6630f0debb13065f9e69de40016f2066_b.jpg" alt="img"></p><ul><li>可以使用 SPSS 作出散点图先判断是否具有一定的线性关系。</li></ul><p><img src="https://pic4.zhimg.com/v2-10be7772f4c86fe1893778e0dc861a97_b.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/v2-8c12299f48ea4bead72019e24f619922_b.jpg" alt="img"></p><h2 id="4-使用matlab计算person系数">4.使用matlab计算person系数</h2><p>(1) 使用matlab计算 <code>corrcoef</code>  <code>R=corrcoef(A)</code>：返回 <img src="https://www.zhihu.com/equation?tex=%5Csmall+A" alt="[公式]"> 的相关系数矩阵，其中 <img src="https://www.zhihu.com/equation?tex=%5Csmall+A" alt="[公式]"> 的列表示随机变量(指标，例如身高、体重等),行表示观测值(样本，例如每一个人的身高、体重等)。  <code>R=corrcoef(A,B)</code>：返回两个变量 <img src="https://www.zhihu.com/equation?tex=%5Csmall+A%EF%BC%8CB" alt="[公式]"> 向量之间的相关系数。</p><p>(2) 使用Excel计算与美化相关系数表</p><ul><li>在数据分析中选取相关系数的计算。</li><li>使用色阶图进行美化</li></ul><p><img src="https://pic3.zhimg.com/v2-8af9b63de84465726adb9609e070afa6_b.jpg" alt="img"></p><h1>(3)对皮尔逊相关系数进行假设检验</h1><h2 id="1-可以进行假设检验的前提">1.可以进行假设检验的前提</h2><ul><li>实验数据通常假设是成对的来自于正态分布的总体。(一般情况下很难满足)。</li><li>实验数据之间的差距不能太大，异常值对检验结果影响很大。</li><li>每个样本之间是独立抽样的。</li></ul><h2 id="2-进行正态分布检验">2.进行正态分布检验</h2><h2 id="3-流程">3.流程</h2><p>目的是验证计算得出的皮尔逊相关系数是否与0有显著的差异。</p><ul><li><strong>step 1</strong>  提出原假设与备择假设, <img src="https://www.zhihu.com/equation?tex=H_0%3Ar%3D0%2CH_1%3Ar%5Cnot%3D0" alt="[公式]"> 。</li><li><strong>step 2</strong> 构造检验统计量</li></ul><p><img src="https://www.zhihu.com/equation?tex=r%5Csqrt%7B%5Cdfrac%7Bn-2%7D%7B1-r%5E2%7D%7D%5Csim+t%28n-2%29+%5C%5C" alt="[公式]"> 服从自由度为2的 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 分布</p><ul><li><strong>step 3</strong> 计算出检验值(代入数据)得到  <img src="https://www.zhihu.com/equation?tex=t%5E%2A" alt="[公式]"> 。</li><li><strong>step 4</strong> 使用  <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">  检验：计算  <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">  值</li></ul><p><img src="https://www.zhihu.com/equation?tex=+p%3D2%5Ctimes%281-%5Cint_%7B-%5Cinfty%7D%5E%7Bt%5E%2A%7Dt%28x%29dx%29%5C%5C" alt="[公式]"></p><ul><li><strong>step 5</strong> 结果说明</li><li><ul><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+p%3C0.01" alt="[公式]"> ：在99%的置信水平上拒绝原假设。</li><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+0.01%3Cp%3C0.05" alt="[公式]"> ：在 99%的置信水平上无法拒绝原假设，但在95%的水平上可以拒绝原假设。</li><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+0.05%3Cp%3C0.1" alt="[公式]"> ：在95%的置信水平上无法拒绝原假设，但在90%的水平上可以拒绝原假设。</li></ul></li><li>显著性标记:  <img src="https://www.zhihu.com/equation?tex=a%2Ca%5E%2A%2Ca%5E%7B%2A%2A%7D" alt="[公式]"> ,** 表示在0.01级别（双尾）的相关性显著**，*** 表示在0.05级别（双尾）的相关性显著。</li><li>matlab相关:</li><li><ul><li><code>tpdf(x,n)</code>： <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 取一系列连续的值，可以做出自由度为 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 的 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 分布图像。</li><li><code>tcdf(t,n)</code>：是自由度为 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 的 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 分布的分布函数。 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 取一个固定的值 <img src="https://www.zhihu.com/equation?tex=t_c" alt="[公式]"> ,可以计算出 <img src="https://www.zhihu.com/equation?tex=%5Csmall+T%5Cle+t_c" alt="[公式]"> 的概率。</li><li><code>tinv(p,n)</code>：自由度为 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 的 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> 分布下对应概率为 <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]"> 的点的值。</li></ul></li></ul><h1>(4)斯皮尔曼(sperman)相关系数</h1><h2 id="1-斯皮尔曼相关系数的第一种定义">1. 斯皮尔曼相关系数的第一种定义</h2><ul><li><img src="https://www.zhihu.com/equation?tex=%5Csmall+X" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=%5Csmall+Y" alt="[公式]">  为两组数据，其斯皮尔曼(等级)相关系数：</li></ul><p><img src="https://www.zhihu.com/equation?tex=r_s%3D1-%5Cdfrac%7B6%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dd_i%5E2%7D%7Bn%28n%5E2-1%29%7D%5C%5C" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Csmall+d_i" alt="[公式]">  为  <img src="https://www.zhihu.com/equation?tex=%5Csmall+X_i" alt="[公式]">  与  <img src="https://www.zhihu.com/equation?tex=%5Csmall+Y_i" alt="[公式]">  之间的等级差。(  <img src="https://www.zhihu.com/equation?tex=%5Csmall+-1+%5Cle+r_s+%5Cle+1" alt="[公式]"> )。</p><ul><li>等级：将所在列的元素排序后，这个数所在的位置。</li><li>有数值相同，将它们所在位置取算术平均。例如对下面一列数90,84,76,71,71,71,69,68,66,64,排出的顺序为 1,2,3,5,5,5,7,8,9,10 计算方式为  <img src="https://www.zhihu.com/equation?tex=%284%2B5%2B6%29%2F3" alt="[公式]"> 。</li></ul><p><img src="https://pic1.zhimg.com/v2-c89e145a8264a71a44dfa8dc09a31330_b.jpg" alt="img"></p><h2 id="2-斯皮尔曼相关系数的第二种定义">2. 斯皮尔曼相关系数的第二种定义</h2><ul><li>定义为<strong>等级之间的皮尔逊相关系数</strong>。</li><li>按这种定义计算得到的斯皮尔曼相关系数一般与第一种定义下计算出的斯皮尔曼相关系数不同。</li></ul><h2 id="3-使用matlab计算斯皮尔曼相关系数">3.使用matlab计算斯皮尔曼相关系数</h2><ul><li><code>corr(X,Y,'type','Spearman')</code>：其中 <img src="https://www.zhihu.com/equation?tex=%5Csmall+X" alt="[公式]"> 与 <img src="https://www.zhihu.com/equation?tex=%5Csmall+Y" alt="[公式]"> 必须是列向量。</li><li><code>corr(X,'type','Spearman')</code>：计算矩阵 <img src="https://www.zhihu.com/equation?tex=%5Csmall+X" alt="[公式]"> 各列之间的斯皮尔曼相关系数。</li></ul><h1>(5)斯皮尔曼相关系数的假设检验</h1><p><img src="https://www.zhihu.com/equation?tex=%5Csmall+H_0%3Ar_s%3D0%2CH_1%3Ar_s%5Cnot%3D0" alt="[公式]"> 。</p><h2 id="1-小样本情况下-公式">1.小样本情况下 <img src="https://www.zhihu.com/equation?tex=%28n%5Cle30%29" alt="[公式]"></h2><p>直接在<a href="https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/d669a332e009581b6ad9eb02.html">临界表</a>中查询即可。</p><p><img src="https://pic1.zhimg.com/v2-967469e93d610ddb57bc5543e8c23edc_b.jpg" alt="img"></p><h2 id="2-大样本情况下-公式">2.大样本情况下 <img src="https://www.zhihu.com/equation?tex=%28n%5Cge30%29" alt="[公式]"></h2><ul><li>统计量  <img src="https://www.zhihu.com/equation?tex=%5Csmall+r_s%5Csqrt%7Bn-1%7D%5Csim+N%280%2C1%29" alt="[公式]"> 。</li><li>计算检验值  <img src="https://www.zhihu.com/equation?tex=%5Csmall+r_s%5Csqrt%7Bn-1%7D" alt="[公式]"> 。</li><li>计算对应的 <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]"> 值,再进行判断。</li></ul><h1>(6)person与spearman对比</h1><ul><li>连续数据，正态分布，线性关系，最好使用 person。</li><li>除此之外都使用 spearman。</li><li>两个定序数据之间也只能用spearman。   定序数据，仅仅反映观测对象的等级顺序关系的数据，优，良，差等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 描述性统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群优化算法</title>
      <link href="/2022/09/08/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>粒子群优化算法</h1><h2 id="资料来源">资料来源</h2><p><a href="https://baike.baidu.com/item/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/2500389?fromtitle=%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95&amp;fromid=1733544&amp;fr=aladdin">粒子群优化算法_百度百科 (baidu.com)</a></p><h2 id="简介">简介</h2><h3 id="定义">定义</h3><p>粒子群优化算法(Particle Swarm optimization,PSO)又翻译为<a href="https://baike.baidu.com/item/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/1733544">粒子群算法</a>、<a href="https://baike.baidu.com/item/%E5%BE%AE%E7%B2%92%E7%BE%A4%E7%AE%97%E6%B3%95/6666141">微粒群算法</a>、或微粒群优化算法。是通过模拟鸟群觅食行为而发展起来的一种基于群体协作的<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%90%9C%E7%B4%A2">随机搜索</a>算法。通常认为它是<a href="https://baike.baidu.com/item/%E7%BE%A4%E9%9B%86%E6%99%BA%E8%83%BD/2623271">群集智能</a> (Swarm intelligence, SI) 的一种。它可以被纳入<a href="https://baike.baidu.com/item/%E5%A4%9A%E4%B8%BB%E4%BD%93%E4%BC%98%E5%8C%96%E7%B3%BB%E7%BB%9F">多主体优化系统</a>(Multiagent Optimization System, MAOS)。</p><p>粒子群优化算法(PSO：Particle swarm optimization) 是一种进化计算技术（evolutionary computation）。源于对鸟群捕食的行为研究。粒子群优化算法的基本思想：是通过<strong>群体中个体之间的协作和信息共享</strong>来寻找最优解．<br>PSO的优势：在于简单容易实现并且没有许多参数的调节。目前已被广泛应用于<strong>函数优化、神经网络训练、模糊系统控制以及其他遗传算法的</strong>应用领域。</p><h3 id="模拟捕食">模拟捕食</h3><p>PSO模拟鸟群的捕食行为。一群鸟在随机搜索食物，在这个区域里只有一块食物。所有的鸟都不知道食物在那里。但是他们知道当前的位置离食物还有多远。那么找到食物的<a href="https://baike.baidu.com/item/%E6%9C%80%E4%BC%98%E7%AD%96%E7%95%A5/19138713">最优策略</a>是什么呢。最简单有效的就是搜寻离食物最近的鸟的周围区域。</p><h3 id="启示">启示</h3><p>PSO从这种模型中得到启示并用于解决优化问题。PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值(fitnessvalue)，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。</p><h3 id="PSO初始化">PSO初始化</h3><p>PSO<a href="https://baike.baidu.com/item/%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a>为一群随机粒子(随机解)，然后通过<a href="https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3/8415523">迭代</a>找到最优解，在每一次迭代中，粒子通过跟踪两个“<a href="https://baike.baidu.com/item/%E6%9E%81%E5%80%BC">极值</a>”来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值pBest，另一个极值是整个种群找到的最优解，这个极值是全局极值gBest。另外也可以不用整个种群而只是用其中一部分最优粒子的邻居，那么在所有邻居中的极值就是<a href="https://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E6%9E%81%E5%80%BC/19132443">局部极值</a>。</p><h2 id="基本思想">基本思想</h2><p>​粒子群算法通过设计一种无质量的粒子来模拟鸟群中的鸟，粒子仅具有两个属性：速度和位置，速度代表移动的快慢，位置代表移动的方向。每个粒子在搜索空间中单独的搜寻最优解，并将其记为当前个体极值，并将个体极值与整个粒子群里的其他粒子共享，找到最优的那个个体极值作为整个粒子群的当前全局最优解，粒子群中的所有粒子根据自己找到的当前个体极值和整个粒子群共享的当前全局最优解来调整自己的速度和位置。下面的动图很形象地展示了PSO算法的过程：<br><img src="https://img-blog.csdn.net/20180803102329735?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="算法介绍">算法介绍</h2><p>在找到这两个最优值时,粒子根据如下的公式来更新自己的速度和新的位置</p><p><img src="https://bkimg.cdn.bcebos.com/formula/4e6933b5f55d4706bb9cadf405f6851e.svg" alt="img"></p><p>(a)</p><p><img src="https://bkimg.cdn.bcebos.com/formula/94578aced7481c1f46e71f7b5f281615.svg" alt="img"></p><p>(b)</p><p>v[] 是粒子的速度，present[] 是当前粒子的位置。pbest[] 和 gbest[] 如前定义。rand() 是介于(0,1)之间的<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0">随机数</a>。c1，c2是学习因子。通常c1=c2=2。</p><p>PSO初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次的迭代中，粒子通过跟踪两个“极值”(pbest，gbest)来更新自己。在找到这两个最优值后，粒子通过下面的公式来更新自己的速度和位置。</p><p>另一种解释：</p><p><img src="https://img-blog.csdn.net/20180803100337670?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>公式(1)的第一部分称为【记忆项】，表示上次速度大小和方向的影响；公式(1)的第二部分称为【自身认知项】，是从当前点指向粒子自身最好点的一个矢量，表示粒子的动作来源于自己经验的部分；公式(1)的第三部分称为【群体认知项】，是一个从当前点指向种群最好点的矢量，反映了粒子间的协同合作和知识共享。粒子就是通过自己的经验和同伴中最好的经验来决定下一步的运动。以上面两个公式为基础，形成了PSO的标准形式。<br><img src="https://img-blog.csdn.net/20180803100428140?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180803102011840?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdnimg.cn/827098a496564b159b8a433b35955f2f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAYnJpbGxpYW50WkM=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h3 id="伪代码实现">伪代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">For each particle</span><br><span class="line"></span><br><span class="line">____Initialize particle</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br><span class="line">Do</span><br><span class="line"></span><br><span class="line">____For each particle</span><br><span class="line"></span><br><span class="line">________Calculate fitness value</span><br><span class="line"></span><br><span class="line">________If the fitness value is better than the best fitness value (pBest) in history</span><br><span class="line"></span><br><span class="line">____________set current value as the new pBest</span><br><span class="line"></span><br><span class="line">____End</span><br><span class="line"></span><br><span class="line">____Choose the particle with the best fitness value of all the particles as the gBest</span><br><span class="line"></span><br><span class="line">____For each particle</span><br><span class="line"></span><br><span class="line">________Calculate particle velocity according equation (a)</span><br><span class="line"></span><br><span class="line">________Update particle position according equation (b)</span><br><span class="line"></span><br><span class="line">____End</span><br><span class="line">While maximum iterations or minimum error criteria is not attained</span><br><span class="line">在每一维粒子的速度都会被限制在一个最大速度Vmax，如果某一维更新后的速度超过用户设定的Vmax，那么这一维的速度就被限定为Vmax。</span><br></pre></td></tr></table></figure><h2 id="PSO算法案例">PSO算法案例</h2><p><img src="https://img-blog.csdn.net/20180803102108831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180803102146843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhYWlrdWFpY2h1YW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="代码demo">代码demo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dim = <span class="number">1</span>;<span class="comment">//维数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p_num = <span class="number">10</span>;<span class="comment">//粒子数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> iters = <span class="number">100</span>;<span class="comment">//迭代次数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">999999</span>;<span class="comment">//极大值</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="comment">//定义粒子的位置和速度的范围</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> v_max = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> v_min = <span class="number">-2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pos_max = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pos_min = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//定义位置向量和速度向量</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; pos;</span><br><span class="line">vector&lt;<span class="type">double</span>&gt; spd;</span><br><span class="line"><span class="comment">//定义粒子的历史最优位置和全局最优位置</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; p_best;</span><br><span class="line"><span class="type">double</span> g_best;</span><br><span class="line"><span class="comment">//使用eigen库定义函数值矩阵和位置矩阵</span></span><br><span class="line">Matrix&lt;<span class="type">double</span>, iters, p_num&gt; f_test;</span><br><span class="line">Matrix&lt;<span class="type">double</span>, iters, p_num&gt; pos_mat;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适应度函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fun_test</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> res = x * x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化粒子群的位置和速度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//矩阵中所有元素初始化为极大值</span></span><br><span class="line">    f_test.<span class="built_in">fill</span>(inf);</span><br><span class="line">    pos_mat.<span class="built_in">fill</span>(inf);</span><br><span class="line">    <span class="comment">//生成范围随机数</span></span><br><span class="line">    <span class="type">static</span> std::mt19937 rng;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution1</span><span class="params">(<span class="number">-1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution2</span><span class="params">(<span class="number">-2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pos.<span class="built_in">push_back</span>(<span class="built_in">distribution1</span>(rng));</span><br><span class="line">        spd.<span class="built_in">push_back</span>(<span class="built_in">distribution2</span>(rng));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">fun_test</span>(pos[i]);<span class="comment">//计算函数值</span></span><br><span class="line">        <span class="comment">//初始化函数值矩阵和位置矩阵</span></span><br><span class="line">        <span class="built_in">f_test</span>(<span class="number">0</span>, i) = temp;</span><br><span class="line">        <span class="built_in">pos_mat</span>(<span class="number">0</span>, i) = pos[i];</span><br><span class="line">        p_best.<span class="built_in">push_back</span>(pos[i]);<span class="comment">//初始化粒子的历史最优位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="type">ptrdiff_t</span> minRow, minCol;</span><br><span class="line">    f_test.<span class="built_in">row</span>(<span class="number">0</span>).<span class="built_in">minCoeff</span>(&amp;minRow, &amp;minCol);<span class="comment">//返回函数值矩阵第一行中极小值对应的位置</span></span><br><span class="line">    g_best = <span class="built_in">pos_mat</span>(minRow, minCol);<span class="comment">//初始化全局最优位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PSO</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mt19937 rng;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">1</span>; step &lt; iters; ++step)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新速度向量和位置向量</span></span><br><span class="line">            spd[i] = <span class="number">0.5</span> * spd[i] + <span class="number">2</span> * <span class="built_in">distribution</span>(rng) * (p_best[i] - pos[i]) +</span><br><span class="line">                <span class="number">2</span> * <span class="built_in">distribution</span>(rng) * (g_best - pos[i]);</span><br><span class="line">            pos[i] = pos[i] + spd[i];</span><br><span class="line">            <span class="comment">//如果越界则取边界值</span></span><br><span class="line">            <span class="keyword">if</span> (spd[i] &lt; <span class="number">-2</span> || spd[i] &gt; <span class="number">4</span>)</span><br><span class="line">                spd[i] = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos[i] &lt; <span class="number">-1</span> || pos[i] &gt; <span class="number">2</span>)</span><br><span class="line">                pos[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//更新位置矩阵</span></span><br><span class="line">            <span class="built_in">pos_mat</span>(step, i) = pos[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新函数值矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = <span class="built_in">fun_test</span>(pos[i]);</span><br><span class="line">            <span class="built_in">f_test</span>(step, i) = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_num; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            MatrixXd temp_test;</span><br><span class="line">            temp_test = f_test.<span class="built_in">col</span>(i);<span class="comment">//取函数值矩阵的每一列</span></span><br><span class="line">            std::<span class="type">ptrdiff_t</span> minRow, minCol;</span><br><span class="line">            temp_test.<span class="built_in">minCoeff</span>(&amp;minRow, &amp;minCol);<span class="comment">//获取每一列的极小值对应的位置</span></span><br><span class="line">            p_best[i] = <span class="built_in">pos_mat</span>(minRow, i);<span class="comment">//获取每一列的极小值，即每个粒子的历史最优位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        g_best = *<span class="built_in">min_element</span>(p_best.<span class="built_in">begin</span>(), p_best.<span class="built_in">end</span>());<span class="comment">//获取全局最优位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_test</span>(g_best);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">PSO</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 粒子群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差异分析方法汇总</title>
      <link href="/2022/09/08/%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2022/09/08/%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1>差异分析方法汇总</h1><p><img src="https://pic2.zhimg.com/v2-f5abf19d441b50860899984332d20675_b.png" alt="img"></p><h1>方差分析</h1><h2 id="试验和因素">试验和因素</h2><p>方差分析：通过观察和试验判断哪些因素的产品的产量质量有显著影响。</p><p><code>方差分析</code>（Analysis of variance，简称ANOVA，又称变异系数分析）是一类用于分析多组数据之间均值差异的统计方法模型，还涉及一些相关的步骤（比如两组数据之间的“变异”）。</p><p>在试验中，我们将要考察的指标称为<strong>试验指标</strong>，影响试验指标的条件称为因素，因素可分两类：</p><ul><li>可控因素：</li><li>不可控因素</li></ul><p>可控因素的所处的状态称为因素的<strong>水平</strong></p><p><strong>单因素试验</strong>：只有一个因素改变</p><p><strong>多因素试验</strong>：多个因素改变</p><h2 id="检验统计量">检验统计量</h2><h3 id="偏差平方和">偏差平方和</h3><h4 id="总体偏差平方和">总体偏差平方和</h4><h4 id="组内偏差平方和">组内偏差平方和</h4><h4 id="组间偏差平方和">组间偏差平方和</h4><h2 id="单因子方差分析（1-way-ANOVA）">单因子方差分析（1-way ANOVA）</h2><p>**单因素方差分析,用于分析定类数据与定量数据之间的关系情况。**在使用单因素方差分析时，需要每个选项的样本量大于30，比如男性和女性样本量分别是100和120，如果出现某个选项样本量过少时应该首先进行组别合并处理，比如研究不同年龄组样本对于研究变量的差异性态度时，年龄小于20岁的样本量仅为20个，那么需要将小于20岁的选项与另外一组(比如20~25岁)的组别合并为一组，然后再进行单因素方差分析。</p><p>如果选项无法进行合并处理，比如研究不同专业样本对于变量的态度差异，研究样本的专业共分为市场营销、心理学、教育学和管理学四个专业，这四个专业之间为彼此独立无法进行合并组别，但是市场营销专业样本量仅为20并没有代表意义，因此可以考虑首先筛选出市场营销专业，即仅比较心理学，教育学和管理学这三个专业对某变量的差异性态度，当对比的组别超过三个，并且呈现出显著性差异时，可以考虑使用事后检验进一步对比具体两两组别间的差异情况。</p><h2 id="双因素方差分析（2-way-ANOVA">双因素方差分析（2-way ANOVA)</h2><p>**双因素方差分析,用于分析定类数据(2个)与定量数据之间的关系情况，**例如研究人员性别,学历对于网购满意度的差异性;以及男性或者女性时,不同学历是否有着网购满意度差异性;或者同一学历时,不同性别是否有着网购满意度差异性。</p><h2 id="多因素方差分析（N-way-ANOVA）">多因素方差分析（N-way ANOVA）</h2><p>**多因素方差分析通常用于类实验式问卷研究。**比如研究者测试某新药对于胆固醇水平是否有疗效；研究者共招募72名被试，男女分别为36名，以及男女分别再细分使用新药和普通药物；同时高血压患者对于新药可能有干扰，因而研究者将被试是否患高血压也纳入考虑范畴中。因而最终，X共分为三个，分别是药物(旧药和新药)、性别，是否患高血压；Y为胆固醇水平。因而需要进行三因素方差分析即多因素方差分析。</p><p>在方法选择上，问卷研究通常会使用方差分析，但某些专业，比如心理学、教育学或者师范类专业等涉及到实验研究时，更多会使用T检验进行分析，另外方差分析与T检验还有较多差异，在某些分析中只能使用其中一种。</p><h1><strong>T检验</strong></h1><p>T检验共分为三种方法，分别是独立样本T检验，配对样本T检验和单样本T检验。</p><p><strong>独立样本T检验</strong>和单因素方差分析功能上基本一致，但是独立样本T检验只能比较两组选项的差异，比如男性和女性。相对来讲，独立样本T检验在实验比较时使用频率更高，尤其是生物、医学相关领域。针对问卷研究，如果比较的类别为两组，独立样本T检验和单因素方差分析均可实现，研究者自行选择使用即可。</p><p>独立样本T检验和<strong>配对样本T检验</strong>功能上都是比较差异，而且均是比较两个组别差异。但二者有着实质性区别，如果是比较不同性别，婚姻状况(已婚和未婚)样本对某变量的差异时，应该使用独立样本T检验。如果比较组别之间有配对关系时，只能使用配对样本T检验，配对关系是指类似实验组和对照组的这类关系。另外独立样本T检验两组样本个数可以不相等，而配对样本T检验的两组样本量需要完全相等。</p><p>T检验的第三种分析方法为<strong>单样本T检验</strong>。比如问卷某题项选项表示为1分代表非常不满意，2分代表比较不满意，3分代表一般，4分代表比较满意，5分代表非常满意，当想分析样本对此题项的态度是否有明显的倾向，比如明显高于3分或者明显低于3分时，即可以使用单样本T检验。单样本T检验是比较某个题项的平均得分是否与某数字(例子是与3进行对比)有着明显的差异，如果呈现出显著性差异，即说明明显该题项平均打分明显不等于3分。此分析方法在问卷研究中较少使用，平均得分是否明显不为3分可以很直观的看出，而不需要单独进行检验分析。</p><h1>卡方分析</h1><p>卡方检验用于分析定类数据与定类数据之间的关系情况。例如研究人员想知道两组学生对于手机品牌的偏好差异情况，则应该使用卡方分析。卡方是通过分析不同类别数据的相对选择频数和占比情况，进而进行差异判断，单选题或多选题均可以使用卡方分析进行对比差异分析。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差异分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各个模型概要</title>
      <link href="/2022/09/08/%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A6%81/"/>
      <url>/2022/09/08/%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h2 id="优化模型"><strong>优化模型</strong></h2><p><strong>1.1 数学规划模型</strong></p><p>线性规划、整数线性规划、非线性规划、多目标规划、动态规划。</p><p><strong>1.2 微分方程组模型</strong></p><p>阻滞增长模型、SARS传播模型。</p><p><strong>1.3 图论与网络优化问题</strong><br>最短路径问题、网络最大流问题、最小费用最大流问题、最小生成树问题(MST)、旅行商问题(TSP)、图的着色问题。</p><p><strong>1.4 概率模型</strong><br>决策模型、随机存储模型、随机人口模型、报童问题、Markov链模型。</p><p><strong>1.5 组合优化经典问题 根据实际问题解决</strong></p><p><strong>1.5.1 多维背包问题(MKP)</strong><br>背包问题：个物品，对物品，体积为，背包容量为。如何将尽可能多的物品装入背包。<br>多维背包问题：个物品，对物品，价值为，体积为，背包容量为。如何选取物品装入背包，是背包中物品的总价值最大。<br>多维背包问题在实际中的应用有：资源分配、货物装载和存储分配等问题。该问题属于难问题。</p><p><strong>1.5.2 二维指派问题(QAP)</strong><br>工作指派问题：个工作可以由个工人分别完成。工人完成工作的时间为。如何安排使总工作时间最小。<br>二维指派问题（常以机器布局问题为例）：台机器要布置在个地方，机器与之间的物流量为，位置与之间的距离为，如何布置使费用最小。<br>二维指派问题在实际中的应用有：校园建筑物的布局、医院科室的安排、成组技术中加工中心的组成问题等。</p><p><strong>1.5.3 旅行商问题(TSP)</strong><br>旅行商问题：有个城市，城市与之间的距离为，找一条经过个城市的巡回（每个城市经过且只经过一次，最后回到出发点），使得总路程最小。</p><p><strong>1.5.4 车辆路径问题(VRP)</strong><br>车辆路径问题（也称车辆计划）：已知个客户的位置坐标和货物需求，在可供使用车辆数量及运载能力条件的约束下，每辆车都从起点出发，完成若干客户点的运送任务后再回到起点，要求以最少的车辆数、最小的车辆总行程完成货物的派送任务。<br>TSP问题是VRP问题的特例。</p><p><strong>1.5.5 车间作业调度问题(JSP)</strong><br>车间调度问题：存在个工作和台机器，每个工作由一系列操作组成，操作的执行次序遵循严格的串行顺序，在特定的时间每个操作需要一台特定的机器完成，每台机器在同一时刻不能同时完成不同的工作，同一时刻同一工作的各个操作不能并发执行。如何求得从第一个操作开始到最后一个操作结束的最小时间间隔。</p><h2 id="分类模型"><strong>分类模型</strong></h2><p><strong>2.1 判别分析</strong><br><strong>2.1.1 距离判别法</strong><br>基本思想：首先根据已知分类的数据，分别计算各类的重心即分组(类)的均值，判别准则是对任给的一次观测，若它与第类的重心距离最近，就认为它来自第类。<br>至于距离的测定，可以根据实际需要采用欧氏距离、马氏距离、明科夫距离等。</p><p><strong>2.1.2 Fisher判别法</strong><br>基本思想：从两个总体中抽取具有个指标的样品观测数据，借助方差分析的思想构造一个判别函数或称判别式。其中系数确定的原则是使两组间的区别最大，而使每个组内部的离差最小。<br>对于一个新的样品，将它的p个指标值代人判别式中求出 y 值，然后与判别临界值(或称分界点(后面给出)进行比较，就可以判别它应属于哪一个总体。在两个总体先验概率相等的假设下，判别临界值一般取：最后，用统计量来检验判别效果，若则认为判别有效，否则判别无效。<br>以上描述的是两总体判别，至于多总体判别方法则需要加以扩展。<br>Fisher判别法随着总体数的增加，建立的判别式也增加，因而计算比较复杂。</p><p><strong>2.1.3 Bayes判别法</strong><br>基本思想：假定对所研究的对象有一定的认识，即假设个总体中，第个总体的先验概率为，概率密度函数为。利用bayes公式计算观测样品来自第个总体的后验概率，当时，将样本判为总体。</p><p><strong>2.1.4 逐步判别法</strong><br>基本思想与逐步回归法类似，采用“有进有出”的算法，逐步引入变量，每次引入一个变量进入判别式，则同时考虑在较早引入判别式的某些作用不显著的变量剔除出去。</p><p><strong>2.2 聚类分析</strong><br>聚类分析是一种无监督的分类方法，即不预先指定类别。<br>根据分类对象不同，聚类分析可以分为样本聚类（Q型）和变量聚类（R型）。样本聚类是针对观测样本进行分类，而变量聚类则是试图找出彼此独立且有代表性的自变量，而又不丢失大部分信息。变量聚类是一种降维的方法。</p><p><strong>2.2.1 系统聚类法（分层聚类法）</strong><br>基本思想：开始将每个样本自成一类；然后求两两之间的距离，将距离最近的两类合成一类；如此重复，直到所有样本都合为一类为止。<br>适用范围：既适用于样本聚类，也适用于变量聚类。并且距离分类准则和距离计算方法都有多种，可以依据具体情形选择。</p><p><strong>2.2.2 快速聚类法（K-均值聚类法）</strong><br>基本思想：按照指定分类数目，选择个初始聚类中心；计算每个观测量（样本）到各个聚类中心的距离，按照就近原则将其分别分到放入各类中；重新计算聚类中心，继续以上步骤；满足停止条件时（如最大迭代次数等）则停止。<br>使用范围：要求用户给定分类数目，只适用于样本聚类（Q型），不适用于变量聚类（R型）。</p><p><strong>2.2.3 两步聚类法（智能聚类方法）</strong><br>基本思想：先进行预聚类，然后再进行正式聚类。<br>适用范围：属于智能聚类方法，用于解决海量数据或者具有复杂类别结构的聚类分析问题。可以同时处理离散和连续变量，自动选择聚类数，可以处理超大样本量的数据。</p><p><strong>2.2.4 模糊聚类分析</strong><br><strong>2.2.5 与遗传算法、神经网络或灰色理论联合的聚类方法</strong><br><strong>2.3 神经网络分类方法</strong></p><h2 id="评价模型"><strong>评价模型</strong></h2><p><strong>3.1 层次分析法(AHP)</strong></p><p>基本思想：是定性与定量相结合的多准则决策、评价方法。将决策的有关元素分解成目标层、准则层和方案层，并通过人们的判断对决策方案的优劣进行排序，在此基础上进行定性和定量分析。它把人的思维过程层次化、数量化，并用数学为分析、决策、评价、预报和控制提供定量的依据。<br>基本步骤：构建层次结构模型；构建成对比较矩阵；层次单排序及一致性检验（即判断主观构建的成对比较矩阵在整体上是否有较好的一致性）；层次总排序及一致性检验（检验层次之间的一致性）。<br>优点：它完全依靠主观评价做出方案的优劣排序，所需数据量少，决策花费的时间很短。从整体上看，AHP在复杂决策过程中引入定量分析，并充分利用决策者在两两比较中给出的偏好信息进行分析与决策支持，既有效地吸收了定性分析的结果，又发挥了定量分析的优势，从而使决策过程具有很强的条理性和科学性，特别适合在社会经济系统的决策分析中使用。<br>缺点：用AHP进行决策主观成分很大。当决策者的判断过多地受其主观偏好影响，而产生某种对客观规律的歪曲时，AHP的结果显然就靠不住了。<br>适用范围：尤其适合于人的定性判断起重要作用的、对决策结果难于直接准确计量的场合。要使AHP的决策结论尽可能符合客观规律，决策者必须对所面临的问题有比较深入和全面的认识。另外，当遇到因素众多，规模较大的评价问题时，该模型容易出现问题，它要求评价者对问题的本质、包含的要素及其相互之间的逻辑关系能掌握得十分透彻，否则评价结果就不可靠和准确。<br>改进方法：<br>(1) 成对比较矩阵可以采用德尔菲法获得。<br>(2) 如果评价指标个数过多（一般超过9个），利用层次分析法所得到的权重就有一定的偏差，继而组合评价模型的结果就不再可靠。可以根据评价对象的实际情况和特点，利用一定的方法，将各原始指标分层和归类，使得每层各类中的指标数少于9个。<br><strong>3.2 灰色综合评价法（灰色关联度分析）</strong><br>基本思想：灰色关联分析的实质就是，可利用各方案与最优方案之间关联度大小对评价对象进行比较、排序。关联度越大，说明比较序列与参考序列变化的态势越一致，反之，变化态势则相悖。由此可得出评价结果。<br>基本步骤：建立原始指标矩阵；确定最优指标序列；进行指标标准化或无量纲化处理；求差序列、最大差和最小差；计算关联系数；计算关联度。 优点：是一种评价具有大量未知信息的系统的有效模型，是定性分析和定量分析相结合的综合评价模型，该模型可以较好地解决评价指标难以准确量化和统计的问题，可以排除人为因素带来的影响，使评价结果更加客观准确。整个计算过程简单，通俗易懂，易于为人们所掌握;数据不必进行归一化处理，可用原始数据进行直接计算，可靠性强；评价指标体系可以根据具体情况增减；无需大量样本，只要有代表性的少量样本即可。 缺点：要求样本数据且具有时间序列特性；只是对评判对象的优劣做出鉴别，并不反映绝对水平，故基于灰色关联分析综合评价具有“相对评价”的全部缺点。<br>适用范围：对样本量没有严格要求，不要求服从任何分布，适合只有少量观测数据的问题；应用该种方法进行评价时，指标体系及权重分配是一个关键的问题，选择的恰当与否直接影响最终评价结果。 改进方法： (1) 采用组合赋权法：根据客观赋权法和主观赋权法综合而得权系数。 (2) 结合TOPSIS法：不仅关注序列与正理想序列的关联度，而且关注序列与负理想序列的关联度，依据公式计算最后的关联度。</p><p><strong>3.3 模糊综合评价法</strong><br>基本思想：是以模糊数学为基础，应用模糊关系合成的原理，将一些边界不清、不易定量的因素定量化，从多个因素对被评价事物隶属等级（或称为评语集）状况进行综合性评价的一种方法。综合评判对评判对象的全体，根据所给的条件，给每个对象赋予一个非负实数评判指标，再据此排序择优。 基本步骤：确定因素集、评语集；构造模糊关系矩阵；确定指标权重；进行模糊合成和做出评价。 优点：:数学模型简单，容易掌握，对多因素、多层次的复杂问题评判效果较好。模糊评判模型不仅可对评价对象按综合分值的大小进行评价和排序，而且还可根据模糊评价集上的值按最大隶属度原则去评定对象所属的等级，结果包含的信息量丰富。评判逐对进行，对被评对象有唯一的评价值，不受被评价对象所处对象集合的影响。接近于东方人的思维习惯和描述方法，因此它更适用于对社会经济系统问题进行评价。 缺点：并不能解决评价指标间相关造成的评价信息重复问题，隶属函数的确定还没有系统的方法，而且合成的算法也有待进一步探讨。其评价过程大量运用了人的主观判断，由于各因素权重的确定带有一定的主观性，因此，总的来说，模糊综合评判是一种基于主观信息的综合评价方法。 应用范围：广泛地应用于经济管理等领域。综合评价结果的可靠性和准确性依赖于合理选取因素、因素的权重分配和综合评价的合成算子等。 改进方法： (1) 采用组合赋权法：根据客观赋权法和主观赋权法综合而得权系数。<br><strong>3.4 BP神经网络综合评价法</strong><br>基本思想：是一种交互式的评价方法，它可以根据用户期望的输出不断修改指标的权值，直到用户满意为止。因此，一般来说，人工神经网络评价方法得到的结果会更符合实际情况。 优点：神经网络具有自适应能力，能对多指标综合评价问题给出一个客观评价，这对于弱化权重确定中的人为因素是十分有益的。在以前的评价方法中，传统的权重设计带有很大的模糊性，同时权重确定中人为因素影响也很大。随着时间、空间的推移，各指标对其对应问题的影响程度也可能发生变化，确定的初始权重不一定符合实际情况。再者，考虑到整个分析评价是一个复杂的非线性大系统，必须建立权重的学习机制，这些方面正是人工神经网络的优势所在。针对综合评价建模过程中变量选取方法的局限性，采用神经网络原理可对变量进行贡献分析，进而剔除影响不显著和不重要的因素，以建立简化模型，可以避免主观因素对变量选取的干扰。 缺点：ANN在应用中遇到的最大问题是不能提供解析表达式，权值不能解释为一种回归系数，也不能用来分析因果关系，目前还不能从理论上或从实际出发来解释ANN的权值的意义。需要大量的训练样本，精度不高，应用范围是有限的。最大的应用障碍是评价算法的复杂性，人们只能借助计算机进行处理，而这方面的商品化软件还不够成熟。 适用范围：神经网络评价模型具有自适应能力、可容错性，能够处理非线性、非局域性的大型复杂系统。在对学习样本训练中，无需考虑输入因子之间的权系数，ANN通过输入值与期望值之间的误差比较，沿原连接权自动地进行调节和适应，因此该方法体现了因子之间的相互作用。 改进方法： (1) 采用组合评价法：对用其它评价方法得出的结果，选取一部分作为训练样本，一部分作为待测样本进行检验，如此对神经网络进行训练，知道满足要求为止，可得到更好的效果。<strong>3.5 数据包络法(DEA)</strong><br><strong>3.6 组合评价法</strong></p><h2 id="预测模型"><strong>预测模型</strong></h2><p><strong>4.1 回归分析法</strong><br>基本思想：根据历史数据的变化规律，寻找自变量与因变量之间的回归方程式，确定模型参数，据此预测。回归问题分为一元和多元回归、线性和非线性回归。<br>特点：技术比较成熟，预测过程简单；将预测对象的影响因素分解，考察各因素的变化情况，从而估计预测对象未来的数量状态；回归模型误差较大，外推特性差。<br>适用范围：回归分析法一般适用于中期预测。回归分析法要求样本量大且要求样本有较好的分布规律，当预测的长度大于占有的原始数据长度时，采用该方法进行预测在理论上不能保证预测结果的精度。另外，可能出现量化结果与定性分析结果不符的现象，有时难以找到合适的回归方程类型。</p><p><strong>4.2 时间序列分析法</strong><br>基本思想：把预测对象的历史数据按一定的时间间隔进行排列，构成一个随时间变化的统计序列，建立相应的数据随时间变化的变化模型，并将该模型外推到未来进行预测。 适用范围：此方法有效的前提是过去的发展模式会延续到未来，因而这种方法对短期预测效果比较好，而不适合作中长期预测。一般来说，若影响预测对象变化各因素不发生突变，利用时间序列分析方法能得到较好的预测结果；若这些因素发生突变，时间序列法的预测结果将受到一定的影响。</p><p><strong>4.3 灰色预测法</strong><br>基本思想：将一切随机变量看作是在一定范围内变化的灰色变量，不是从统计规律角度出发进行大样本分析研究，而是利用数据处理方法(数据生成与还原)，将杂乱无章的原始数据整理成规律性较强的生成数据来加以研究，即灰色系统理论建立的不是原始数据模型，而是生成数据模型。 适用范围：预测模型是一个指数函数，如果待测量是以某一指数规律发展的，则可望得到较高精度的预测结果。影响模型预测精度及其适应性的关键因素，是模型中背景值的构造及预测公式中初值的选取。</p><p><strong>4.4 BP神经网络法</strong><br>人工神经网络的理论有表示任意非线性关系和学习等的能力，给解决很多具有复杂的不确定性和时变性的实际问题提供了新思想和新方法。 利用人工神经网络的学习功能，用大量样本对神经元网络进行训练，调整其连接权值和闭值，然后可以利用已确定的模型进行预测。神经网络能从数据样本中自动地学习以前的经验而无需繁复的查询和表述过程，并自动地逼近那些最佳刻画了样本数据规律的函数，而不论这些函数具有怎样的形式，且所考虑的系统表现的函数形式越复杂，神经网络这种特性的作用就越明显。 误差反向传播算法(BP算法)的基本思想是通过网络误差的反向传播，调整和修改网络的连接权值和闭值，使误差达到最小，其学习过程包括前向计算和误差反向传播。它利用一个简单的三层人工神经网络模型，就能实现从输入到输出之间任何复杂的非线性映射关系。目前，神经网络模型已成功地应用于许多领域，诸如经济预测、财政分析、贷款抵押评估和破产预测等许多经济领域。 优点：可以在不同程度和层次上模仿人脑神经系统的结构及信息处理和检索等功能，对大量非结构性、非精确性规律具有极强的自适应功能，具有信息记忆、自主学习、知识推理和优化计算等特点，其自学习和自适应功能是常规算法和专家系统技术所不具备的，同时在一定程度上克服了由于随机性和非定量因素而难以用数学公式严密表达的困难。 缺点：网络结构确定困难，同时要求有足够多的历史数据，样本选择困难，算法复杂，容易陷入局部极小点。</p><p><strong>4.5 支持向量机法</strong><br>支持向量机是基于统计学习的机器学习方法，通过寻求结构风险化最小，实现经验风险和置信范围的最小，从而达到在统计样本较少的情况下，亦能获得良好统计规律的目的。 其中支持向量机是统计学习理论的核心和重点。支持向量机是结构风险最小化原理的近似，它能够提高学习机的泛化能力，既能够由有限的训练样本得到小的误差，又能够保证对独立的测试集仍保持小的误差，而且支持向量机算法是一个凸优化问题，因此局部最优解一定是全局最优解，支持向量机就克服了神经网络收敛速度慢和局部极小点等缺陷。 核函数的选取在SVM方法中是一个较为困难的问题，至今没有一定的理论方面的指导。</p><p><strong>4.6 组合预测法</strong><br>在实际预测工作中，从信息利用的角度来说，就是任何一种单一预测方法都只利用了部分有用信息，同时也抛弃了其它有用的信息。为了充分发挥各预测模型的优势，对于同一预测问题，往往可以采用多种预测方法进行预测。不同的预测方法往往能提供不同的有用信息，组合预测将不同预测模型按一定方式进行综合。根据组合定理，各种预测方法通过组合可以尽可能利用全部的信息，尽可能地提高预测精度，达到改善预测性能的目的。 优化组合预测有两类概念，一是指将几种预测方法所得的预测结果，选取适当的权重进行加权平均的一种预测方法，其关键是确定各个单项预测方法的加权系数；二是指在几种预测方法中进行比较，选择拟合度最佳或标准离差最小的预测模型作为最优模型进行预测。组合预测是在单个预测模型不能完全正确地描述预测量的变化规律时发挥其作用的。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模型概要 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="/2022/09/08/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2022/09/08/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>博弈论</h1><h1>博弈模型/博弈论/对策论</h1><h2 id="百科定义">百科定义</h2><p><strong>博弈论</strong>（英语：Game Theory），又译为<strong>对策论</strong>或<strong>赛局理论</strong>，是<a href="https://zh.wikipedia.org/wiki/%E7%BB%8F%E6%B5%8E%E5%AD%A6">经济学</a>的一个分支，1944年<a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC">冯·诺伊曼</a>与<a href="https://zh.wikipedia.org/wiki/%E5%A5%A5%E6%96%AF%E5%8D%A1%C2%B7%E6%91%A9%E6%A0%B9%E6%96%AF%E7%89%B9%E6%81%A9">奥斯卡·摩根斯特恩</a>合著《博弈论与经济行为》，标志着现代系统博弈理论的的初步形成，因此他们被称为“博弈论之父”。博弈论被认为是20世纪经济学最伟大的成果之一。目前可以应用在<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E5%AD%A6">生物学</a>、<a href="https://zh.wikipedia.org/wiki/%E7%BB%8F%E6%B5%8E%E5%AD%A6">经济学</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E5%85%B3%E7%B3%BB">国际关系</a>、<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>、<a href="https://zh.wikipedia.org/wiki/%E6%94%BF%E6%B2%BB%E5%AD%A6">政治学</a>、<a href="https://zh.wikipedia.org/wiki/%E5%86%9B%E4%BA%8B%E6%88%98%E7%95%A5">军事战略</a>，研究<strong>游戏</strong>或者<strong>博弈</strong>内的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法。也是<a href="https://zh.wikipedia.org/wiki/%E9%81%8B%E7%B1%8C%E5%AD%B8">运筹学</a>的一个重要学科。 现代的博弈论的源头是<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC">约翰·冯·诺伊曼</a>对于双人<a href="https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%92%8C%E8%B5%9B%E5%B1%80">零和博弈</a>的混合策略均衡点的发想和证明。</p><h2 id="模型背景">模型背景</h2><ul><li>多个决策者</li><li>每个决策都有自己的决策变量和目标函数</li><li>一个决策者的决策变量以某种形式出现在另一个决策者的目标函数中</li><li>决策者之间的决策行为相互影响</li></ul><h2 id="具体分类">具体分类</h2><ul><li>合作博弈：是否达成有约束性的协议<ul><li>静态动态博弈</li><li>完全信息不完全信息博弈</li></ul></li><li>非合作博弈</li></ul><h2 id="模型三要素">模型三要素</h2><ul><li>参与人：决策者</li><li>策略空间：决策变量的取值范围</li><li>效用函数：决策者的目标函数</li></ul><h2 id="学术词汇">学术词汇</h2><ul><li>零和博弈：双方，一方所得即一方所失。</li><li>策略式博弈（静态博弈）<ul><li>所有玩家同时做策略选择</li><li>知道对手可选的策略</li><li>不知道对手具体会选哪一个策略</li><li>非合作</li></ul></li><li>完全信息：所有玩家都知道在一组策略选择下的每个人的收益。</li></ul><h1>建议看《数学模型》例子很多很详细。</h1><h1>博弈论导论</h1><h3 id="一、什么是博弈论？"><strong>一、什么是博弈论？</strong></h3><p><strong>博弈论(Game Theory)<strong>是</strong>相互依存</strong>情况中的<strong>理性行为</strong>的数学建模。博弈由这几个要素构成：</p><ul><li>玩家(Players)：博弈的参与者</li><li>策略(Strategy)：博弈玩家各自的操作</li><li>收益(Payoff)：博弈玩家的收益，一般用矩阵来表示，在连续的时候也会写成函数。</li><li>信息(Information)：博弈玩家知道的信息</li><li>理性(Rationality)：博弈玩家是理性的，在竞争的情况下使自己的收益最大化</li></ul><p><strong>博弈论方法的本质——相互依存性</strong>：每一方的收益不仅依赖于自己的策略，同时也依赖其他参与方的策略。</p><p><strong>博弈论研究的目标——均衡</strong>：因为博弈的参与方的策略改变会造成收益的变化，所以，各玩家会调整策略使自己的收益最大。在这样的情况下，一个“稳定”的策略选择是值得研究的。各个玩家选择了各自的策略之后，没有动机去改变当前的策略，就形成了稳定的状态。</p><p>定义是抽象的，还是用一些例子来找找感觉吧。</p><h3 id="二、例子：囚徒困境"><strong>二、例子：囚徒困境</strong></h3><p>这个例子应该是众所周知。简要介绍一下：</p><blockquote><p>两个共谋犯罪的人被关入监狱，不能互相沟通情况。①如果两个人都不揭发对方，则由于证据不确定，每个人都坐牢一年；②若一人揭发，而另一人沉默，则揭发者因为立功而立即获释，沉默者因不合作而入狱十二年；③若互相揭发，则因证据确凿，二者都判刑六年。</p></blockquote><p>考察博弈的几个要素：</p><ol><li>玩家：这两个犯罪的人，记为A、B</li><li>策略：二者的策略都是{揭发、沉默}</li><li>收益：用收益矩阵来表示</li></ol><p><img src="https://pic3.zhimg.com/80/v2-978177f121f1046139045e3e7fe4dd3a_720w.jpg" alt="img">囚徒困境收益矩阵</p><p>\4. 信息：这种情况是完全信息的，即，每一参与者都拥有所有其他参与者的收益函数的准确信息。</p><p>剧透一下，囚徒困境的”均衡“，是二人都选择<strong>揭发</strong>的策略。</p><h3 id="三、分类"><strong>三、分类</strong></h3><ul><li>根据玩家数量分为：1人，2人，多人博弈</li><li>根据“同时做决策”还是“轮流做决策”分为：策略式博弈(静态博弈)和扩展式博弈(动态博弈)、</li><li>根据信息的了解情况分为：完全信息博弈和非完全信息博弈</li><li>根据收益分为：零和博弈、非零和博弈</li><li>合作、非合作博弈</li><li>根据策略的数量分为：有限博弈和无限博弈</li></ul><p>当然，上面的分类很杂，我们的课程主要讲了这几种：</p><ol><li>完全信息策略式博弈</li><li>非完全信息策略式博弈</li><li>完全信息扩展式博弈</li><li>非完全信息扩展式博弈</li><li>重复博弈</li></ol><h3 id="四、小结"><strong>四、小结</strong></h3><p>博弈论很有趣的，你会发现很多意想不到的结果。不过，由于博弈论假设每个玩家都是“理性”的，而现实生活却不一定是这样，因此，很多情况下博弈论给出的结论只是一个理论上的参考。</p><p>有一些有意思的小例子，算是智力小测试了，感兴趣可以看看：</p><ol><li>Nim博弈：有一堆硬币，总个数是N；有2个玩家，轮流取硬币。每次可以选择取1枚或2枚。取到最后一枚硬币的人获胜。请问先手有必胜策略还是后手？(和N有关)</li><li>海盗博弈：这个更有意思一些</li></ol><ul><li>有五个理性的海盗，P1、 P2、 P3 、P4 和P5，找到了100个金币，需要想办法分配金币。海盗们有严格的等级制度：P1 &lt; P2 &lt; P3 &lt; P4 &lt; P5。</li><li>海盗世界的分配原则是：等级最高的海盗提出一种分配方案。所有的海盗投票决定是否接受分配，包括提议人。并且在票数相同的情况下，提议人有决定权。如果提议通过，那么海盗们按照提议分配金币。如果没有通过，那么提议人将被扔出船外，然后由下一个最高职位的海盗提出新的分配方案。</li><li>请问，最终每个人分别会获得多少金币呢？</li></ul><h1>博弈论笔记一：策略式博弈及其纳什均衡</h1><p><a href="https://zhuanlan.zhihu.com/p/148303919">序言</a>中介绍了博弈的要素和博弈的分类，那么，怎么“论”呢？当下最重要的，是将博弈用数学语言来描述出来，也就是<strong>形式化</strong>。</p><p>博弈不同的分类：{策略式，扩展式}，{完全信息，非完全信息}等等，都有不同的形式化表示，这一节介绍最简单的一种：<strong>完全信息策略式博弈</strong>。</p><p>与之对应的例子有：囚徒困境(Prisoners’ Dilemma)、古诺竞争(Cournot Competition)。</p><p>对了，顺便提一下，博弈不是“<strong>搏</strong>”而是“<strong>博</strong>”，哈哈，一开始学的时候写错了。</p><h3 id="一、一些概念的定义">一、一些概念的定义</h3><h3 id="1-策略式博弈">1. 策略式博弈</h3><p>策略式博弈也叫静态博弈，它是<strong>一次</strong>博弈：</p><ul><li>所有玩家同时做策略选择</li><li>知道对手可选的策略</li><li>不知道对手具体会选哪一个策略</li><li>非合作</li></ul><p>典型的例子是：石头剪刀布。</p><p>与策略式博弈相对应的是扩展式博弈(动态博弈)。</p><h3 id="2-完全信息">2. 完全信息</h3><p>所有玩家都知道在一组策略选择下的每个人的收益。</p><p><strong>下面把完全信息策略式博弈简写为：策略式博弈</strong></p><h3 id="二、策略式博弈形式化">二、策略式博弈形式化</h3><p>形式化主要是将博弈的要素用数学语言表示出来。对于一个策略式博弈，用{玩家、策略、收益}就可以完全表示。</p><h3 id="1-基础概念的定义">1. 基础概念的定义</h3><p>一个策略式博弈包括：</p><ul><li><strong>玩家集</strong>N：玩家的有限集合</li><li>每个玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">都有<strong>策略集</strong><img src="https://www.zhihu.com/equation?tex=A_i" alt="[公式]">，表示他可以选择的策略的集合</li><li>每个玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">都有<strong>收益函数</strong><img src="https://www.zhihu.com/equation?tex=u_i" alt="[公式]">：<img src="https://www.zhihu.com/equation?tex=A_1+%5Ctimes+A_2+%5Ctimes+%5Cdots+A_N+%5Crightarrow+R" alt="[公式]">，表示在一组策略下它的收益</li></ul><p>此外，有如下定义：</p><ul><li><strong>博弈结果</strong>：<img src="https://www.zhihu.com/equation?tex=a+%3D+%28a_1%2Ca_2%2C%5Cdots%2Ca_N%29" alt="[公式]">，是一组策略构成的元组</li><li><strong>博弈结果空间</strong>：<img src="https://www.zhihu.com/equation?tex=A+%3D+A_1+%5Ctimes+A_2+%5Ctimes+%5Cdots+A_N" alt="[公式]">，则<img src="https://www.zhihu.com/equation?tex=a+%5Cin+A" alt="[公式]"></li><li><strong>对手策略</strong>：<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D+%3D+%28a_1%2C%5Cdots%2Ca_%7Bi-1%7D%2C+a_%7Bi%2B1%7D%2C%5Cdots%2Ca_N%29" alt="[公式]">，则<img src="https://www.zhihu.com/equation?tex=a+%3D+%28a_i%2Ca_%7B-i%7D%29" alt="[公式]"></li></ul><blockquote><p>在策略式博弈中，收益的具体数值并不重要，重要的是收益之间的大小关系，称作偏好关系。任何满足全序关系的集合，都可以用来表示收益。我们通常用实数来表示收益。</p></blockquote><h3 id="2-形式化">2. 形式化</h3><p>集合 <img src="https://www.zhihu.com/equation?tex=+G+%3D+%5C%7BN%2C+%5C%7B+A_i+%5C%7D_%7Bi%3D1%7D%5EN%2C+%5C%7B+u_i+%5C%7D_%7Bi%3D1%7D%5EN+%5C%7D+%5C%5C" alt="[公式]"> 称作<strong>策略式博弈G</strong></p><p>其中<img src="https://www.zhihu.com/equation?tex=N%2CA_i%2Cu_i" alt="[公式]">就是前面定义的那样。</p><h3 id="3-例子：囚徒困境形式化">3. 例子：囚徒困境形式化</h3><p><img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7B%5C%7B1%2C2%5C%7D%2C+%5C%7B+A_1%2CA_2+%5C%7D%2C+%5C%7B+u_1%2Cu_2+%5C%7D+%5C%7D" alt="[公式]"></p><ul><li>玩家集：<img src="https://www.zhihu.com/equation?tex=N+%3D+%5C%7B1%2C2%5C%7D" alt="[公式]">，表示1、2两个囚徒</li><li>策略集：<img src="https://www.zhihu.com/equation?tex=A_1+%3D+A_2+%3D+%5C%7B%E5%9D%A6%E7%99%BD%EF%BC%8C%E6%B2%89%E9%BB%98%5C%7D" alt="[公式]">，为了书写简便，用c表示坦白，用d表示沉默</li><li>收益函数：</li><li><img src="https://www.zhihu.com/equation?tex=u_%7B1%7D%28c%2C+c%29%3D-6%2C+u_%7B1%7D%28c%2C+d%29%3D0%2C+u_%7B1%7D%28d%2C+d%29%3D-1%2C+u_%7B1%7D%28d%2C+c%29%3D-12" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=u_%7B2%7D%28c%2C+c%29%3D-6%2C+u_%7B2%7D%28c%2C+d%29%3D-12%2C+u_%7B2%7D%28d%2C+d%29%3D-1%2C+u_%7B2%7D%28d%2C+c%29%3D0" alt="[公式]"></li><li>用收益矩阵表示如下：</li></ul><p><img src="https://pic3.zhimg.com/80/v2-978177f121f1046139045e3e7fe4dd3a_720w.jpg" alt="img">囚徒困境收益矩阵</p><h3 id="三、纳什均衡">三、纳什均衡</h3><p>我们自然地会去想，在这种条件下，两个囚犯会选择怎样的策略呢？先从A的视角想一下，</p><ul><li>如果B坦白：A选择坦白，收益是(-6)；A选择沉默，收益是(-12)，因此A会坦白。</li><li>如果B沉默：A选择坦白，收益是(0)；A选择沉默，收益是(-1)，因此A会坦白。</li></ul><p>同理，B也是这么想的，因此，两人都会选择坦白。</p><h3 id="1-纳什均衡的想法">1. 纳什均衡的想法</h3><p>从上面的思考中，可以看出这种思想：当对手策略选定的时候，我会调整自己的策略，使得自己收益在几种策略选择中是最大的，这时的策略称为“<strong>最优反应</strong>”。这个时候，<strong>如果对手不改变策略的话，我是没有动机去改变自己的策略的。</strong></p><p>如果每个人的策略都是“最优反应”，那么就会形成一种稳定的局面，这时的<strong>博弈结果</strong>就是<strong>纳什均衡</strong></p><h3 id="2-纳什均衡形式化定义">2. 纳什均衡形式化定义</h3><p><strong>纳什均衡(Nash equilibrium)<strong>是</strong>博弈结果</strong><img src="https://www.zhihu.com/equation?tex=a%5E%7B%2A%7D%3D%5Cleft%28a_%7B1%7D%5E%7B%2A%7D%2C+a_%7B2%7D%5E%7B%2A%7D%2C+%5Cldots%2C+a_%7BN%7D%5E%7B%2A%7D%5Cright%29" alt="[公式]">，使得对于每个玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">都有： <img src="https://www.zhihu.com/equation?tex=+u_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%2A%7D%2C+a_%7B-i%7D%5E%7B%2A%7D%5Cright%29+%5Cgeq+u_%7Bi%7D%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5E%7B%2A%7D%5Cright%29+%5C%5C" alt="[公式]"> (对手策略选定的时候，自己最优)</p><p>纳什均衡<strong>简写为</strong>：<strong>NE</strong></p><h3 id="3-纳什均衡求解：寻找最优反应">3. 纳什均衡求解：寻找最优反应</h3><p>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">关于对手策略<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D" alt="[公式]">的<strong>最优反应</strong>：<img src="https://www.zhihu.com/equation?tex=B_%7Bi%7D%5Cleft%28a_%7B-i%7D%5Cright%29%3D%5Cleft%5C%7Ba_%7Bi%7D+%5Cin+A_%7Bi%7D%3A+u_%7Bi%7D%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29+%5Cgeq+u_%7Bi%7D%5Cleft%28b_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29+%5Ctext+%7B+for+all+%7D+b_%7Bi%7D+%5Cin+A_%7Bi%7D%5Cright%5C%7D" alt="[公式]"></p><p>同时满足所有人的最优反应的博弈结果，就是纳什均衡。也就是对于 <img src="https://www.zhihu.com/equation?tex=%5Cforall+i" alt="[公式]"> ，满足<img src="https://www.zhihu.com/equation?tex=a_%7Bi%7D%5E%7B%2A%7D+%5Cin+B_%7Bi%7D%5Cleft%28a_%7B-i%7D%5E%7B%2A%7D%5Cright%29" alt="[公式]">的博弈结果。</p><h3 id="4-例1：依旧是囚徒困境">4. 例1：依旧是囚徒困境</h3><p><img src="https://pic3.zhimg.com/80/v2-6a22d2cd25ca6b7effb745962834a40a_720w.jpg" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Barray%7D%7Bll%7D+B_%7B1%7D%28c%29%3D%5C%7Bc%5C%7D+%26+B_%7B1%7D%28d%29%3D%5C%7Bc%5C%7D+%5C%5C+B_%7B2%7D%28c%29%3D%5C%7Bc%5C%7D+%26+B_%7B2%7D%28d%29%3D%5C%7Bc%5C%7D+%5Cend%7Barray%7D+%5C%5C" alt="[公式]"> 在收益矩阵上标出这些最优反应：</p><p><img src="https://pic2.zhimg.com/80/v2-1b5d1051d86e9e846d4205899902ceb5_720w.jpg" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=B_1%28c%29%3D%5C%7Bc%5C%7D" alt="[公式]">表示在囚徒2选择c的时候，囚徒1会选择c，因为囚徒1的收益(-6 &gt; -12)。对应矩阵中左边红色的”√“。</p><p>详细分析如下：</p><p><img src="https://pic4.zhimg.com/80/v2-631c45fba73f7fbf0fa71686394261c7_720w.jpg" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=B_1%28d%29%3D%5C%7Bc%5C%7D" alt="[公式]">表示在囚徒2选择d的时候，囚徒1会选择c，因为囚徒1的收益(0 &gt; -1)。对应矩阵中右边红色的”√“。</p><p><img src="https://www.zhihu.com/equation?tex=B_2%28c%29%3D%5C%7Bc%5C%7D" alt="[公式]">表示在囚徒1选择c的时候，囚徒2会选择c，因为囚徒2的收益(-6 &gt; -12)。对应矩阵中上边绿色的”√“。</p><p><img src="https://www.zhihu.com/equation?tex=B_2%28d%29%3D%5C%7Bc%5C%7D" alt="[公式]">表示在囚徒1选择d的时候，囚徒2会选择c，因为囚徒2的收益(0 &gt; -1)。对应矩阵中下边绿色的”√“。</p><p>因此，最终得到满足所有人最优反应的结果：(c,c)，也就是两人都坦白。</p><h3 id="5-例2：古诺竞争">5. 例2：古诺竞争</h3><p>这个例子收益是连续的，不能用矩阵来表示。问题如下：</p><blockquote><p>两个厂商{1, 2}生产和销售同一种商品，厂商<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">生产的数量记为<img src="https://www.zhihu.com/equation?tex=q_i" alt="[公式]">。 每件商品生产成本都是c，售价是：<img src="https://www.zhihu.com/equation?tex=max%280%2Ca-b%28q_1%2Bq_2%29%29" alt="[公式]"> 求纳什均衡</p></blockquote><h3 id="1-形式化">1) 形式化</h3><p><img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7B%5C%7B1%2C2%5C%7D%2C+%5C%7B+q_1%2Cq_2+%5C%7D%2C+%5C%7B+u_1%2Cu_2+%5C%7D+%5C%7D" alt="[公式]"></p><p>其中，收益<img src="https://www.zhihu.com/equation?tex=u_i%28q_1%2Cq_2%29+%3D+%28max%280%2Ca-b%28q_1%2Bq_2%29%29-c%29q_i" alt="[公式]">。(售价-成本)x生产数量</p><h3 id="2-求最优反应函数">2) 求最优反应函数</h3><p>对于厂商1：</p><ul><li>如果<img src="https://www.zhihu.com/equation?tex=q_%7B2%7D+%5Cgeq%28a-c%29+%2F+b" alt="[公式]">，那么对于任意的<img src="https://www.zhihu.com/equation?tex=q_1+%5Cge+0" alt="[公式]">，都有<img src="https://www.zhihu.com/equation?tex=u_%7B1%7D%5Cleft%28q_%7B1%7D%2C+q_%7B2%7D%5Cright%29+%5Cleq+0" alt="[公式]">，即没有正收益</li><li>如果<img src="https://www.zhihu.com/equation?tex=q_%7B2%7D+%3C+%28a-c%29+%2F+b" alt="[公式]">，那么<img src="https://www.zhihu.com/equation?tex=u_1%28q_1%2Cq_2%29+%3D+%28a-b%28q_1%2Bq_2%29%29-c%29q_1" alt="[公式]">。</li><li>固定<img src="https://www.zhihu.com/equation?tex=q_2" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=q_1" alt="[公式]">何时取最大呢？求导！</li><li>求解：<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+u_%7B1%7D%5Cleft%28q_%7B1%7D%2C+q_%7B2%7D%5Cright%29%7D%7B%5Cpartial+q_%7B1%7D%7D%3Da-c-b+q_%7B2%7D-2+b+q_%7B1%7D%3D0+" alt="[公式]">，求得<img src="https://www.zhihu.com/equation?tex=q_%7B1%7D%3D%5Cleft%28a-c-b+q_%7B2%7D%5Cright%29+%2F+2+b" alt="[公式]">，<strong>这就是厂商1的最优反应函数</strong></li></ul><p>同理，对于厂商2，最优反应函数是：<img src="https://www.zhihu.com/equation?tex=q_%7B2%7D%3D%5Cleft%28a-c-b+q_%7B1%7D%5Cright%29+%2F+2b" alt="[公式]"></p><h3 id="3-纳什均衡">3) 纳什均衡</h3><p>对于满足纳什均衡的博弈结果<img src="https://www.zhihu.com/equation?tex=%5Cleft%28q_%7B1%7D%5E%7B%2A%7D%2C+q_%7B2%7D%5E%7B%2A%7D%5Cright%29" alt="[公式]">，有： <img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Barray%7D%7Bl%7D+q_%7B1%7D%5E%7B%2A%7D%3DB_%7B1%7D%5Cleft%28q_%7B2%7D%5E%7B%2A%7D%5Cright%29%3D%5Cleft%28a-c-b+q_%7B2%7D%5E%7B%2A%7D%5Cright%29+%2F+2+b+%5C%5C+q_%7B2%7D%5E%7B%2A%7D%3DB_%7B2%7D%5Cleft%28q_%7B1%7D%5E%7B%2A%7D%5Cright%29%3D%5Cleft%28a-c-b+q_%7B1%7D%5E%7B%2A%7D%5Cright%29+%2F+2+b+%5Cend%7Barray%7D+%5C%5C" alt="[公式]"> 联立方程，解得<img src="https://www.zhihu.com/equation?tex=q_%7B1%7D%5E%7B%2A%7D%3D+q_%7B2%7D%5E%7B%2A%7D%3D%5Cfrac%7Ba-c%7D%7B3b%7D" alt="[公式]"></p><p><img src="https://pic1.zhimg.com/80/v2-2c3439f67583f2459569da619abf4048_720w.jpg" alt="img">最优反应相交之处</p><h3 id="四、小结-2">四、小结</h3><p>这节学习了：</p><ul><li><strong>策略式博弈</strong>形式化</li><li><strong>纳什均衡</strong>的定义及求解</li></ul><p>重要的是理解纳什均衡所表示的意义。纳什均衡并不一定是最优的结果，它是一种稳定的局面，在这种情况下，所有人都没有动机去改变自己的选择。</p><h1>博弈论笔记二：混合策略博弈</h1><h2 id="一、引言">一、引言</h2><p>前面，我们学习了策略式博弈的纳什均衡。每个玩家可选的策略也叫<strong>纯策略</strong>。在前面讲的纳什均衡中，每个玩家都要选定一个纯策略。但有的时候并不能找到一个纯策略的纳什均衡，举例如下：</p><p><img src="https://pic2.zhimg.com/80/v2-c884bd014117579593780431274ee575_720w.jpg" alt="img">没有纯策略纳什均衡</p><p>还有一个常见的例子：石头剪刀布，就没有纯策略的纳什均衡。</p><p>这个时候，需要引入新的概念——混合策略。</p><h3 id="二、混合策略博弈">二、混合策略博弈</h3><p>以石头剪刀布为例，无论双方采用哪种策略组合，输的一方总可以改变策略使自己反败为胜，因此没有纯策略的纳什均衡。通过引入“随机性”来解决这个问题。</p><p>通俗地解释，混合策略就是在纯策略上加上概率，在一次博弈中，玩家随机地选择一种纯策略。</p><h3 id="1-混合策略">1. 混合策略</h3><h3 id="1-纯策略">1)纯策略</h3><p>在前面的一节学习了<strong>纯策略</strong>的表示：玩家i的策略集<img src="https://www.zhihu.com/equation?tex=A_%7Bi%7D%3D%5Cleft%5C%7Ba_%7Bi+1%7D%2C+a_%7Bi+2%7D%2C+%5Cldots%2C+a_%7Bi+n_%7Bi%7D%7D%5Cright%5C%7D" alt="[公式]">，纯策略<img src="https://www.zhihu.com/equation?tex=a_i+%5Cin+A_i" alt="[公式]">。</p><h3 id="2-混合策略">2)混合策略</h3><p><strong>混合策略是给每个纯策略分配一个概率</strong>，一个玩家的策略集就是一个“样本空间”。</p><p>用<img src="https://www.zhihu.com/equation?tex=%5CDelta%28A_i%29" alt="[公式]">表示<img src="https://www.zhihu.com/equation?tex=A_i" alt="[公式]">上的概率分布，即： <img src="https://www.zhihu.com/equation?tex=+%5Cmathbf%7B%5CDelta%7D%5Cleft%28%5Cboldsymbol%7BA%7D_%7B%5Cboldsymbol%7Bi%7D%7D%5Cright%29%3D%5Cleft%5C%7Bp_%7Bi%7D%3D%5Cleft%5C%7Bp_%7Bi+1%7D%2C+p_%7Bi+2%7D%2C+%5Cldots%2C+p_%7Bi+n_%7Bi%7D%7D%5Cright%5C%7D%2C+p_%7Bi+j%7D+%5Cgeq+0%2C+%5Csum_%7Bj%7D+p_%7Bi+j%7D%3D1%5Cright%5C%7D+%5C%5C" alt="[公式]"> 那么，<strong>混合策略</strong><img src="https://www.zhihu.com/equation?tex=p_%7Bi%7D%3D%5Cleft%28p_%7Bi+1%7D%2C+p_%7Bi+2%7D%2C+%5Cldots%2C+p_%7Bi+n_%7Bi%7D%7D%5Cright%29+%5Cin+%5Cmathbf%7B%5CDelta%7D%5Cleft%28A_%7Bi%7D%5Cright%29" alt="[公式]"></p><h3 id="3-混合策略博弈结果">3)混合策略博弈结果</h3><p>混合策略博弈的<strong>博弈结果</strong><img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bp%7D%3D%5Cleft%28%5Cboldsymbol%7Bp%7D_%7B1%7D%2C+%5Cboldsymbol%7Bp%7D_%7B2%7D%2C+%5Cldots%2C+%5Cboldsymbol%7Bp%7D_%7BN%7D%5Cright%29%2C+p_%7Bi%7D+%5Cin+%5CDelta%5Cleft%28A_%7Bi%7D%5Cright%29" alt="[公式]"></p><p>定义<img src="https://www.zhihu.com/equation?tex=p_%7B-i%7D%3D%5Cleft%28p_%7B1%7D%2C+%5Cldots%2C+p_%7Bi-1%7D%2C+p_%7Bi%2B1%7D%2C+%5Cldots%2C+p_%7BN%7D%5Cright%29" alt="[公式]">，则<img src="https://www.zhihu.com/equation?tex=p%3D%5Cleft%28p_%7Bi%7D%2C+p_%7B-i%7D%5Cright%29" alt="[公式]"></p><h3 id="2-期望收益">2. 期望收益</h3><p>在这样一个“随机”的博弈中，收益如何计算呢？这就需要计算期望的收益了。期望的收益就是纯策略的博弈结果的收益乘上这个结果出现的概率，对每个博弈结果进行求和。</p><p>给定一个策略式博弈<img src="https://www.zhihu.com/equation?tex=G%3D%5Cleft%5C%7BN%2C%5Cleft%5C%7BA_%7Bi%7D%5Cright%5C%7D%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D" alt="[公式]">和一个混合策略博弈结果<img src="https://www.zhihu.com/equation?tex=p%3D%5Cleft%28p_%7B1%7D%2C+p_%7B2%7D%2C+%5Cdots%2C+p_%7BN%7D%5Cright%29" alt="[公式]">，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的<strong>期望收益</strong>是 <img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Barray%7D%7Bl%7D+U_%7Bi%7D%28p%29%3D%5Csum_%7Ba+%5Cin+A%7D+p%28a%29+u_%7Bi%7D%28a%29+%5C%5C+%3D%5Csum_%7Ba%3D%5Cleft%28a_%7B1%7D%2C+%5Cldots%2C+a_%7BN%7D%5Cright%29+%5Cin+A%7D+p_%7B1%7D%5Cleft%28a_%7B1%7D%5Cright%29+%5Ctimes+%5Ccdots+%5Ctimes+p_%7BN%7D%5Cleft%28a_%7BN%7D%5Cright%29+u_%7Bi%7D%28a%29+%5Cend%7Barray%7D+%5C%5C" alt="[公式]"></p><p>(假设每个玩家的决策是独立的，因此是每个玩家的相应策略的概率乘积)</p><h3 id="3-形式化——混合策略博弈">3. 形式化——混合策略博弈</h3><p><img src="https://www.zhihu.com/equation?tex=+G%3D%5Cleft%5C%7BN%2C%5Cleft%5C%7B%5CDelta%5Cleft%28A_%7B1%7D%5Cright%29%2C+%5CDelta%5Cleft%28A_%7B2%7D%5Cright%29%2C+%5Cldots%2C+%5CDelta%5Cleft%28A_%7BN%7D%5Cright%29%5Cright%5C%7D%2C%5Cleft%5C%7BU_%7B1%7D%2C+U_%7B2%7D%2C+%5Cldots%2C+U_%7BN%7D%5Cright%5C%7D%5Cright%5C%7D+%5C%5C" alt="[公式]"></p><h3 id="4-例子">4. 例子</h3><p>在下面的博弈中，假设<img src="https://www.zhihu.com/equation?tex=%5Cpi_1%3D0.4%2C%5Cpi_2%3D0.5" alt="[公式]">是策略U和策略L的概率，那么：</p><p><img src="https://pic4.zhimg.com/80/v2-9a71b2ab77adfc25c438bf601d23a327_720w.jpg" alt="img"></p><h3 id="三、混合策略纳什均衡">三、混合策略纳什均衡</h3><h3 id="1-定义：混合策略纳什均衡-MNE">1. 定义：混合策略纳什均衡(MNE)</h3><p>一个混合策略博弈结果<img src="https://www.zhihu.com/equation?tex=p%3D%5Cleft%28p_%7B1%7D%2C+p_%7B2%7D%2C+%5Cdots%2C+p_%7BN%7D%5Cright%29" alt="[公式]">是一个混合策略纳什均衡(mixed strategy Nash equilibrium)，当对于每个玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">，都有： <img src="https://www.zhihu.com/equation?tex=+U_%7Bi%7D%5Cleft%28p_%7Bi%7D%2C+p_%7B-i%7D%5Cright%29+%5Cgeq+U_%7Bi%7D%5Cleft%28p_%7Bi%7D%5E%7B%5Cprime%7D%2C+p_%7B-i%7D%5Cright%29+%5Ctext+%7B+for+%7D+p_%7Bi%7D%5E%7B%5Cprime%7D+%5Cin+%5CDelta%5Cleft%28A_%7Bi%7D%5Cright%29+%5C%5C" alt="[公式]"> 通俗地解释就是：<strong>每个玩家都选择在对手不改变的情况下的最好的分布</strong></p><p>简写为：MNE</p><h3 id="2-最优反应"><strong>2. 最优反应</strong></h3><p>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的最优反应<img src="https://www.zhihu.com/equation?tex=B_%7Bi%7D%5Cleft%28p_%7B-i%7D%5Cright%29%3D%5Cleft%5C%7Bp_%7Bi%7D%3A+U_i%5Cleft%28p_%7Bi%7D%2C+p_%7B-i%7D%5Cright%29+%5Cgeq+U_i%5Cleft%28p_%7Bi%7D%5E%7B%5Cprime%7D%2C+p_%7B-i%7D%5Cright%29+%5Ctext+%7B+for+all+%7D+p_%7Bi%7D%5E%7B%5Cprime%7D+%5Cin+%5CDelta%5Cleft%28A_%7Bi%7D%5Cright%29%5Cright%5C%7D" alt="[公式]"></p><p>定理：<img src="https://www.zhihu.com/equation?tex=p%3D%5Cleft%28p_%7B1%7D%2C+p_%7B2%7D%2C+%5Cdots%2C+p_%7BN%7D%5Cright%29" alt="[公式]">是MNE当且仅当对于所有的<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=p_%7Bi%7D+%5Cin+B_%7Bi%7D%5Cleft%28p_%7B-i%7D%5Cright%29" alt="[公式]"></p><h3 id="3-存在性：纳什定理">3. 存在性：纳什定理</h3><p>定理：<strong>有限的</strong>策略式博弈一定存在<strong>混合策略</strong>纳什均衡</p><p>有限指：有限的玩家，每个玩家都有有限种纯策略。</p><h3 id="4、求解混合策略纳什均衡">4、求解混合策略纳什均衡</h3><p>定理：<img src="https://www.zhihu.com/equation?tex=p%3D%5Cleft%28p_%7B1%7D%2C+p_%7B2%7D%2C+%5Cdots%2C+p_%7BN%7D%5Cright%29" alt="[公式]">是MNE当且仅当玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的每个具有正概率的纯策略都是<img src="https://www.zhihu.com/equation?tex=p_%7B-i%7D" alt="[公式]">的最优反应。(证明略)</p><p>也就是说，<strong>玩家</strong><img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"><strong>选任意一种纯策略的期望收益是相同的</strong>。</p><p>用这个定理来求解MNE</p><h3 id="例子">例子</h3><p><img src="https://pic2.zhimg.com/80/v2-d8e93e71507dc22b259a320fe39e7601_720w.jpg" alt="img"></p><p>设玩家1选择U的概率是<img src="https://www.zhihu.com/equation?tex=%5Cpi_1" alt="[公式]">，玩家2选择L的概率是<img src="https://www.zhihu.com/equation?tex=%5Cpi_2" alt="[公式]"></p><p>由玩家2选L的期望收益等于玩家2选R的期望收益，得式子： <img src="https://www.zhihu.com/equation?tex=+2+%5Cpi_%7B1%7D%2B5%5Cleft%281-%5Cpi_%7B1%7D%5Cright%29%3D4+%5Cpi_%7B1%7D%2B2%5Cleft%281-%5Cpi_%7B1%7D%5Cright%29+%5C%5C" alt="[公式]"> 由玩家1选U的期望收益等于玩家1选D的期望收益，得式子： <img src="https://www.zhihu.com/equation?tex=+%5Cpi_%7B2%7D%3D3%5Cleft%281-%5Cpi_%7B2%7D%5Cright%29+%5C%5C" alt="[公式]"> 解得：<img src="https://www.zhihu.com/equation?tex=%5Cpi_1%3D0.6%2C%5Cpi_2%3D0.75" alt="[公式]"></p><p>因此求得纳什均衡<img src="https://www.zhihu.com/equation?tex=p+%3D+%5C%7B%5C%7B0.6%2C0.4%5C%7D%2C%5C%7B0.75%2C0.25%5C%7D%5C%7D" alt="[公式]"></p><h3 id="解释">解释</h3><p><strong>”玩家</strong><img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">**选任意一种纯策略的期望收益是相同的“**也可以这么想：如果玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的纯策略的期望收益不同的话，那么他会一直选期望收益高的那个，也就是选择一个纯策略，而不是混合策略。这样就回到了纯策略博弈的时代，开篇的例子又说明了有些博弈是找不到纯策略的均衡的。</p><p>因此，如果想保持一种”稳定“的局面，每个玩家都没有动机改变当前的策略(或分布)，就要保证它选择每个策略的期望收益都相同。</p><h3 id="四、小结-3">四、小结</h3><p>本篇内容有：</p><ul><li>混合策略博弈的定义</li><li>混合策略纳什均衡的定义及求解</li></ul><h1>博弈论笔记三：占优策略均衡和理性化</h1><h3 id="一、占优策略-Dominant-Strategy">一、占优策略(Dominant Strategy)</h3><h3 id="1-例子">1. 例子</h3><p>在囚徒困境中，收益矩阵是这样的：</p><p><img src="https://pic3.zhimg.com/80/v2-7efcc3f20c9ca67759f1f22d4440279e_720w.jpg" alt="img"></p><ul><li>当玩家2选择confess的时候，玩家1选confess是最优的；</li><li>当玩家2选择don’t confess的时候，玩家1选confess是最优的；</li></ul><p>可以发现，不管玩家2如何选择，玩家1选择(confess)都是最优的。那么，对于玩家1来说，confess这个策略就是占优策略。</p><h3 id="2-形式化定义">2. 形式化定义</h3><p>沿用<a href="https://zhuanlan.zhihu.com/p/148407108">策略式博弈</a>的记号，定义：</p><ol><li><strong>严格占优于</strong>：<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">是一个玩家的两种纯策略，若对于所有<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D+%5Cin+A_%7B-i%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=u_%7Bi%7D%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29%3Eu_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%2C+a_%7B-i%7D%5Cright%29" alt="[公式]">，则称策略 <img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]"><strong>严格占优于</strong><img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]"></li><li><strong>弱占优于</strong>：<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">是一个玩家的两种纯策略，若对于所有<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D+%5Cin+A_%7B-i%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=u_%7Bi%7D%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29+%5Cge+u_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%2C+a_%7B-i%7D%5Cright%29" alt="[公式]">，且对于某些<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D+%5Cin+A_%7B-i%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=u_%7Bi%7D%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29+%3E+u_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%2C+a_%7B-i%7D%5Cright%29" alt="[公式]">，则称策略 <img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]"><strong>弱占优于</strong><img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]"></li><li><strong>严格占优策略</strong>：如果<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">严格占优于玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">其他所有策略，则称<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">是严格占优策略。</li><li><strong>弱占优策略</strong>：如果<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">弱占优于玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">其他所有策略，则称<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">是弱占优策略。</li></ol><p>严格占优就是收益<strong>高于</strong>其他策略；弱占优就是收益<strong>不低于</strong>其他策略，且有时高于其他策略。</p><h3 id="二、占优策略均衡">二、占优策略均衡</h3><p>定义：<strong>每个玩家的占优策略</strong>（严格占优策略或弱占优策略）构成的博弈结果，称为占优策略均衡。</p><p>从定义可以看出，占优策略均衡属于纳什均衡。</p><p>性质：易求解，但可能不存在。</p><h3 id="三、例：第二价格拍卖-维克里拍卖">三、例：第二价格拍卖(维克里拍卖)</h3><p>N个买家通过密封投标的方式竞价，出价最高的投标者获得被拍卖的商品，并支付<strong>第二高</strong>的出价。竞品对玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的价值是<img src="https://www.zhihu.com/equation?tex=v_i" alt="[公式]">，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的出价是<img src="https://www.zhihu.com/equation?tex=b_i" alt="[公式]">。</p><p>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的收益：<img src="https://www.zhihu.com/equation?tex=v_i-b_i" alt="[公式]"></p><p>定理：在第二价格拍卖中，对于任意玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">，策略<img src="https://www.zhihu.com/equation?tex=b_i%3Dv_i" alt="[公式]">是一个弱占优策略，即，<img src="https://www.zhihu.com/equation?tex=%28v_1%2Cv_2%2C%5Cdots%2Cv_N%29" alt="[公式]">是一个占优策略均衡。</p><p>证明：即需证明对于任意<img src="https://www.zhihu.com/equation?tex=b_i%2Cb_%7B-i%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=u_%7Bi%7D%5Cleft%28v_%7Bi%7D%2C+b_%7B-i%7D%5Cright%29+%5Cgeq+u_%7Bi%7D%5Cleft%28b_%7Bi%7D%2C+b_%7B-i%7D%5Cright%29" alt="[公式]">，分情况讨论如下：</p><ul><li>如果某人的竞价<img src="https://www.zhihu.com/equation?tex=b_k+%5Cge+v_i" alt="[公式]"></li><li><ul><li>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">若想竞拍成功，则<img src="https://www.zhihu.com/equation?tex=b_i+%3E+b_k+%5Cge+v_i" alt="[公式]">的收益小于0，不如选<img src="https://www.zhihu.com/equation?tex=b_i+%3D+v_i" alt="[公式]">的策略(收益为0)。</li><li>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">若竞拍不成功，收益为0，和<img src="https://www.zhihu.com/equation?tex=b_i+%3D+v_i" alt="[公式]">的策略相同。</li></ul></li><li>如果所有人的竞价<img src="https://www.zhihu.com/equation?tex=b_k+%3C+v_i" alt="[公式]"></li><li><ul><li>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">若竞拍成功，则收益大于0，收益取决于<img src="https://www.zhihu.com/equation?tex=b_k" alt="[公式]">的最大值(第二价格)，因此，没有比<img src="https://www.zhihu.com/equation?tex=b_i%3Dv_i" alt="[公式]">更好的选择了</li><li>竞拍不成功，收益为0，不如<img src="https://www.zhihu.com/equation?tex=b_i%3Dv_i" alt="[公式]">的策略</li></ul></li></ul><h3 id="四、被占优策略-Dominated-Strategies">四、被占优策略(Dominated Strategies)</h3><ul><li><img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">严格占优于<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">，称<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">被<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">严格占优。</li><li><img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">弱占优于<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">，称<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">被<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">弱占优。</li></ul><h3 id="1-消除被占优策略可以用来求解占优策略均衡-迭代">1. 消除被占优策略可以用来求解占优策略均衡(迭代)</h3><p>例：</p><p><img src="https://pic4.zhimg.com/80/v2-9900f7b53810c844a29ced3465315347_720w.jpg" alt="img"></p><ul><li>对于玩家1：‘u’策略被‘d’策略弱占优。</li><li>对于玩家2：‘l’策略被‘r’策略弱占优。</li></ul><p>消除被占优策略‘u’和‘l’，得：</p><p><img src="https://pic1.zhimg.com/80/v2-de7e516d69ac77cc6adfd50bc32d942c_720w.jpg" alt="img"></p><ul><li>对于玩家1：‘m’策略被‘d’策略弱占优。</li><li>消去玩家1的‘m’策略后，对于玩家2：‘m’策略被‘r’策略严格占优。</li></ul><p>最后，得到(d,r)是占优策略均衡(弱占优策略均衡)</p><h3 id="2-消除被占优策略可以用来简化混合策略纳什均衡-MNE-求解">2. 消除被占优策略可以用来简化混合策略纳什均衡(MNE)求解</h3><p><strong>一个策略可以被一个“混合策略”占优</strong>，如：</p><p><img src="https://pic2.zhimg.com/80/v2-994a0357d27e5164c4aa951a979638f9_720w.jpg" alt="img"></p><p>对于玩家1，没有纯策略能够占优于策略‘u’，但是不难看出混合策略<img src="https://www.zhihu.com/equation?tex=p_1+%3D+%280%2C+0.5%2C0.5%29" alt="[公式]">严格占优于纯策略‘u’，更一般地，设玩家2的混合策略是<img src="https://www.zhihu.com/equation?tex=p_2%3D%28p%2C1-p%29" alt="[公式]">，也就是以概率p选择l策略。</p><p>则玩家1在三种纯策略上的收益为： <img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Barray%7D%7Bl%7D+U_%7B1%7D%5Cleft%28%5Cmathrm%7Bu%7D%2C+p_%7B2%7D%5Cright%29%3D1+%5C%5C+U_%7B1%7D%5Cleft%28%5Cmathrm%7Bm%7D%2C+p_%7B2%7D%5Cright%29%3D3+p+%5C%5C+U_%7B1%7D%5Cleft%28%5Cmathrm%7Bd%7D%2C+p_%7B2%7D%5Cright%29%3D4%281-p%29+%5Cend%7Barray%7D+%5C%5C" alt="[公式]"> 画图如下：</p><p><img src="https://pic4.zhimg.com/80/v2-f209039b80be6d0d514ff02564fc5c0b_720w.jpg" alt="img"></p><p>可见，‘u’这个策略始终都不是最好的策略。</p><h3 id="定理：被严格占优的策略在MNE中概率为0">定理：被严格占优的策略在MNE中概率为0</h3><p>证明：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/148772400">笔记(二)</a>MNE那一节讲过，每个具有正概率的纯策略都是<img src="https://www.zhihu.com/equation?tex=p_%7B-i%7D" alt="[公式]">的最优反应，也就是玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">选任意一种纯策略的期望收益是相同的。</li><li>但是，因为<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">被<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">严格占优，因此<img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7BU%7D_%7Bi%7D%5Cleft%28a_%7Bi%7D%2C+p_%7B-i%7D%5Cright%29%3C%5Cmathrm%7BU%7D_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%2C+p_%7B-i%7D%5Cright%29" alt="[公式]">，因此，MNE中，<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">的概率为0</li></ul><p>利用这一定理，可以<strong>消去被严格占优的策略</strong>，简化MNE的求解。</p><h3 id="五、信念和理性化">五、信念和理性化</h3><h3 id="1-信念-belief">1. 信念(belief)</h3><p>定义：“信念”的意思，就是认为对手会采用什么样的策略。对于混合策略博弈，博弈结果<img src="https://www.zhihu.com/equation?tex=p%3D%5Cleft%28p_%7B1%7D%2C+p_%7B2%7D%2C+%5Cldots+p_%7BN%7D%5Cright%29+%3D+%28p_i%2Cp_%7B-i%7D%29" alt="[公式]">，其中，<img src="https://www.zhihu.com/equation?tex=p_%7B-i%7D" alt="[公式]">称为<strong>信念</strong>(belief)</p><h3 id="2-理性">2. 理性</h3><p>纯策略<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">是<strong>理性</strong>的，当：存在信念<img src="https://www.zhihu.com/equation?tex=p_%7B-i%7D" alt="[公式]">使得<img src="https://www.zhihu.com/equation?tex=a_%7Bi%7D" alt="[公式]">是<img src="https://www.zhihu.com/equation?tex=p_%7B-i%7D" alt="[公式]">的最优反应。</p><p>定理：在MNE中，每一个具有正概率的纯策略都是理性的。</p><p>定理：<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">是理性的<strong>当且仅当</strong><img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">不被严格占优。</p><h3 id="3-理性化">3. 理性化</h3><p>理性化：<strong>迭代</strong>消除被严格占优的策略直到没有被严格占优的策略。</p><h3 id="六、例：选美比赛博弈-Beauty-Contest-game">六、例：选美比赛博弈(Beauty Contest game)</h3><ul><li>n个玩家</li><li>每个人选[0,50]之间的一个数</li><li>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的收益是：<img src="https://www.zhihu.com/equation?tex=50-%5Cleft%28a_%7Bi%7D-%5Cfrac%7B2%7D%7B3%7D+%5Cfrac%7B%5Csum_%7Bi%7D+a_%7Bi%7D%7D%7Bn%7D%5Cright%29%5E%7B2%7D" alt="[公式]">，即与平均数的 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B2%7D%7B3%7D" alt="[公式]"> 越接近，收益越高。</li></ul><p>分析：</p><p>给定对手的策略<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D" alt="[公式]">，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的最优反应： <img src="https://www.zhihu.com/equation?tex=+a_%7Bi%7D%5E%7B%2A%7D%3D%5Cfrac%7B2%7D%7B3%7D+%5Cfrac%7B%5Csum_%7Bj%2C+j+%5Cneq+i%7D+a_%7Bj%7D%7D%7Bn-2+%2F+3%7D+%5C%5C" alt="[公式]"> 可以发现： <img src="https://www.zhihu.com/equation?tex=+a_%7Bi%7D%5E%7B%2A%7D+%5Cin%5Cleft%5B0%2C+%5Cfrac%7B2%7D%7B3%7D+%5Cfrac%7Bn-1%7D%7Bn-2+%2F+3%7D+50%5Cright%5D+%5C%5C" alt="[公式]"> 这时，在<img src="https://www.zhihu.com/equation?tex=%28%5Cfrac%7B2%7D%7B3%7D+%5Cfrac%7Bn-1%7D%7Bn-2+%2F+3%7D+50%2C50%5D" alt="[公式]">之间的策略都被严格占优，消去。</p><p>迭代理性化，第k次会得到区间：<img src="https://www.zhihu.com/equation?tex=%5Cleft%5B0%2C%5Cleft%28%5Cfrac%7B2%7D%7B3%7D+%5Cfrac%7Bn-1%7D%7Bn-2+%2F+3%7D%5Cright%29%5E%7Bk%7D+50%5Cright%5D" alt="[公式]"></p><p>一直迭代下去，最终得到结果：0</p><p>因此，纳什均衡是每个人的策略都是选0</p><h1>博弈论笔记四：连续博弈</h1><blockquote><p>前面讲过了：策略式博弈以及它的纳什均衡。其中，纳什均衡的<strong>存在性</strong>是由<strong>纳什定理</strong>保证的(在笔记二讲过)：<strong>有限的</strong>策略式博弈一定存在<strong>混合策略</strong>纳什均衡。<br>纳什定理的限制条件是“有限的”策略式博弈。有限是指每个玩家都有有限种纯策略。<br>现在在策略式博弈中，加入其他的约束条件，<strong>纳什均衡的存在性</strong>也会得到保证。连续博弈就是加入了这些约束条件的策略式博弈。具体来说，这些约束条件是对<strong>策略集</strong>和<strong>收益函数</strong>的约束。</p></blockquote><h3 id="一、连续博弈定义">一、连续博弈定义</h3><p>连续博弈是一种满足某些约束的<strong>策略式博弈</strong>，约束为：</p><ul><li>策略集<img src="https://www.zhihu.com/equation?tex=A_i" alt="[公式]">是非空的紧集</li><li>收益函数<img src="https://www.zhihu.com/equation?tex=u_i%3AA+%5Crightarrow+R" alt="[公式]">是连续的</li></ul><h3 id="二、定理">二、定理</h3><h3 id="1-纳什定理-回顾">1. 纳什定理(回顾)</h3><p><strong>有限的</strong>策略式博弈一定存在<strong>混合策略</strong>纳什均衡</p><h3 id="2-无限博弈纯策略纳什均衡存在定理">2. 无限博弈纯策略纳什均衡存在定理</h3><p>若策略式博弈<img src="https://www.zhihu.com/equation?tex=G%3D%5Cleft%5C%7BN%2C%5Cleft%5C%7BA_%7Bi%7D%5Cright%5C%7D%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D" alt="[公式]">对于每个<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">都满足：</p><ul><li><img src="https://www.zhihu.com/equation?tex=A_i" alt="[公式]">是紧集，凸集</li><li><img src="https://www.zhihu.com/equation?tex=u_i%28a_i%2Ca_%7B-i%7D%29" alt="[公式]">在<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D" alt="[公式]">上连续</li><li><img src="https://www.zhihu.com/equation?tex=u_i%28a_i%2Ca_%7B-i%7D%29" alt="[公式]">在<img src="https://www.zhihu.com/equation?tex=a_%7Bi%7D" alt="[公式]">上是连续的、紧致(concave)的</li></ul><p>那么存在<strong>纯策略</strong>纳什均衡。</p><h3 id="3-无限博弈混合策略纳什均衡存在定理">3. 无限博弈混合策略纳什均衡存在定理</h3><p>若策略式博弈<img src="https://www.zhihu.com/equation?tex=G%3D%5Cleft%5C%7BN%2C%5Cleft%5C%7BA_%7Bi%7D%5Cright%5C%7D%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D" alt="[公式]">对于每个<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">都满足：</p><ul><li><img src="https://www.zhihu.com/equation?tex=A_i" alt="[公式]">是紧集，凸集</li><li><img src="https://www.zhihu.com/equation?tex=u_i%28a%29" alt="[公式]">在<img src="https://www.zhihu.com/equation?tex=a" alt="[公式]">上连续</li></ul><p>那么存在<strong>混合策略</strong>纳什均衡。</p><blockquote><p>上面两个定理需要满足的条件我不懂，数学基础比较薄弱……</p></blockquote><h3 id="三、求解纳什均衡">三、求解纳什均衡</h3><p>求解纳什均衡，就是这两个步骤：</p><ul><li>找到最优反应函数</li><li>找到同时满足所有玩家最优反应函数的解</li></ul><h3 id="四、总结">四、总结</h3><p>这节课没有什么新的内容，主要是例题，比如古诺模型(Cournot)，伯特兰德模型(Bertrand)，还有一些其他的。现在比较懒不想写……</p><h1>博弈论笔记五：相关均衡</h1><blockquote><p>纳什均衡中，每个玩家独立地进行策略选择。然而，这种方式有时并不会达到很好的收益，很多坏的策略也会被选到。其实，玩家可以“约定”一下，不去选择坏的结果，这样会提高收益。<br>相关策略中，玩家的策略选择不是独立的。和混合策略在<strong>每个玩家的策略集</strong>上加上概率分布不同，相关策略是在<strong>所有玩家的策略组合</strong>上加上概率分布。</p></blockquote><h3 id="一、引入相关均衡">一、引入相关均衡</h3><h3 id="1-性别战">1. 性别战</h3><p>收益矩阵如下：策略Ballet和Football分别用B、F代替</p><p><img src="https://pic4.zhimg.com/80/v2-40947af9d7393c801aac5cfb6847abdf_720w.jpg" alt="img"></p><p>根据之前的学习，不难求出纯策略纳什均衡和混合策略纳什均衡。</p><p>纯策略纳什均衡：{(B, B), (F, F)}，收益分别为(1, 4)和(4, 1)</p><p>混合策略纳什均衡：Boy以1/5的概率选择B，以4/5的概率选择F；Boy以4/5的概率选择B，以1/5的概率选择F；期望收益为：(4/5, 4/5)。这个收益比纯策略纳什均衡最坏情况还要低。</p><p>现在考虑一个约定：掷一枚均匀的硬币，根据掷硬币的结果来告诉玩家应该选择那种策略。例如，若硬币是正面，那Boy就被告知应该选择B，Girl被告知应该选择B；若硬币是反面，那Boy就被告知应该选择F，Girl被告知应该选择F。也就是(B, B), (F, F)这两种博弈结果都以1/2的概率出现。</p><p>如果这个约定能被两人遵守的话，那么收益将会是(5/2, 5/2)，比混合策略纳什均衡好很多。</p><p>关键点就在于：<strong>没有人有违背约定的动机</strong>。在上面的例子里，假设Boy单方面违背约定，在硬币正面的时候，选择了F策略，那么，博弈结果将会是(F, B)，Boy的收益是0。如果遵守约定，收益将会是1。因此，<strong>当违背约定的期望收益不如遵守约定时，所有玩家就都会遵守约定了，这就是相关均衡</strong>。</p><h3 id="2-十字路口博弈">2. 十字路口博弈</h3><p>这是一个更复杂一点的例子。在一个十字路口有A、B两车，如下右图所示。A有上(U)、下(D)两种策略，B有左(L)、右®两种策略。如果A选择U，B选择R，就“撞车”了，收益为(0, 0)，其余收益就不多解释了，如下左图所示。</p><p><img src="https://pic4.zhimg.com/80/v2-5a1f6429565968fbf34afeadc3da7acf_720w.jpg" alt="img"></p><p>纯策略纳什均衡是(U, L)和(D, R)</p><p>混合策略那是均衡是A以1/2的概率选择U，B以1/2的概率选择L。收益为(5/2, 5/2)</p><h3 id="第一种约定">第一种约定</h3><p>现在假设有一个“信号灯”，以均等概率产生“红“、“绿”两种颜色。约定：如果是绿色，A选择U、B选择L；如果是红色，A选择D，B选择R。也就是(U, L)和(D, R)这两种博弈结果都以1/2的概率出现。</p><p>如果遵守约定，两人的期望收益为：(3, 3)，高于混合策略博弈。</p><p><strong>没有玩家会违背约定</strong>：如果A看见信号等是绿色，也就是他被告知选择U，B被告知选择L。如果A遵守约定，收益是5；如果A违背约定，博弈结果变为(D, L)，收益将会是4。其他情况与此类似。</p><h3 id="第二种约定">第二种约定</h3><p>还可以有另一种约定：”信号灯“以相同的概率(1/3)产生(U, L)、(D, L)和(D, R)这三种结果中的一种，并告知两个玩家应该选择的策略。</p><p>期望收益为：(10/3, 10/3)</p><p>下面来说明为什么不会违背约定：</p><ul><li>如果A被告知应该选择U，那么信号灯产生的就是(U, L)这种结果，B被告知选择L。如果A遵守约定，那么A的收益为5；如果A单方面违背约定，那么A的期望收益为4。(博弈结果变为(D, L))。</li><li>如果A被告知应该选择D，那么信号灯产生的就是(D, L)或者(D, R)的博弈结果，且出现概率均等。即B有1/2的概率被告知选择L，1/2的概率被告知选择R。如果A遵守约定，那么A的收益为5/2；如果A单方面违背约定，那么A的期望收益也为5/2。</li></ul><p>A违背约定收益并不会变高，因此没有动机违背约定。</p><h3 id="二、相关策略">二、相关策略</h3><p>相关策略就是在<strong>博弈结果</strong>上加上分布。</p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta%28A%29" alt="[公式]">表示在策略集<img src="https://www.zhihu.com/equation?tex=A+%3D+A_1+%5Ctimes+A_2+%5Ctimes+%5Cdots%5Ctimes+A_N" alt="[公式]">上的概率分布。<img src="https://www.zhihu.com/equation?tex=%5Cpi+%5Cin+%5CDelta%28A%29" alt="[公式]">就是一个相关策略。</p><p>用<img src="https://www.zhihu.com/equation?tex=R" alt="[公式]">表示在A上的这个随机变量。</p><p>要清楚纯策略、混合策略、相关策略的区别。</p><h3 id="例子-2">例子</h3><p><img src="https://pic4.zhimg.com/80/v2-40947af9d7393c801aac5cfb6847abdf_720w.jpg" alt="img"></p><p>对于混合策略，在四种可能的博弈结果上都有一个概率。混合策略：<img src="https://www.zhihu.com/equation?tex=%5Cpi%3D%28p_1%2Cp_2%2Cp_3%2Cp_4%29" alt="[公式]"></p><p><img src="https://pic2.zhimg.com/80/v2-aecdf56fdac1c2336b0fa449a6448979_720w.jpg" alt="img"></p><ul><li>纯策略(B, F)用混合策略表示就是：<img src="https://www.zhihu.com/equation?tex=%5Cpi+%3D+%281%2C0%2C0%2C0%29" alt="[公式]"></li><li>混合策略<img src="https://www.zhihu.com/equation?tex=%5C%7B%28p%2C1-p%29%2C%28q%2C1-q%29%5C%7D" alt="[公式]">用混合策略表示就是<img src="https://www.zhihu.com/equation?tex=%5Cpi+%3D+%28p+q%2C%281-p%29+q%2C+p%281-q%29%2C%281-p%29+q%2C%281-p%29%281-q%29%29" alt="[公式]"></li></ul><p>混合策略一定可以用相关策略表示，但相关策略不一定能用混合策略表示出来。</p><h3 id="三、相关均衡">三、相关均衡</h3><h3 id="1-原理解释">1. 原理解释</h3><p>相关均衡的概率分布不是随便的，在一定的分布下才会造成相关均衡。什么时候会保持相关均衡呢？那就是<strong>每个人都没有动机偏离约定的选择</strong>的时候。也就是，当玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">被告知选择策略<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">的时候，他选择<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">的期望收益高于选择任何策略<img src="https://www.zhihu.com/equation?tex=a_i%27+%5Cneq+a_i" alt="[公式]">的期望收益。</p><ul><li>如果玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">不偏离约定策略<img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]">，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的期望收益为：<img src="https://www.zhihu.com/equation?tex=%5CSigma_%7Ba_%7B-i%7D%7D+p%28a_i%2C+a_%7B-i%7D%29u%28a_i%2C+a_%7B-i%7D%29" alt="[公式]"></li><li>如果玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">骗了了约定策略，选择了<img src="https://www.zhihu.com/equation?tex=a_i%27" alt="[公式]">策略，那么博弈结果会变为<img src="https://www.zhihu.com/equation?tex=%28a_i%27%2C+a_%7B-i%7D%29" alt="[公式]">，这个博弈结果出现的<strong>概率</strong>为<img src="https://www.zhihu.com/equation?tex=p%28a_i%2Ca_%7B-i%7D%29" alt="[公式]">，也就是<img src="https://www.zhihu.com/equation?tex=%28a_i%2Ca_%7B-i%7D%29" alt="[公式]">的概率，因为只是玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">改变了应该选择的策略。因此期望收益为：<img src="https://www.zhihu.com/equation?tex=%5CSigma_%7Ba_%7B-i%7D%7D+p%28a_i%2C+a_%7B-i%7D%29u%28a_i%27%2C+a_%7B-i%7D%29" alt="[公式]"></li></ul><p>当不偏离约定的期望收益大于等于偏离约定的期望收益时，就构成了相关均衡。</p><h3 id="2-形式化-2">2. 形式化</h3><p>策略式博弈<img src="https://www.zhihu.com/equation?tex=G%3D%5Cleft%5C%7BN%2C%5Cleft%5C%7BA_%7Bi%7D%5Cright%5C%7D%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D" alt="[公式]">的相关均衡是一个联合概率分布<img src="https://www.zhihu.com/equation?tex=%5Cpi+%5Cin+%5CDelta%28A%29" alt="[公式]">，使得对于任何<img src="https://www.zhihu.com/equation?tex=a_i%2Ca_i%27" alt="[公式]">，都有： <img src="https://www.zhihu.com/equation?tex=+%5Csum_%7Ba_%7B-i%7D%7D+p%28a_i%2Ca_%7B-i%7D%29%5Cleft%5Bu_%7Bi%7D%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29-u_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%2C+a_%7B-i%7D%5Cright%29%5Cright%5D+%5Cgeq+0+%5C%5C" alt="[公式]"> 也可以写成： <img src="https://www.zhihu.com/equation?tex=+%5Csum_%7Ba_%7B-i%7D+%5Cin+A_%7B-i%7D%7D+p%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29+u%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29+%5Cgeq+%5Csum_%7Ba_%7B-i%7D+%5Cin+A_%7B-i%7D%7D+p%5Cleft%28a_%7Bi%7D%2C+a_%7B-i%7D%5Cright%29+u%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%2C+a_%7B-i%7D%5Cright%29+%5C%5C" alt="[公式]"></p><h3 id="3-例子：计算相关均衡">3. 例子：计算相关均衡</h3><p><img src="https://pic4.zhimg.com/80/v2-94fe34f2139d73b19c971090d3f0ba3f_720w.jpg" alt="img"></p><p>根据上面的公式，可以列出下面几个式子：</p><p><img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Baligned%7D+2+%5Ctimes+p_%7B1%7D%2B0+%5Ctimes+p_%7B2%7D+%26+%5Cgeq+0+%5Ctimes+p_%7B1%7D%2B5+%5Ctimes+p_%7B2%7D+%5Crightarrow+p_%7B1%7D+%5Cgeq+5+p_%7B2%7D+%2F+2+%5C%5C+0+%5Ctimes+p_%7B3%7D%2B5+%5Ctimes+p_%7B4%7D+%26+%5Cgeq+2+%5Ctimes+p_%7B3%7D%2B0+%5Ctimes+p_%7B4%7D+%5Crightarrow+p_%7B4%7D+%5Cgeq+2+p_%7B3%7D+%2F+5+%5C%5C+5+%5Ctimes+p_%7B1%7D%2B0+%5Ctimes+p_%7B3%7D+%26+%5Cgeq+0+%5Ctimes+p_%7B1%7D%2B2+%5Ctimes+p_%7B3%7D+%5Crightarrow+p_%7B1%7D+%5Cgeq+2+p_%7B3%7D+%2F+5+%5C%5C+0+%5Ctimes+p_%7B2%7D%2B2+%5Ctimes+p_%7B4%7D+%26+%5Cgeq+5+%5Ctimes+p_%7B2%7D%2B0+%5Ctimes+p_%7B4%7D+%5Crightarrow+p_%7B4%7D+%5Cgeq+5+p_%7B2%7D+%2F+2+%5C%5C+p_%7B1%7D+%26%2Bp_%7B2%7D%2Bp_%7B3%7D%2Bp_%7B4%7D%3D1+%5C%5C+p_%7B1%7D+%26%2Cp_%7B2%7D%2Cp_%7B3%7D%2Cp_%7B4%7D%3E%3D0+%5Cend%7Baligned%7D+%5C%5C" alt="[公式]"></p><p>计算是线性时间的，比混合策略纳什均衡好很多。</p><h3 id="4-一些结论">4. 一些结论</h3><ol><li>每个<strong>混合策略纳什均衡</strong>都是一个<strong>相关均衡</strong></li><li>相关均衡的集合是一个凸集。</li></ol><p><img src="https://pic2.zhimg.com/80/v2-6f07bbcd508e1138d84e41e5050e0915_720w.jpg" alt="img"></p><ul><li>CE：相关均衡</li><li>MNE：混合策略纳什均衡</li><li>PNE：纯策略纳什均衡</li></ul><h3 id="四、总结-2">四、总结</h3><p>这节讲相关均衡，最难的点就在于理解这个均衡。理解了为什么不会偏离“约定”，计算相关均衡就很简单了。</p><h1>博弈论笔记(六)：非完全信息策略式博弈</h1><blockquote><p>前面的五节笔记讲的都是<strong>完全信息的策略式博弈</strong>，而这一章才开始一个新的类别——非完全信息策略式博弈。</p></blockquote><h3 id="一、引言：非完全信息">一、引言：非完全信息</h3><p>在一场博弈中，玩家可能并不知道其他玩家的收益、偏好等等。这些情况下的博弈，称为<strong>非完全信息的博弈(Incomplete Information)</strong>。在非完全信息策略式博弈中，我们考虑一种情况：<strong>玩家有一个隐藏的“状态”，在不同的状态下，收益矩阵不同</strong>。其他的非完全信息策略式博弈都可以转化为这种模型。</p><h3 id="二、例：-非完全信息">二、例：(非完全信息)</h3><p>男生和女生决定去看足球(F)还是去看芭蕾(B)，如果两个人都知道对方喜欢自己，那么这是一个完全信息博弈，收益矩阵是这样的：</p><p><img src="https://pic1.zhimg.com/80/v2-09b3ac3268ae9514eae71e94498603ec_720w.jpg" alt="img"></p><p>现在假设这样的情况：女生知道男生喜欢她，但是男生却不知道女生的意愿(女生自己是知道的)。不过，男生也并不是一点信息都没有，他知道女生喜欢他的概率为p。这样，收益矩阵就变成了：</p><p><img src="https://pic4.zhimg.com/80/v2-9e7cdf63811fd03b2963cbdaff8caa1f_720w.jpg" alt="img"></p><p>这样的话，如何计算纳什均衡呢？</p><p>如果Boy选择F，Girl在喜欢的状态下，F是最优反应，在不喜欢的状态下，B是最优反应。这个时候，如果F是Boy的最优反应，那么(F,(F,B))就构成纳什均衡了。</p><p>那么，F是不是Boy的最优反应？什么时候才是Boy的最优反应呢？这就要计算Boy选择F时候的期望收益。Boy如果选择F，有p的概率收益是2，有1-p的概率收益是0。因此，期望收益为： <img src="https://www.zhihu.com/equation?tex=+U_1%28F%2C%28F%2CB%29%29%3D2%2Ap%2B0%2A%281-p%29%3D2p+%5C%5C" alt="[公式]"> 在其他玩家策略不变的情况下，玩家收益最大的策略是最优反应。上面已经计算了Boy选择F的期望收益，现在要计算在女生策略不变的情况下，Boy选择策略B的收益： <img src="https://www.zhihu.com/equation?tex=+U_1%28B%2C%28F%2CB%29%29%3D0%2Ap%2B1%2A%281-p%29%3D1-p+%5C%5C" alt="[公式]"> 因此，当<img src="https://www.zhihu.com/equation?tex=2p%5Cge+1-p" alt="[公式]">也就是<img src="https://www.zhihu.com/equation?tex=p+%5Cge+1%2F3" alt="[公式]">时，<img src="https://www.zhihu.com/equation?tex=%28F%2C%28F%2CB%29%29" alt="[公式]">是纳什均衡。</p><p>同理，讨论Boy选B的情况，先计算女生的最优反应，再计算男生的最优反应，计算出p的范围是多少的时候，会有纳什均衡。结果是<img src="https://www.zhihu.com/equation?tex=p+%5Cge+2%2F3" alt="[公式]">时，<img src="https://www.zhihu.com/equation?tex=%28B%2C%28B%2CF%29%29" alt="[公式]">是纳什均衡。</p><h3 id="三、形式化：贝叶斯博弈-Bayesian-Games">三、形式化：贝叶斯博弈(Bayesian Games)</h3><p>策略式博弈<img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7BG%7D%3D%5Cleft%5C%7B%5Cboldsymbol%7BN%7D%2C%5Cleft%5C%7B%5Cboldsymbol%7BA%7D_%7B%5Cboldsymbol%7Bi%7D%7D%5Cright%5C%7D%2C%5Cleft%5C%7B%5Cboldsymbol%7B%5CTheta%7D_%7B%5Cboldsymbol%7Bi%7D%7D%5Cright%5C%7D%2C%5Cleft%5C%7B%5Cboldsymbol%7Bu%7D_%7B%5Cboldsymbol%7Bi%7D%7D%5Cright%5C%7D%2C+%5Cboldsymbol%7Bp%7D%5Cright%5C%7D" alt="[公式]">是贝叶斯博弈，其中：</p><ul><li><img src="https://www.zhihu.com/equation?tex=N" alt="[公式]">是<strong>玩家集</strong></li><li><img src="https://www.zhihu.com/equation?tex=A_i" alt="[公式]">是<strong>策略集</strong></li><li><img src="https://www.zhihu.com/equation?tex=%5CTheta_i" alt="[公式]">是<strong>状态集</strong>，表示每个人的私有的信息。给定状态，收益是确定的。</li><li><img src="https://www.zhihu.com/equation?tex=p%3Dp%28%5Ctheta_1%2C%5Cdots%2C%5Ctheta_N%29" alt="[公式]">表示在<img src="https://www.zhihu.com/equation?tex=%5Ctimes_%7Bi%3D1..n%7D%5CTheta_i" alt="[公式]">上的联合分布。</li><li>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的<strong>纯策略</strong><img src="https://www.zhihu.com/equation?tex=a_i%3A%5CTheta_i+%5Crightarrow+A_i" alt="[公式]">，表示在玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的<strong>所有状态下的策略选择</strong>。<img src="https://www.zhihu.com/equation?tex=a_%7Bi%7D%3D%5Cleft%28a_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5E%7B1%7D%5Cright%29%2C+a_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5E%7B2%7D%5Cright%29%2C+%5Cldots%2C+a_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5E%7Bn_%7Bi%7D%7D%5Cright%29%5Cright%29" alt="[公式]">，(假设有<img src="https://www.zhihu.com/equation?tex=n_i" alt="[公式]">种状态)</li><li><strong>收益函数</strong><img src="https://www.zhihu.com/equation?tex=u_%7Bi%7D%3A+%28%5Ctimes_%7Bi%3D1+.+.+N%7D+A_%7Bi%7D%29+%5Ctimes+%28%5Ctimes_%7Bi%3D1+.+.+n%7D+%5CTheta_%7Bi%7D%29+%5Crightarrow+R" alt="[公式]">。<img src="https://www.zhihu.com/equation?tex=u_%7Bi%7D%5Cleft%28a_%7B1%7D%2C+%5Cldots%2C+a_%7BN%7D%2C+%5Ctheta_%7B1%7D%2C+%5Cldots%2C+%5Ctheta_%7BN%7D%5Cright%29" alt="[公式]">表示在这些博弈结果和这些状态下的收益。</li></ul><p>这里面，需要仔细说说<img src="https://www.zhihu.com/equation?tex=%5CTheta_i" alt="[公式]">，它表示每个人的<strong>隐藏的状态</strong>信息，<strong>每个玩家知道自己的状态，但是不知道其他人的状态</strong>。如果所有人都只有一个状态，那么就是完全信息的。一般来说，我们研究<strong>状态独立</strong>的情形，每个人的状态都是独立的，也就是<img src="https://www.zhihu.com/equation?tex=p%5Cleft%28%5Ctheta_%7B1%7D%2C+%5Cldots%2C+%5Ctheta_%7BN%7D%5Cright%29%3Dp%5Cleft%28%5Ctheta_%7B1%7D%5Cright%29+p%5Cleft%28%5Ctheta_%7B2%7D%5Cright%29+%5Cldots+p%5Cleft%28%5Ctheta_%7BN%7D%5Cright%29" alt="[公式]">。</p><p>根据贝叶斯规则，有 <img src="https://www.zhihu.com/equation?tex=+p%5Cleft%28%5Ctheta_%7B-i%7D+%5Cmid+%5Ctheta_%7Bi%7D%5Cright%29%3D+%5Cfrac%7Bp%5Cleft%28%5Ctheta_%7Bi%7D%2C+%5Ctheta_%7B-i%7D%5Cright%29%7D%7B+p%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%7D+%5C%5C" alt="[公式]"> 其中<img src="https://www.zhihu.com/equation?tex=%5Ctheta_%7B-i%7D%3D%5Cleft%28%5Ctheta_%7B1%7D%2C+%5Cldots%2C+%5Ctheta_%7Bi-1%7D%2C+%5Ctheta_%7Bi%2B1%7D+%5Cldots%2C+%5Ctheta_%7BN%7D%5Cright%29" alt="[公式]"></p><p><strong>博弈结果</strong><img src="https://www.zhihu.com/equation?tex=%28a_1%2Ca_2%2C%5Cdots+%2Ca_N%29+%3D+%5Cleft%28%5Cleft%28a_%7B1%7D%5Cleft%28%5Ctheta_%7B1%7D%5E%7B1%7D%5Cright%29%2C+%5Cldots%2C+a_%7B1%7D%5Cleft%28%5Ctheta_%7B1%7D%5E%7Bn_%7B1%7D%7D%5Cright%29%5Cright%29%2C+%5Cldots%2C%5Cleft%28a_%7BN%7D%5Cleft%28%5Ctheta_%7BN%7D%5E%7B1%7D%5Cright%29%2C+%5Cldots%2C+a_%7BN%7D%5Cleft%28%5Ctheta_%7BN%7D%5E%7Bn_%7BN%7D%7D%5Cright%29%5Cright%29%5Cright%29" alt="[公式]"></p><p>给定<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D" alt="[公式]">，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的期望收益： <img src="https://www.zhihu.com/equation?tex=+U_%7Bi%7D%5Cleft%28a_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%2C+a_%7B-i%7D%5Cright%29%3D%5Csum_%7B%5Ctheta_%7B-i%7D%7D+p%5Cleft%28%5Ctheta_%7B-i%7D+%5Cmid+%5Ctheta_%7Bi%7D%5Cright%29+u_%7Bi%7D%5Cleft%28a_%7B-i%7D%5Cleft%28%5Ctheta_%7B-i%7D%5Cright%29%2C+a_%7Bi%7D%2C+%5Ctheta_%7B-i%7D%2C+%5Ctheta_%7Bi%7D%5Cright%29+%5C%5C" alt="[公式]"> 意思：在当前的状态<img src="https://www.zhihu.com/equation?tex=%5Ctheta_i" alt="[公式]">下，对手的某种状态的概率，乘以这种状态下他们的策略选择的收益，求和。</p><h3 id="四、贝叶斯纳什均衡">四、贝叶斯纳什均衡</h3><p>若<strong>博弈结果</strong><img src="https://www.zhihu.com/equation?tex=%28a_1%2Ca_2%2C%5Cdots+%2Ca_N%29" alt="[公式]">对于所有的<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=a_i%27%28%5Ctheta_i%29+%5Cin+A_i" alt="[公式]">，满足： <img src="https://www.zhihu.com/equation?tex=+U_%7Bi%7D%5Cleft%28a_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%2C+a_%7B-i%7D%5Cright%29+%5Cgeq+U_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%2C+a_%7B-i%7D%5Cright%29+%5C%5C" alt="[公式]"> 则称这个博弈结果是<strong>纳什均衡</strong>。</p><h3 id="最优反应函数">最优反应函数</h3><p>玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的在给定<img src="https://www.zhihu.com/equation?tex=a_%7B-i%7D" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=%5Ctheta_i" alt="[公式]">的最优反应为： <img src="https://www.zhihu.com/equation?tex=+B_%7Bi%7D%5Cleft%28a_%7B-i%7D%2C+%5Ctheta_%7Bi%7D%5Cright%29%3D%5Cleft%5C%7Ba_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%3A+U_%7Bi%7D%5Cleft%28a_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%2C+a_%7B-i%7D%5Cright%29%5Cright.+%5Cgeq+U_%7Bi%7D%5Cleft%28a_%7Bi%7D%5E%7B%5Cprime%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%2C+a_%7B-i%7D%5Cright%29+%5Ctext+%7B+for+all+%7D+%5Cleft.a_%7Bi%7D%5E%7B%5Cprime%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29%5Cright%5C%7D+%5C%5C" alt="[公式]"></p><h3 id="定理">定理</h3><p>博弈结果<img src="https://www.zhihu.com/equation?tex=%28a_1%2Ca_2%2C%5Cdots+%2Ca_N%29" alt="[公式]">是纳什均衡当且仅当对于每个<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=%5Ctheta_i" alt="[公式]">，都有<img src="https://www.zhihu.com/equation?tex=a_%7Bi%7D%5Cleft%28%5Ctheta_%7Bi%7D%5Cright%29+%5Cin+B_%7Bi%7D%5Cleft%28a_%7B-i%7D%2C+%5Ctheta_%7Bi%7D%5Cright%29" alt="[公式]"></p><h3 id="五、例子：古诺模型-非完全信息">五、例子：古诺模型(非完全信息)</h3><p>上面性别战是离散的例子，这里举一个古诺模型。</p><p>有两家公司生产同一种商品，这种商品的成本可能有两种：高价<img src="https://www.zhihu.com/equation?tex=c_H" alt="[公式]">和低价<img src="https://www.zhihu.com/equation?tex=c_L" alt="[公式]">，公司1的成本是<img src="https://www.zhihu.com/equation?tex=c_H" alt="[公式]">，这是众所周知的。然而公司1不知道公司2的成本是<img src="https://www.zhihu.com/equation?tex=c_H" alt="[公式]">还是<img src="https://www.zhihu.com/equation?tex=c_L" alt="[公式]">，它相信公司2成本是<img src="https://www.zhihu.com/equation?tex=c_H" alt="[公式]">的概率是<img src="https://www.zhihu.com/equation?tex=p" alt="[公式]">。市场上可以卖出的商品单价是(<img src="https://www.zhihu.com/equation?tex=a-" alt="[公式]">商品总产量)，现在两家公司需要决定各自的产量。</p><p>建模：</p><ul><li><img src="https://www.zhihu.com/equation?tex=N+%3D+%5C%7B1%2C2%5C%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=%5Ctheta_1+%3D+%5C%7Bc_H%5C%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%5Ctheta_2+%3D+%5C%7Bc_H%EF%BC%8Cc_L%5C%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=A_1%3D%5C%7Bq_1%3Aq_1+%5Cge+0%5C%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=A_2%3D%5C%7Bq_%7B2%2CH%7D%2Cq_%7B2%2CL%7D%3Aq_%7B2%2CH%7D+%5Cge+0%2C+q_%7B2%2CL%7D+%5Cge+0%5C%7D" alt="[公式]"></li><li>单价：<img src="https://www.zhihu.com/equation?tex=a-q_%7B1%7D-q_%7B2%2C+L%7D+" alt="[公式]">或<img src="https://www.zhihu.com/equation?tex=a-q_%7B1%7D-q_%7B2%2C+H%7D" alt="[公式]"></li></ul><p>求解纳什均衡：</p><p>对于公司1，求它的期望收益(公司1以p的概率相信公司2是<img src="https://www.zhihu.com/equation?tex=c_H" alt="[公式]">)： <img src="https://www.zhihu.com/equation?tex=+U_%7B1%7D%5Cleft%28q_%7B1%7D%2C+q_%7B2%2C+L%7D%2C+q_%7B2%2C+H%7D%2C+c_%7BL%7D%2C+c_%7BH%7D%5Cright%29%3Dp+q_%7B1%7D%5Cleft%28a-q_%7B1%7D-q_%7B2%2C+H%7D%5Cright%29%2B%281-p%29+q_%7B1%7D%5Cleft%28a-q_%7B1%7D-q_%7B2%2C+L%7D%5Cright%29-c_%7BH%7D+q_%7B1%7D+%5C%5C" alt="[公式]"> 对于公司2，如果它成本是<img src="https://www.zhihu.com/equation?tex=c_H" alt="[公式]">，则期望收益为： <img src="https://www.zhihu.com/equation?tex=+U_%7B2%7D%5Cleft%28q_%7B1%7D%2C+q_%7B2%2C+H%7D%2C+c_%7BH%7D%5Cright%29%3D%5Cleft%28a-q_%7B1%7D-q_%7B2%2C+H%7D%5Cright%29+q_%7B2%2C+H%7D-c_%7BH%7D+q_%7B2%2C+H%7D+%5C%5C" alt="[公式]"> 对于公司2，如果它成本是<img src="https://www.zhihu.com/equation?tex=c_L" alt="[公式]">，则期望收益为： <img src="https://www.zhihu.com/equation?tex=+U_%7B2%7D%5Cleft%28q_%7B1%7D%2C+q_%7B2%2C+L%7D%2C+c_%7BL%7D%5Cright%29%3D%5Cleft%28a-q_%7B1%7D-q_%7B2%2C+L%7D%5Cright%29+q_%7B2%2C+L%7D-c_%7BL%7D+q_%7B2%2C+L%7D+%5C%5C" alt="[公式]"> 用期望收益对产量求导等于零，得出收益的极大值点，也就是最优反应函数： <img src="https://www.zhihu.com/equation?tex=+B_%7B1%7D%5Cleft%28q_%7B2%2C+L%7D%2C+q_%7B2%2C+H%7D%5Cright%29%3D%5Cleft%5C%7B%5Cfrac%7Ba-p+q_%7B2%2C+H%7D-%281-p%29+q_%7B2%2C+L%7D-c_%7BH%7D%7D%7B2%7D%5Cright%5C%7D+%5C%5C" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=+B_%7B2%7D%5Cleft%28q_%7B1%7D%2C+c_%7BH%7D%5Cright%29%3D%5Cleft%5C%7B%5Cfrac%7Ba-q_%7B1%7D-c_%7BH%7D%7D%7B2%7D%5Cright%5C%7D+%5C%5C" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=+B_%7B2%7D%5Cleft%28q_%7B1%7D%2C+c_%7BL%7D%5Cright%29%3D%5Cleft%5C%7B%5Cfrac%7Ba-q_%7B1%7D-c_%7BL%7D%7D%7B2%7D%5Cright%5C%7D+%5C%5C" alt="[公式]"></p><p>求得纳什均衡<img src="https://www.zhihu.com/equation?tex=%28q_1%2C%28q_%7B2%2CL%7D%2Cq_%7B2%2CH%7D%29%29" alt="[公式]">： <img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Barray%7D%7Bc%7D+q_%7B1%7D%3D%5Cfrac%7Ba-c_%7BH%7D-%281-p%29%5Cleft%28c_%7BH%7D-c_%7BL%7D%5Cright%29%7D%7B3%7D+%5C%5C+q_%7B2%2C+%5Cmathrm%7BH%7D%7D%3D%5Cfrac%7Ba%7D%7B3%7D-%5Cfrac%7Bc_%7BH%7D%2Bc_%7BL%7D%7D%7B6%7D-p+%5Cfrac%7Bc_%7BH%7D-c_%7BL%7D%7D%7B6%7D+%5C%5C+q_%7B2%2C+L%7D%3D%5Cfrac%7Ba%7D%7B3%7D-%5Cfrac%7Bc_%7BL%7D%7D%7B3%7D-p+%5Cfrac%7Bc_%7BH%7D-c_%7BL%7D%7D%7B6%7D+%5Cend%7Barray%7D+%5C%5C" alt="[公式]"></p><h3 id="六、总结">六、总结</h3><p>这一节讲了非完全信息策略式博弈，主要是多了&quot;私有状态&quot;这一个概念。状态多的时候，纳什均衡很难求。</p><h1>博弈论笔记(七)：扩展式博弈(Extensive Game)</h1><blockquote><p>前面讲过了完全信息策略式博弈、非完全信息策略式博弈。<br>在策略式博弈中，所有玩家在同一时间做出决策。<br>扩展式博弈(Extensive Game)，也叫动态博弈。和策略式博弈最大的不同，就是玩家是轮流做决策的。</p></blockquote><p>例子：①尼姆游戏：有n枚硬币，两个玩家轮流取硬币，每次可以取1枚或两枚硬币，取到最后一枚硬币的人获胜。②下棋。</p><p>特点是：每一步没有收益，只有最后一步，才有收益(获胜)。扩展式博弈相较于策略式博弈，多了玩家的序列信息，以及每个点上的策略集</p><p>分类：完全信息扩展式博弈、非完全信息扩展式博弈。</p><h3 id="一、一个例子">一、一个例子</h3><p>谷歌想进入中国市场，百度可以选择“对立(F)”和“合作©”</p><p>这样可以画出一颗“博弈树”：</p><p><img src="https://pic3.zhimg.com/80/v2-d8f5f84fe6f44acf7007ea75cdd4814e_720w.jpg" alt="img"></p><h3 id="二、表示形式：博弈树">二、表示形式：博弈树</h3><p>博弈树由<strong>结点</strong>(node)和<strong>边</strong>(edge)组成，对应博弈玩家、策略和收益。</p><ol><li>结点：</li><li>非叶子结点：代表<strong>博弈玩家</strong>，表示这个时候哪个博弈玩家做出决策。每个非叶子结点有且仅有一个博弈玩家。</li><li>叶子结点：代表每个玩家在此时的<strong>收益</strong>。收益只存在于叶子结点。</li><li>边：表示<strong>策略</strong></li></ol><h3 id="三、扩展式博弈形式化定义">三、扩展式博弈形式化定义</h3><ol><li>玩家集N</li><li>策略集A：表示所有可能的策略。不过在一些结点上可能只有一部分可以选择的策略。</li><li>历史集H：“策略的序列”构成的集合，可以是有限集或者无限集。H中的元素称为<strong>历史</strong>(history)。性质：</li><li><ol><li><img src="https://www.zhihu.com/equation?tex=%5Cemptyset+%5Cin+H" alt="[公式]">，表示博弈树的根结点。</li><li>如果策略序列<img src="https://www.zhihu.com/equation?tex=a%5E1a%5E2%5Cdots+a%5Ek+%5Cin+H" alt="[公式]">且<img src="https://www.zhihu.com/equation?tex=s+%3C+k" alt="[公式]">，那么<img src="https://www.zhihu.com/equation?tex=a%5E1a%5E2%5Cdots+a%5Es+%5Cin+H" alt="[公式]"></li><li>如果无穷策略序列<img src="https://www.zhihu.com/equation?tex=%28a%5Ek%29_%7Bk%3D1%7D%5E%5Cinfty" alt="[公式]">满足对于任意的<img src="https://www.zhihu.com/equation?tex=k" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=a%5E1a%5E2%5Cdots+a%5Ek+%5Cin+H" alt="[公式]">，那么<img src="https://www.zhihu.com/equation?tex=%28a%5Ek%29_%7Bk%3D1%7D%5E%5Cinfty+%5Cin+H" alt="[公式]"></li><li><strong>每一条历史序列都对应博弈树的一个结点</strong>，对应历史序列末端到达的结点。</li><li>在完全信息扩展式博弈中，历史集大小=结点个数。</li><li>最终历史(Terminal history)：如果<img src="https://www.zhihu.com/equation?tex=a%5E1a%5E2%5Cdots+a%5Ek+%5Cin+H" alt="[公式]">且(<img src="https://www.zhihu.com/equation?tex=k+%3D+%2B%5Cinfty" alt="[公式]">或<img src="https://www.zhihu.com/equation?tex=a%5E1a%5E2%5Cdots+a%5E%7Bk%2B1%7D+%5Cnotin+H+%5C+for+%5C+any%5C+%5C+a%5E%7Bk%2B1%7D+%5Cin+A" alt="[公式]"></li><li>最终历史集(Terminal history set)：<strong>Z</strong> = {All Terminal history}，在这些结点上是<strong>收益</strong>。</li></ol></li><li>博弈玩家函数(Player Function)P：</li><li><ol><li><img src="https://www.zhihu.com/equation?tex=P+%3AH+%5Cbackslash+Z+%5Crightarrow+N" alt="[公式]">，给每一个非终结历史分配玩家集N中的一个元素。</li><li><img src="https://www.zhihu.com/equation?tex=P%28h%29" alt="[公式]">表示在历史h后，轮到哪个玩家做决策。</li></ol></li><li>收益函数(Payoff Function)<img src="https://www.zhihu.com/equation?tex=u_i%3AZ+%5Crightarrow+R" alt="[公式]">，表示第i个玩家的收益</li></ol><p>形式化：扩展式博弈G <img src="https://www.zhihu.com/equation?tex=+G%3D%5Cleft%5C%7BN%2C+H%2C+P%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D+%5C%5C" alt="[公式]"> (不需要策略集A，用上面四个就可以完全刻画一个扩展式博弈，因为策略都包含在历史里了)</p><h3 id="1-例子：最后通牒博弈">1. 例子：最后通牒博弈</h3><p><img src="https://pic3.zhimg.com/80/v2-43d14af4f7ffc305daac5d9fc4289be6_720w.jpg" alt="img"></p><p>由博弈树转化为扩展式博弈：</p><ul><li><img src="https://www.zhihu.com/equation?tex=G%3D%5Cleft%5C%7BN%2C+H%2C+P%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=N+%3D+%5C%7BA%2CB%5C%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=H+%3D+%5C%7B%5Cemptyset%2C%282.0%29%2C%281%2C1%29%2C%280%2C2%29%2C%28%282%2C0%2Cy%29%29%2C%28%282%2C0%29%2C+%5Cmathrm%7Bn%7D%29%2C%28%281%2C1%29%2C+%5Cmathrm%7By%7D%29%2C%28%281%2C1%29%2C+%5Cmathrm%7Bn%7D%29%2C+%28%280%2C2%29%2C+y%29%2C%28%280%2C2%29%2C+n%29+%5C%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=P%3A+P%28%5Cemptyset%29%3DA+%3B+P%28%282%2C0%29%29%3DB+%3B+P%28%281%2C1%29%29%3DB+%3B+P%28%280%2C2%29%29%3DB" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl%7D+++u_%7B1%7D%28%282%2C0%29%2C+y%29%3D2%2C+u_%7B1%7D%28%282%2C0%29%2C+n%29%3D0%2C%5C%5C+u_%7B1%7D%28%281%2C1%29%2C+y%29%3D1%2C+u_%7B1%7D%28%281%2C1%29%2C+n%29%3D0%2C%5C%5C+u_%7B1%7D%28%280%2C2%29%2C+y%29%3D0%2C+u_%7B1%7D%28%280%2C2%29%2C+n%29%3D0%2C+%5C%5C+++u_%7B2%7D%28%282%2C0%29%2C+y%29%3D0%2C+u_%7B2%7D%28%282%2C0%29%2C+n%29%3D0%2C+%5C%5Cu_%7B2%7D%28%281%2C1%29%2C+y%29%3D1%2C+u_%7B2%7D%28%281%2C1%29%2C+n%29%3D0%2C+%5C%5C+u_%7B2%7D%28%280%2C2%29%2C+y%29%3D2%2C+u_%7B2%7D%28%280%2C2%29%2C+n%29%3D0+++%5Cend%7Barray%7D" alt="[公式]"></li></ul><h3 id="2-例子：由扩展式博弈定义画出博弈树">2. 例子：由扩展式博弈定义画出博弈树</h3><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl%7D+G%3D%5Cleft%5C%7BN%2C+H%2C+P%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D+%5C%5C+N%3D%5C%7B1%2C2%5C%7D+%5C%5C+H%3D%5C%7B%5Cemptyset%2C+A%2C+B%2C+A+L%2C+A+R%5C%7D+%5C%5C+P%3A+P%28%5Cemptyset%29%3D1+%3B+P%28A%29%3D2+%5C%5C+u_%7B1%7D%28B%29%3D1%2C+u_%7B1%7D%28A+L%29%3D0%2C+u_%7B1%7D%28A+R%29%3D2+%5C%5C+u_%7B2%7D%28B%29%3D2%2C+u_%7B2%7D%28A+L%29%3D0%2C+u_%7B2%7D%28A+R%29%3D1+%5Cend%7Barray%7D" alt="[公式]"></p><p>画出博弈树：</p><p><img src="https://pic4.zhimg.com/80/v2-90564e20fdc05225e347743022b3c163_720w.jpg" alt="img"></p><h3 id="四、扩展式博弈的纯策略-Pure-strategies">四、扩展式博弈的纯策略(Pure strategies)</h3><p>给定<img src="https://www.zhihu.com/equation?tex=G%3D%5Cleft%5C%7BN%2C+H%2C+P%2C%5Cleft%5C%7Bu_%7Bi%7D%5Cright%5C%7D%5Cright%5C%7D" alt="[公式]">，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的<strong>纯策略的集合</strong>是： <img src="https://www.zhihu.com/equation?tex=+%5Ctimes_%7Bh+%5Cin+H%7D%5Cleft%5C%7Ba%5E%7Bs%7D%3A%5Cleft%28h%2C+a%5E%7Bs%7D%5Cright%29+%5Cin+H%2C+p%28h%29%3Di%5Cright%5C%7D+%5C%5C" alt="[公式]"> 通俗地说，就是玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的结点上的策略集的笛卡尔积。</p><h3 id="例子：最后通牒博弈">例子：最后通牒博弈</h3><p><img src="https://pic2.zhimg.com/80/v2-95b8fc94733214175416d770a7034905_720w.jpg" alt="img"></p><ul><li>玩家A的纯策略：<img src="https://www.zhihu.com/equation?tex=%5C%7B%282%2C0%29%2C%281%2C1%29%2C%280%2C2%29%5C%7D" alt="[公式]"></li><li>玩家B的纯策略：<img src="https://www.zhihu.com/equation?tex=%5C%7B+yyy%2C+yyn%2C+yny+%2C+ynn%2C+nyy%2C+nyn+%2C+nny+%2C+nnn+%5C%7D" alt="[公式]"></li></ul><h3 id="例子：">例子：</h3><p><img src="https://pic3.zhimg.com/80/v2-382c0aa5a1e653bf535ed68c0cd5688e_720w.jpg" alt="img"></p><ul><li>玩家1：<img src="https://www.zhihu.com/equation?tex=%5C%7BA%2CB%5C%7D+%5Ctimes+%5C%7BG%2C+H%5C%7D" alt="[公式]"></li><li>玩家2：<img src="https://www.zhihu.com/equation?tex=%5C%7BC%2CD%5C%7D+%5Ctimes+%5C%7BE%2C+F%5C%7D" alt="[公式]"></li></ul><p>虽然AG这种纯策略是“不可能”的，因为它们不可能出现在一个历史中，但是这是纯策略的定义。</p><h3 id="五、纳什均衡">五、纳什均衡</h3><p>有了纯策略，就可以定义：混合策略、最优反应、纳什均衡。</p><p>和策略式博弈纳什均衡的定义是一样的。</p><p>如何求解纳什均衡：<strong>诱导策略式博弈</strong></p><p>扩展式博弈可以转化为策略式博弈，根据每个玩家纯策略的组合，会出现相应的收益，写出<strong>诱导收益矩阵</strong>。</p><p><img src="https://pic4.zhimg.com/80/v2-3b020520301bec811236330c4b9366c7_720w.jpg" alt="img"></p><p>可以转化为：</p><p><img src="https://pic2.zhimg.com/80/v2-e1a0d8d6e7abed0f1491cd4b942e7b11_720w.jpg" alt="img"></p><p>转化不可逆。</p><p>根据诱导收益矩阵，就可以找到纳什均衡：(BH, CE)，(AG, CF)，(AH, CF)</p><p>但是，<strong>纳什均衡有些策略是不可信的</strong>，比如：(AH, CF)是纳什均衡，但A怎么会选择H策略呢？正常一定选G呀。所以，为了避免这些不可信的纳什均衡，需要找出另一种均衡，试所有均衡都是可信的，这就是子博弈完美均衡。</p><h3 id="Kuhn-Theorem">Kuhn Theorem</h3><p>每一个具有完全信息的有限扩展式博弈至少有一个<strong>纯策略纳什均衡</strong>(PSNE)</p><h3 id="六、子博弈">六、子博弈</h3><p>博弈树的子树，从一个结点开始的所有子结点。</p><h3 id="七、子博弈完美纳什均衡-Subgame-Perfect-Equilibrium">七、子博弈完美纳什均衡(Subgame Perfect Equilibrium)</h3><p>如果<img src="https://www.zhihu.com/equation?tex=a%3D%5Cleft%28a_%7B1%7D%5E%7B%2A%7D%2C+a_%7B2%7D%5E%7B%2A%7D%2C+%5Cldots%2C+a_%7BN%7D%5E%7B%2A%7D%5Cright%29" alt="[公式]">在每个子博弈都是纳什均衡，那么它就是子博弈完美均衡</p><h3 id="定理-2">定理</h3><p>每一个完全信息扩展式博弈都有子博弈完美均衡。</p><p>如何求解子博弈完美均衡？是用后向归纳的方式，从树的叶子端开始，不断剪枝，最终到根节点。具体过程请看<strong>下节笔记</strong>。</p><h3 id="八、小结">八、小结</h3><p>这节主要介绍了扩展式博弈的概念、形式化以及纳什均衡。这些都是扩展式博弈的基础的部分。</p><h1>博弈论笔记(八)：求解子博弈完美均衡——单步偏移，后向归纳</h1><h3 id="一、目标">一、目标</h3><p>本节课探究两个目标：</p><ol><li>子博弈完美均衡(SPE)是否存在？</li><li>如何找到SPE？</li></ol><p>先给出结论：</p><ol><li>有限的完全信息扩展式博弈，存在SPE</li><li>计算：后向归纳</li></ol><h3 id="二、寻找SPE-–-后向归纳">二、寻找SPE – 后向归纳</h3><h3 id="1-步骤">1. 步骤</h3><ol><li>从最末端的非叶子结点开始(从最后的子博弈开始)，计算NE(此时对于这个非叶子结点的玩家，相当于寻找他的最优收益)。用这个收益，替代这个子博弈根结点。</li><li>重复第1步，直到根节点</li></ol><p>通过逆向归纳构造的策略博弈集等价于SPE的集合</p><h3 id="2-例子-唯一的SPE">2. 例子(唯一的SPE)</h3><blockquote><p>叶子结点上的收益表示：(1的收益，2的收益)</p></blockquote><p>红色的勾表示选择这个分支。从下往上推，每个人选择自己收益较高的分支。</p><p><img src="https://pic2.zhimg.com/80/v2-7bf2f470277febf5bb3d73f3ce319ad9_720w.jpg" alt="img"></p><p>得到SPE：(AG, CF)</p><h3 id="3-例子-不唯一的SPE">3. 例子(不唯一的SPE)</h3><p><img src="https://pic2.zhimg.com/80/v2-e3d68095705ce4c646695b309c6fc225_720w.jpg" alt="img"></p><p><em>在最高收益相等的时候，根据纳什均衡的定义，这些收益最高的都是纳什均衡。</em></p><p>玩家2会选择的纯策略可能有4种：FHK、FIK、GHK、GIK。当玩家2选择<code>FHK</code>的时候，玩家1在三个分支上的收益分别是：3, 1, 1。因此，玩家1会选择C，得到一个SPE：(C, FHK)。</p><p>同理得到所有的SPE：(C, FHK)、(C, FIK)、(C, GHK)、(D, GHK)、(E, GHK)、(D, GIK)</p><h3 id="4-例子-蜈蚣博弈">4. 例子(蜈蚣博弈)</h3><p><img src="https://pic3.zhimg.com/80/v2-561e473bbcd03f1250415688fdced016_720w.jpg" alt="img"></p><p>SPE：(DDD, DD)。收益：(1. 0)，收益并不理想。</p><h3 id="三、形式化之路">三、形式化之路</h3><blockquote><p>如果只是想知道如何求解，形式化似乎不重要。但是如果想严谨地建模，那就必须形式化了。</p></blockquote><h3 id="1-一些符号记法">1. 一些符号记法</h3><ul><li>初始历史：<img src="https://www.zhihu.com/equation?tex=A%28h%29+%3D+%5C%7Ba+%3A+%28h%2Ca%29%5Cin+H+%5C%7D" alt="[公式]">，表示在结点 <img src="https://www.zhihu.com/equation?tex=h" alt="[公式]"> 的策略集。(不要忘了历史<img src="https://www.zhihu.com/equation?tex=h" alt="[公式]">和结点一一对应)</li><li>博弈G的长度：<img src="https://www.zhihu.com/equation?tex=%5Cell%28G%29%3D%5Cmax+_%7Bh+%5Cin+H%7D%5C%7B%7Ch%7C%5C%7D" alt="[公式]">，和树高相同。</li><li><img src="https://www.zhihu.com/equation?tex=s_i" alt="[公式]">：玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的某个纯策略</li><li><img src="https://www.zhihu.com/equation?tex=s_i%28h%29+%3D+a" alt="[公式]">：<img src="https://www.zhihu.com/equation?tex=a+%5Cin+A%28h%29" alt="[公式]"> and <img src="https://www.zhihu.com/equation?tex=a+%5Cin+s_i" alt="[公式]">。(表示在结点<img src="https://www.zhihu.com/equation?tex=h" alt="[公式]">上，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的选择是<img src="https://www.zhihu.com/equation?tex=a" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=s_i%28h%29+%3D++A%28h%29+%5Ccap++s_i" alt="[公式]">。)</li></ul><h3 id="举例">举例</h3><p><img src="https://pic4.zhimg.com/80/v2-b7a0d13f1473f2a1ae91b6ed0a819493_720w.jpg" alt="img"></p><ul><li><img src="https://www.zhihu.com/equation?tex=%5Cell%28G%29+%3D+3" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=A%28BF%29+%3D+%5C%7BG%2CH%5C%7D" alt="[公式]"></li><li>设纯策略<img src="https://www.zhihu.com/equation?tex=s_1%3D%28AG%29" alt="[公式]">，那么<img src="https://www.zhihu.com/equation?tex=s_1%28BF%29%3DG" alt="[公式]">，(在结点BF上，玩家1的选择是G)</li></ul><h3 id="2-定义：有限博弈">2. 定义：有限博弈</h3><p>博弈G的长度<img src="https://www.zhihu.com/equation?tex=%5Cell%28G%29" alt="[公式]">有限。</p><h3 id="3-定义：子博弈">3. 定义：子博弈</h3><p>给定<img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7BN%2CH%2CP%2C%5C%7Bu_i%5C%7D%5C%7D" alt="[公式]">，结点h的子博弈定义为：<img src="https://www.zhihu.com/equation?tex=G%28h%29%3D%5C%7BN%2C%5Cleft.H%5Cright%7C_%7Bh%7D%2C%5Cleft.P%5Cright%7C_%7Bh%7D%2C%5C%7B%5Cleft.u_%7Bi%7D%5Cright%7C_%7Bh%7D%5C%7D%5C%7D" alt="[公式]">，其中：</p><ul><li><img src="https://www.zhihu.com/equation?tex=H%7C_%7Bh%7D" alt="[公式]">：<img src="https://www.zhihu.com/equation?tex=%5C%7Bh%5E%7B%5Cprime%7D%3A+s.t.+%5Cleft%28h%2C+h%5E%7B%5Cprime%7D%5Cright%29+%5Cin+H%5C%7D" alt="[公式]">，子博弈的历史集</li><li><img src="https://www.zhihu.com/equation?tex=P%7C_%7Bh%7D%28h%27%29+%3D+P%28h%2Ch%27%29" alt="[公式]">：子博弈中，结点<img src="https://www.zhihu.com/equation?tex=h%27" alt="[公式]">上的玩家</li><li><img src="https://www.zhihu.com/equation?tex=%5Cleft.u_%7Bi%7D%5Cright%7C_%7Bh%7D%5Cleft%28h%5E%7B%5Cprime%7D%5Cright%29%3Du_%7Bi%7D%5Cleft%28h%2C+h%5E%7B%5Cprime%7D%5Cright%29" alt="[公式]">，子博弈玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">在历史<img src="https://www.zhihu.com/equation?tex=h%27" alt="[公式]">的的收益</li></ul><p>其他记号：</p><ul><li><img src="https://www.zhihu.com/equation?tex=s_i%7C_h" alt="[公式]">子博弈中玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的纯策略</li><li><img src="https://www.zhihu.com/equation?tex=%5Cleft.s_%7Bi%7D%5Cright%7C_%7Bh%7D%5Cleft%28h%5E%7B%5Cprime%7D%5Cright%29%3Ds_%7Bi%7D%5Cleft%28h%2C+h%5E%7B%5Cprime%7D%5Cright%29" alt="[公式]">，子博弈中，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">在结点<img src="https://www.zhihu.com/equation?tex=h%27" alt="[公式]">的策略选择。</li></ul><h3 id="4-定义：子博弈完美均衡-Subgame-Perfect-Equilibrium">4. 定义：子博弈完美均衡(Subgame Perfect Equilibrium)</h3><p>对于有限博弈<img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7BN%2CH%2CP%2C%5C%7Bu_i%5C%7D%5C%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=s%5E%2A+%3D+%5Cleft%28s_%7B1%7D%5E%7B%2A%7D%2C+s_%7B2%7D%5E%7B%2A%7D%2C+%5Cldots%2C+s_%7BN%7D%5E%7B%2A%7D%5Cright%29" alt="[公式]">是子博弈完美均衡(subgame perfect equilibrium)，当且仅当： <img src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Barray%7D%7Bl%7D+%5Cforall+i+%5Cin+N%2C+%5Cforall+h+%5Cin+H+%5Cbackslash+%5Cmathrm%7BZ%7D+%5Ctext+%7B+s.t.+%7D+%5Cmathrm%7BP%7D%28h%29%3Di+%5C%5C+%5Cleft.u_%7Bi%7D%5Cright%7C_%7Bh%7D%5Cleft%28%5Cleft.s_%7Bi%7D%5E%7B%2A%7D%5Cright%7C_%7Bh%7D%2C%5Cleft.s_%7B-i%7D%5E%7B%2A%7D%5Cright%7C_%7Bh%7D%5Cright%29+%5Cgeq%5Cleft.+u_%7Bi%7D%5Cright%7C_%7Bh%7D%5Cleft%28s_%7Bi%7D%2C%5Cleft.s_%7B-i%7D%5E%7B%2A%7D%5Cright%7C_%7Bh%7D%5Cright%29+%5C%5Cfor%5C+every%5C+s_i%5C+in%5C+G%28h%29+%5Cend%7Barray%7D+%5C%5C" alt="[公式]"> 解释：对于所有子博弈(设根结点是<img src="https://www.zhihu.com/equation?tex=h" alt="[公式]">，根结点上的玩家是<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">)，在子博弈中，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的这种纯策略选择得到的收益，<strong>高于其他的纯策略</strong>。</p><h3 id="5-单步偏离原则">5. 单步偏离原则</h3><p>对于所有子博弈(设子博弈根结点是<img src="https://www.zhihu.com/equation?tex=h" alt="[公式]">，根结点上的玩家是<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">)，在子博弈中，玩家<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">的这种纯策略(记为<img src="https://www.zhihu.com/equation?tex=s_i%5E%2A" alt="[公式]">)选择得到的收益，<strong>不低于那些仅和<img src="https://www.zhihu.com/equation?tex=s_i%5E%2A" alt="[公式]">在<img src="https://www.zhihu.com/equation?tex=A%28h%29" alt="[公式]">上不同的纯策略</strong>。(也就是只考虑子博弈根节点的策略选择不同)</p><h3 id="举例-2">举例</h3><p><img src="https://pic4.zhimg.com/80/v2-a7c2edcc9fccfcbed76f1f1d04f9b007_720w.jpg" alt="img"></p><p>在检验(AHI, CE)是不是SPE的时候，检验根节点的时候，只需比较(AHI, CE)和(BHI, CE)的收益，不需要改变HI, CE。</p><h3 id="6-注意">6. 注意</h3><p>单步偏离原则不适用于<strong>无限博弈</strong></p><p><img src="https://pic1.zhimg.com/80/v2-bcb62b19f9c86fd8eddf59e9d4ba8bb8_720w.jpg" alt="img"></p><p>策略DDD……满足单步偏离原则，因为偏离一步之后，收益并没有增加，但是AAA……才是SPE。</p><h3 id="7-库恩定理">7. 库恩定理</h3><p>每一个具有完全信息的<strong>有限</strong>扩展式博弈都有子博弈完美均衡。</p><h3 id="四、应用">四、应用</h3><p>这两道算习题吧。</p><h3 id="1-古诺竞争–主从博弈">1. 古诺竞争–主从博弈</h3><p>古诺竞争已经出现过很多次了，这里再写一下题目：</p><blockquote><p>两个厂商{1, 2}生产和销售同一种商品，厂商<img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">生产的数量记为<img src="https://www.zhihu.com/equation?tex=q_i" alt="[公式]">。每件商品生产成本都是c，售价是：<img src="https://www.zhihu.com/equation?tex=max%280%2Ca-b%28q_1%2Bq_2%29%29" alt="[公式]"></p></blockquote><p>和之前不同的是，这次<strong>厂商1先决定产量，然后厂商2再决定产量</strong>。这就变成了扩展式博弈。求子博弈完美均衡。</p><p>求解方法：先求厂商2的最优反应，用<img src="https://www.zhihu.com/equation?tex=q_1" alt="[公式]">表示，然后在求<img src="https://www.zhihu.com/equation?tex=q_1" alt="[公式]">的最优反应的时候，把<img src="https://www.zhihu.com/equation?tex=q_2" alt="[公式]">代入，最优反应函数中就只有<img src="https://www.zhihu.com/equation?tex=q_1" alt="[公式]">这个变量了，然后求极值点，就求出了子博弈完美均衡时的<img src="https://www.zhihu.com/equation?tex=q_1" alt="[公式]">，再代回求出<img src="https://www.zhihu.com/equation?tex=q_2" alt="[公式]">。</p><h3 id="2-最后通牒博弈">2. 最后通牒博弈</h3><p>两人分资产，第一个人选择分给自己的比例<img src="https://www.zhihu.com/equation?tex=x+%5Cin+%5B0%2C1%5D" alt="[公式]">。第二个人决定是否同意这种分法。如果同意，二人的收益为<img src="https://www.zhihu.com/equation?tex=%28x%2C1-x%29" alt="[公式]">，如果不同意，二人的收益为<img src="https://www.zhihu.com/equation?tex=%280%2C0%29" alt="[公式]">，求子博弈完美均衡。</p><h1>博弈论笔记(九)：二人零和博弈</h1><h2 id="一、形式化定义">一、形式化定义</h2><p>二人零和博弈是一个策略式博弈<img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7B%5C%7B1%2C2%5C%7D%2C%5C%7BA_1%2CA_2%5C%7D%2C%5C%7Bu_1%2Cu_2%5C%7D%5C%7D" alt="[公式]">使得对于任意<img src="https://www.zhihu.com/equation?tex=a_1%5Cin+A_1" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=a_2%5Cin+A_2" alt="[公式]">，都有<img src="https://www.zhihu.com/equation?tex=u_1%28a_1%2Ca_2%29%2Bu_2%28a_1%2Ca_2%29%3D0" alt="[公式]"></p><p>用语言描述就是：在任何的博弈结果上，两个玩家的收益和都是0。</p><p>例子：石头剪刀布，赢的+1分，输的-1分，平局得0分。</p><p>可以发现，当一个玩家在一种结果的收益是<img src="https://www.zhihu.com/equation?tex=x" alt="[公式]">的时候，另一个玩家的收益一定是<img src="https://www.zhihu.com/equation?tex=-x" alt="[公式]">，因此，无需记录两个玩家的收益，只需要记录一个玩家的收益即可。<strong>我们按惯例在收益矩阵中保留玩家一的收益。</strong> 这个收益矩阵记为<strong>u</strong></p><p><strong>u</strong> 举例如下：</p><p><img src="https://pic4.zhimg.com/80/v2-14049b24606fdf3af670e320935e354f_720w.jpg" alt="img">用玩家一的收益表示</p><p>用之前所学的，寻找最优反应，可以求解二人零和博弈，但是这节讲一种更简单，复杂度更低的求解方法。</p><h2 id="二、最大化最小原则-Maxmin"><strong>二、最大化最小原则(Maxmin)</strong></h2><blockquote><p>二人零和博弈也是策略式博弈，当然可以用以前的方法来求解纳什均衡。不过，有了零和的约束，换一种方法去思考会使得求解更为简便。</p></blockquote><p>可以先用策略式博弈的想法开始考虑：</p><p>当玩家1固定一个策略<img src="https://www.zhihu.com/equation?tex=a_1" alt="[公式]">时，玩家2会选择对它收益最高的那个策略<img src="https://www.zhihu.com/equation?tex=a_2" alt="[公式]">，也就是：</p><p>对于玩家1，应该采用这样的方法：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax_%7Ba_1+%5Cin+A_1%7D+%5Cmax_%7Ba_2+%5Cin+A_2%7D+u_2%28a_1%2C+a_2%29+%5C%5C" alt="[公式]"></p><p>把收益矩阵都转化为<img src="https://www.zhihu.com/equation?tex=u" alt="[公式]">的形式：<img src="https://www.zhihu.com/equation?tex=u_1%3Du%2C+u_2+%3D+-u" alt="[公式]"></p><p>对于玩家一，对每个策略计算最少收益，然后在这些最小值中取最大的。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax_%7Ba_1+%5Cin+A_1%7D+%5Cmin_%7Ba_2+%5Cin+A_2%7D+u%28a_1%2C+a_2%29+%5C%5C" alt="[公式]"></p><p>玩家二收益：</p><p><img src="https://www.zhihu.com/equation?tex=-%5Cmin_%7Ba_2+%5Cin+A_2%7D+%5Cmax_%7Ba_1+%5Cin+A_1%7D+u%28a_1%2C+a_2%29+%5C%5C" alt="[公式]"></p><p>前面的负号不影响策略的取值</p><h2 id="三、例子"><strong>三、例子</strong></h2><p><img src="https://pic2.zhimg.com/80/v2-5198803be67f8a5c9c7c9f71e2359259_720w.jpg" alt="img"></p><h2 id="四、二人零和博弈纳什均衡"><strong>四、二人零和博弈纳什均衡</strong></h2><p>定理：对于有限二人零和博弈<img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7B%5C%7B1%2C2%5C%7D%2C+%5C%7BA_1%2C+A_2%5C%7D%2C+u%5C%7D" alt="[公式]">，玩家1选择策略：</p><p><img src="https://www.zhihu.com/equation?tex=a_1%5E%2A+%5Cin+%5Cmathop%7B%5Carg%5Cmax%7D_%7Ba_1+%5Cin+A_1%7D+%5Cmin_%7Ba_2+%5Cin+A_2%7D+u%28a_1%2C+a_2%29+%5C%5C" alt="[公式]"></p><p>玩家2选择策略：</p><p><img src="https://www.zhihu.com/equation?tex=a_2%5E%2A+%5Cin+%5Cmathop%7B%5Carg%5Cmin%7D_%7Ba_2+%5Cin+A_2%7D+%5Cmax_%7Ba_1+%5Cin+A_1%7D+u%28a_1%2C+a_2%29+%5C%5C" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%28a_1%5E%2A%2C+a_2%5E%2A%29" alt="[公式]">构成一个纳什均衡 当且仅当</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax_%7Ba_1+%5Cin+A_1%7D+%5Cmin_%7Ba_2+%5Cin+A_2%7D+u%28a_1%2C+a_2%29+%3D+%5Cmin_%7Ba_2+%5Cin+A_2%7D+%5Cmax_%7Ba_1+%5Cin+A_1%7D+u%28a_1%2C+a_2%29+%5C%5C" alt="[公式]"></p><h2 id="五、混合策略博弈"><strong>五、混合策略博弈</strong></h2><h3 id="1-形式化定义"><strong>1. 形式化定义</strong></h3><p><img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7B%5C%7B1%2C2%5C%7D%2C%5C%7BA_1%2CA_2%5C%7D%2CM%5C%7D" alt="[公式]">，其中：</p><ul><li><img src="https://www.zhihu.com/equation?tex=A_1+%3D+%5C%7Ba_1%2Ca_2%2C...%2Ca_m%5C%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=A_2+%3D+%5C%7Bb_1%2Cb_2%2C...%2Cb_n%5C%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=u_%7Bij%7D+%3D+u_1%28a_i%2Cb_j%29+%3D+u%28a_i%2Cb_j%29" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=M+%3D+%28u_%7Bij%7D%29_%7Bm%5Ctimes+n%7D" alt="[公式]"></li><li><img src="https://www.zhihu.com/equation?tex=p+%3D+%28p_1%2Cp_2%2C...%2Cp_m%29+%5Cin+%5CDelta_1" alt="[公式]">是在<img src="https://www.zhihu.com/equation?tex=A_1" alt="[公式]">上的混合策略(<img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="[公式]">表示纯策略上的概率分布)</li><li><img src="https://www.zhihu.com/equation?tex=q+%3D+%28q_1%2Cq_2%2C...%2Cq_n%29+%5Cin+%5CDelta_2" alt="[公式]">是在<img src="https://www.zhihu.com/equation?tex=A_2" alt="[公式]">上的混合策略(<img src="https://www.zhihu.com/equation?tex=%5CDelta" alt="[公式]">表示纯策略上的概率分布)</li><li><strong>博弈结果</strong>：<img src="https://www.zhihu.com/equation?tex=%28p%2Cq%29" alt="[公式]"></li><li>玩家1的<strong>期望</strong>收益：<img src="https://www.zhihu.com/equation?tex=U%28p%2C+q%29%3D%5Csum_%7Bi%2C+j%7D+p_%7Bi%7D+q_%7Bj%7D+u%5Cleft%28a_%7Bi%7D%2C+b_%7Bj%7D%5Cright%29%3D%5Csum_%7Bi%2C+j%7D+p_%7Bi%7D+q_%7Bj%7D+u_%7Bi+j%7D%3Dp+M+q%5E%7B%5Ctop%7D" alt="[公式]">，(p,q是行向量)</li></ul><h3 id="2-MinMax-and-MaxMin"><strong>2. MinMax and MaxMin</strong></h3><p>类比纯策略，得到</p><p>玩家1的选择：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+U%28p%2C+q%29%3D%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+p+M+q%5E%7B%5Ctop%7D+%5C%5C" alt="[公式]"></p><p>玩家2的选择：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+U%28p%2C+q%29%3D%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+p+M+q%5E%7B%5Ctop%7D+%5C%5C" alt="[公式]"></p><h3 id="引理：max-min-公式-min-max"><strong>引理：max min</strong> <img src="https://www.zhihu.com/equation?tex=%5Cle" alt="[公式]"> <strong>min max</strong></h3><p><img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+U%28p%2C+q%29+%5Cle+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+U%28p%2C+q%29+%5C%5C" alt="[公式]"></p><h3 id="二人零和博弈混合策略纳什均衡"><strong>二人零和博弈混合策略纳什均衡</strong></h3><p>定理：对于有限二人零和博弈<img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7B%5C%7B1%2C2%5C%7D%2C+%5C%7BA_1%2C+A_2%5C%7D%2C+u%5C%7D" alt="[公式]">，玩家1选择策略：</p><p><img src="https://www.zhihu.com/equation?tex=p%5E%2A+%5Cin+%5Cmathop%7B%5Carg%5Cmax%7D_%7Bp+%5Cin+%5CDelta_1%7D+%5Cmin_%7Bq+%5Cin+%5CDelta_2%7D+U%28p%2C+q%29+%5C%5C" alt="[公式]"></p><p>玩家2选择策略：</p><p><img src="https://www.zhihu.com/equation?tex=q%5E%2A+%5Cin+%5Cmathop%7B%5Carg%5Cmin%7D_%7Bq+%5Cin+%5CDelta_2%7D+%5Cmax_%7Bp+%5Cin+%5CDelta_1%7D+U%28p%2C+q%29+%5C%5C" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%28p%5E%2A%2C+q%5E%2A%29" alt="[公式]">构成一个混合策略纳什均衡 <strong>当且仅当</strong></p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+U%28p%2C+q%29%3D%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+U%28p%2C+q%29+%5C%5C" alt="[公式]"></p><h3 id="冯诺依曼最大化最小定理-John-von-Neumann’s-Minimax-Theorem"><strong>冯诺依曼最大化最小定理(John von Neumann’s Minimax Theorem)</strong></h3><p>上面讲了混合策略那是均衡的充要条件，那么混合均衡是否一定存在呢？怎样找到呢？<strong>冯诺依曼最大化最小定理</strong>给就要给出这两个问题的答案。</p><h3 id="定理："><strong>定理：</strong></h3><p>对于有限二人零和博弈<img src="https://www.zhihu.com/equation?tex=G+%3D+%5C%7B%5C%7B1%2C2%5C%7D%2C+%5C%7BA_1%2C+A_2%5C%7D%2C+M%5C%7D" alt="[公式]">，一定有：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+p+M+q%5E%7B%5Ctop%7D%3D%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+p+M+q%5E%7B%5Ctop%7D+%5C%5C" alt="[公式]"></p><p>即：<strong>混合策略纳什均衡一定存在</strong></p><p>推论：二人有限零和博弈至少存在一种混合策略纳什均衡：任何一对最优策略都是纳什均衡。</p><p>证明：略</p><blockquote><p>根据之前几节学习的，策略式博弈的混合策略纳什均衡一定是存在的，不过那是后来Nash提出来的，运用了更高级的数学工具(不动点定理等)，而最大化最小定理是在之前几十年提出的，没有相应的数学工具，所以只能是对二人零和博弈的证明。<br>在求解上，之前的混合策略纳什均衡求解是NP-Hard问题，而最大化最小定理的求解是一个多项式时间可以求出的。</p></blockquote><h3 id="求解MNE"><strong>求解MNE</strong></h3><p>既然一定存在MNE，那么直接求解最优化问题<img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+p+M+q%5E%7B%5Ctop%7D" alt="[公式]">或者<img src="https://www.zhihu.com/equation?tex=%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+p+M+q%5E%7B%5Ctop%7D" alt="[公式]">就可以求出MNE的解。</p><p>求解：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+p+M+q%5E%7B%5Ctop%7D+%5C%5C" alt="[公式]"></p><p>令 <img src="https://www.zhihu.com/equation?tex=v+%3D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+p+M+q%5E%7B%5Ctop%7D" alt="[公式]">，求解 <img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7Dv" alt="[公式]">。 <img src="https://www.zhihu.com/equation?tex=pM" alt="[公式]"> 是一个固定的<strong>行向量</strong>， <img src="https://www.zhihu.com/equation?tex=q" alt="[公式]"> 是一个<strong>概率分布</strong>，因此，<img src="https://www.zhihu.com/equation?tex=p+M+q%5E%7B%5Ctop%7D" alt="[公式]">的最小值就是<img src="https://www.zhihu.com/equation?tex=pM" alt="[公式]">向量中最小的那个数。因此：</p><p>求解<img src="https://www.zhihu.com/equation?tex=%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+p+M+q%5E%7B%5Ctop%7D" alt="[公式]">等价于求解<strong>线性规划问题</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax+v+%5C%5C+%5C%5C" alt="[公式]"></p><p>s.t.</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bc%7D+p+M+%5Cgeq+v+%5Cmathbf%7B1%7D+%5C%5C+p%3D%5Cleft%28p_%7B1%7D%2C+%5Cldots%2C+p_%7Bm%7D%5Cright%29+%5Cin+%5CDelta_%7B1%7D+%5C%5C+%5Cmathbf%7B1%7D%3D%281%2C+%5Cldots%2C+1%29%5E%7B%5Ctop%7D+%5Cend%7Barray%7D+%5C%5C" alt="[公式]"></p><p>求解<img src="https://www.zhihu.com/equation?tex=%5Cmin+_%7Bq+%5Cin+%5CDelta_%7B2%7D%7D+%5Cmax+_%7Bp+%5Cin+%5CDelta_%7B1%7D%7D+p+M+q%5E%7B%5Ctop%7D" alt="[公式]">等价于求解线性规划问题：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmin+v+%5C%5C" alt="[公式]"></p><p>s.t</p><p><img src="https://www.zhihu.com/equation?tex=M+q%5E%7B%5Ctop%7D+%5Cgeq+v+%5Cmathbf%7B1%7D+%5C%5C+q%3D%5Cleft%28q_%7B1%7D%2C+%5Cldots%2C+q_%7Bn%7D%5Cright%29+%5Cin+%5CDelta_%7B2%7D+%5C%5C+%5Cmathbf%7B1%7D%3D%281%2C+%5Cldots%2C+1%29%5E%7B%5Ctop%7D+%5C%5C+%5C%5C" alt="[公式]"></p><h2 id="六、总结-2">六、总结</h2><p>二人零和博弈是策略式博弈的一种特殊情况，普通的混合策略博弈求解难度随着博弈策略呈指数级增加，而二人零和博弈有高效的求解方法，是一个线性规划问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="/2022/09/08/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2022/09/08/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1>Decision Tree（决策树）</h1><p>决策树是一种简单但广泛使用的分类器，它通过训练数据构建决策树，对未知的数据进行分类。决策树的每个内部节点表示在一个属性上的测试，每个分枝代表该测试的一个输出，而每个树叶结点存放着一个类标号。<br>在决策树算法中。</p><ul><li>ID3基于信息增益作为属性选择的度量，</li><li>C4.5基于信息增益比作为属性选择的度量，</li><li>CART基于基尼指数作为属性选择的度量。</li></ul><h2 id="决策树的优缺点">决策树的优缺点</h2><ul><li>优点<br>1、不需要任何领域知识或参数假设<br>2、适合高维数据。<br>3、简单易于理解。<br>4、短时间内处理大量数据，得到可行且效果较好的结果。<br>5、使用可视化模型。</li><li>缺点<br>1、对于各类别样本数量不一致数据，信息增益偏向于那些具有更多数值的特征。<br>2、易于过拟合。<br>3、忽略属性之间的相关性。<br>4、不支持在线学习<br>5、它们是不稳定的，这意味着数据的微小变化可能导致最优决策树结构的巨大变化。<br>6、计算可能变得非常复杂，特别是如果许多值不确定和/或许多结果是相关的。</li></ul><h2 id="决策树公式">决策树公式</h2><p><img src="http://r.photo.store.qq.com/psc?/V12XQ1QV2XlKPv/45NBuzDIW489QBoVep5mcfXH.U3WdPHorVpDWM0gJb2D3QOvpUVckAXxJL8hLjwjgrMoxu865v2q05HHVCszL8eFItNHO5KoZMacpgm73PY!/r" alt=""></p><h3 id="树模型">树模型</h3><hr><ul><li><strong>决策树</strong>：从根节点开始一步步走到叶子节点（决策）。</li><li>所有的数据最终都会落到叶子节点，即可以应用于分类也可以做回归。</li></ul><h3 id="树的组成">树的组成</h3><hr><ul><li><strong>根节点</strong>：第一个选择点</li><li><strong>非叶子节点于分支</strong>：中间过程</li><li><strong>叶子节点</strong>：最终的决策结果</li></ul><h3 id="决策树的训练与测试">决策树的训练与测试</h3><hr><ul><li>训练阶段从给定的训练集构造出一颗树，从根节点开始选择最有价值的特征开始切分节点。</li><li>测试阶段：根据构造出来的树模型从上到下走一遍。</li><li>一旦构造好了决策树，那么分类或者预测任务就很简单了，只需要走一遍就可以了，那么难点在于如何构造出一个树。</li></ul><h3 id="特征切分">特征切分</h3><hr><p>存在的问题：根节点的选择该用那个特征呢？接下来我们要如何划分？<br>思考：我们的目标应该使根节点就像老大，根节点下面的节点就像老二，老大应该比老二能更好的切分数据。<br>目标：选择一种衡量标准，来计算通过不同特征进行分支选择后的分类情况，找出来最好的就作为我们的根节点，以此类推确定所有的节点的划分标准。</p><h3 id="衡量标准——熵">衡量标准——熵</h3><hr><ul><li>熵：表示随机变量不确定性的度量（就是一个整体中内部元素的混乱程度，元素种类越多混乱程度越高）</li><li>公式：<br><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5nLOon6PRkUqIHD.R9KXA9*ah7Twa7esj1yYWHP3aBHi6FcamtGv76qo7NMc5i6FYKNZdRsfTN49rUOFVPZiggU!/mnull&amp;bo=cwF3AHMBdwADCSw!&amp;rf=photolist&amp;t=5" alt=""></li></ul><p>公式中pi表示第i种情况的概率</p><ul><li>熵值熵值与不确定性一般成正比<br>下图为熵值与概率的关系图：</li></ul><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5uNfuzFf.Njq94kymHaCq*47ucoUDxdMLlZpuwuB2u05oSkYToZakg9rNZncHZATj3PaboL15JCzUG6vtVqZXAU!/mnull&amp;bo=QAKLAUACiwEDCSw!&amp;rf=photolist&amp;t=5" alt=""></p><h3 id="决策树算法">决策树算法</h3><hr><ul><li>ID3：信息增益（存在的问题：每个数据都有一个ID特征（1，2，3，…，14），根据该特征分类之后的熵值恒为 0 ，但是实际上根据这个特征分类毫无意义）</li><li>C4.5：信息增益率（是ID3的升级，考虑自身熵值）</li><li><strong>CART：使用GINI系数来作为衡量标准</strong></li><li>GINI系数（基尼系数）：<br><img src="http://a1.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5iDp*u5ka5r6sbhAldywtygTKn.L7BO4KhYzhfvcXJheamxdUgPSWT9aeo6vFYum4*JijXdBhQPtYrSyVTfLI6c!/c&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=OgJ.ADoCfgADGTw!&amp;tl=1&amp;vuin=1005741898&amp;tm=1618920000&amp;sce=60-2-2&amp;rf=0-0" alt=""></li></ul><h3 id="减枝策略">减枝策略</h3><hr><p><strong>离散化，</strong><br>把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。<br>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如:<br>原数据:1,999,100000,15;处理后:1,3,4,2;<br>原数据:{100,200}，{20,50000}，{1,400};<br>处理后:{3,4}，{2,6}，{1,5};</p><ul><li>针对连续值我们可以采用“离散化”的方式减少决策树计算量过大，叶子节点过多的问题。例如一组特征值为60，70，80，90，95，100，120，125，220。直接采用二分将会出现9个节点。如果我们人为分成A（60-80）、B（90-100）、C（120-220），我们只需要分成3类即可。当然要根据特征含义和特定分析条件下选择是否分割数据。</li><li>决策树剪枝：为了防止过拟合情况。（决策树过拟合分析很大，理论上可以完全分开数据，使得每个叶子节点只存在一个数据）</li><li>剪枝策略：<br>1、预剪枝（实用）：边建立决策树边进行剪枝操作。方法：限制树的深度，叶子节点的个数，叶子节点包含的样本树，信息增益量等。<br>2、后剪枝：当建立完决策树后来进行剪枝操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火算法</title>
      <link href="/2022/09/08/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/266874840">知乎原博客</a></p><p><a href="http://t.csdn.cn/aEReJ">CSDN优秀博客</a></p><h1>模拟退火算法</h1><h2 id="优点：">优点：</h2><p>模拟退火算法的优点在于：<strong>不管函数形式多复杂，模拟退火算法更有可能找到全局最优解。</strong></p><p>迭代原则简单，理论支撑强，实际效果也很好</p><h2 id="1-金属退火的原理"><strong>1.金属退火的原理</strong></h2><p>金属退火是将金属加热到一定温度，保持足够时间，然后以适宜速度冷却(通常是缓慢冷却，有时是控制冷却)的一种金属热处理工艺。模拟退火算法来源于固体退火原理，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到<a href="https://www.zhihu.com/search?q=%E5%9F%BA%E6%80%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22266874840%22%7D">基态</a>，内能减为最小。</p><p><img src="https://pic3.zhimg.com/v2-cce87c2c7bde7807d14365d6fbd846ce_b.jpg" alt="img"></p><p>如上图，处在低温状态时，固体中分子具有的内能很低，在原本的位置上做小范围的振动。若是将固体加热到一定温度，分子内能将会增加，<a href="https://www.zhihu.com/search?q=%E7%83%AD%E8%BF%90%E5%8A%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22266874840%22%7D">热运动</a>加剧，分子排列的无序度增加。此时再将温度缓缓降低，在每个温度都达到平衡态（即准静态过程），分子具有的能量逐渐降低，最终回归到有序排列的状态，分子内能也跟着降到最低。</p><h2 id="2-模拟退火算法机制"><strong>2.模拟退火算法机制</strong></h2><p>模拟退火算法<code>(Simulated Annealing,SA)</code>最早的思想是由<code>N. Metropolis</code>等人于<code>1953</code>年提出。<code>1983</code>年,<code>S. Kirkpatrick</code>等成功地将退火思想引入到组合优化领域。它是基于<code>Monte-Carlo</code> 迭代求解策略的一种随机寻优算法，其出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。</p><p>介绍模拟退火前，还是有必要先介绍爬山算法。</p><h3 id="爬山算法"><strong>爬山算法</strong></h3><p>爬山算法是一种简单的贪心搜索算法，该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解。</p><p><img src="https://pic3.zhimg.com/80/v2-dc9922369b5cf664398149e6d983a5b6_720w.jpg" alt="img"></p><p>爬山算法实现很简单，其主要缺点是会陷入局部最优解，而不一定能搜索到全局最优解。如上图所示：假设<code>C</code>点为当前解，爬山算法搜索到<code>A</code>点这个局部最优解就会停止搜索，因为在<code>A</code>点无论向那个方向小幅度移动都不能得到更优的解。</p><h3 id="模拟退火核心思想"><strong>模拟退火核心思想</strong></h3><p>模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合一定的概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。如下图：</p><p>这里的“一定的概率”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。将温度T当作控制参数，目标函数值<code>f</code>视为内能<code>E</code>，而固体在某温度<code>T</code>时的一个状态对应一个解<img src="https://www.zhihu.com/equation?tex=x_%7Bi%7D" alt="[公式]">，然后算法试图随着控制参数T的降低，使目标函数<code>f</code>(内能<code>E</code>)也逐渐降低，直至趋于全局最小值（退火中低温时的最低能量状态），就像金属退火过程一样。</p><p>关于爬山算法与模拟退火，有一个有趣的比喻：</p><ul><li>爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。</li><li>模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。</li></ul><h3 id="模拟退火数学原理"><strong>模拟退火数学原理</strong></h3><p>从上面我们知道，会结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，那么具体的更新解的机制是什么呢？如果新解比当前解更优，则接受新解，否则基于<code>Metropolis</code>准则判断是否接受新解。接受概率为：</p><p><img src="https://www.zhihu.com/equation?tex=%09P+%3D++%09%5Cbegin%7Bcases%7D+%091%2C~~~~~~~~~~~~~~~~~+E_%7Bt%2B1%7D+%5Clt+E_%7Bt%7D+%5C%5C+%09e%5E%7B%5Cfrac%7B-%28E_%7Bt%2B1%7D+-+E_%7Bt%7D%29%7D%7BkT%7D%7D%2C~~~~+E_%7Bt%2B1%7D+%5Cge+E_%7Bt%7D+%09%5Cend%7Bcases%7D+%5C%5C" alt="[公式]"></p><p>如上公式，假设当前时刻搜索的解为<img src="https://www.zhihu.com/equation?tex=x_%7Bt%7D" alt="[公式]">，对应的系统能量(目标函数)为<img src="https://www.zhihu.com/equation?tex=E_%7Bt%7D" alt="[公式]">，对搜索点施加随机扰动，产生新解<img src="https://www.zhihu.com/equation?tex=x_%7Bt%2B1%7D" alt="[公式]">，相应地，系统能量为<img src="https://www.zhihu.com/equation?tex=E_%7Bt%2B1%7D" alt="[公式]">，那么系统对搜索点从<img src="https://www.zhihu.com/equation?tex=x_%7Bt%7D" alt="[公式]">到<img src="https://www.zhihu.com/equation?tex=x_%7Bt%2B1%7D" alt="[公式]">转变的接受概率就为上公式。具体以下图为例：</p><p><img src="https://pic3.zhimg.com/80/v2-66faae9e6cb2e1dde6023e8f9fe3a07e_720w.jpg" alt="img"></p><p>假设开始状态在<code>A</code>，随着迭代次数更新到<code>B</code>局部最优解，这时发现更新到<code>B</code>时，能量比<code>A</code>要低，则说明接近最优解了，因此百分百转移，状态到达<code>B</code>后，发现下一步能量上升了，如果是梯度下降则是不允许继续向前的，而这里会以一定的概率跳出这个坑，这个概率和当前的状态、能量等都有关系，如果<code>B</code>最终跳出来了到达<code>C</code>，又会继续以一定的概率跳出来，直到到达<code>D</code>后，就会稳定下来。</p><h2 id="3-模拟退火的流程"><strong>3.模拟退火的流程</strong></h2><p>算法实质分两层循环，在任一温度水平下，随机扰动产生新解，并计算目标函数值的变化，决定是否被接受。由于算法初始温度比较高，这样，使<code>E</code>增大的新解在初始时也可能被接受，因而能跳出局部极小值，然后通过缓慢地降低温度，算法就最终可能收敛到全局最优解，具体流程为：</p><ol><li>令<img src="https://www.zhihu.com/equation?tex=T+%3D+T_%7B0%7D" alt="[公式]">,表示开始退火的初始温度，随机产生一个初始解<img src="https://www.zhihu.com/equation?tex=x_%7B0%7D" alt="[公式]">,并计算对应的目标函数值<img src="https://www.zhihu.com/equation?tex=E%28x_%7B0%7D%29" alt="[公式]">;</li><li>令<img src="https://www.zhihu.com/equation?tex=T+%3D+kT" alt="[公式]">,其中<code>k</code>取值<code>0</code>到<code>1</code>之间，为温度下降速率；</li><li>对当前解<img src="https://www.zhihu.com/equation?tex=x_%7Bt%7D" alt="[公式]">施加随机扰动，在其邻域内产生一个新解<img src="https://www.zhihu.com/equation?tex=x_%7Bt%2B1%7D" alt="[公式]">，并计算对应的目标函数值<img src="https://www.zhihu.com/equation?tex=E%28x_%7Bt%2B1%7D%29" alt="[公式]">,计算</li></ol><p><img src="https://www.zhihu.com/equation?tex=%09%5CDelta+E+%3D+E%28x_%7Bt%2B1%7D%29+-+E%28x_%7Bt%7D%29+%5C%5C" alt="[公式]"></p><ol><li>若<img src="https://www.zhihu.com/equation?tex=%5CDelta+E+%5Clt+0" alt="[公式]">,接受新解作为当前解，否则按照概率<img src="https://www.zhihu.com/equation?tex=e%5E%7B-+%5CDelta+E%2FkT%7D" alt="[公式]">判断是否接受新解；</li><li>在温度<code>T</code>下，重复<code>L</code>次扰动和接受过程，即执行步骤<code>3</code>和<code>4</code>；</li><li>判断温度是否达到终止温度水平，若是则终止算法，否则返回步骤<code>2</code>.</li></ol><h3 id="Metropolis准则判断">Metropolis准则判断</h3><p>刚才说了，对当前解加随机扰动，得到一个新的解，那要不要接受这个解呢？模拟退火算法则使用的蒙特卡洛判断准则，这也是模拟退火算法的灵魂。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>E</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&lt;</mo><msub><mi>E</mi><mi>t</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>e</mi><mfrac><mrow><mo>−</mo><mrow><mo fence="true">{</mo><msub><mi>E</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>E</mi><mi>t</mi></msub><mo fence="true">)</mo></mrow></mrow><mrow><mi>k</mi><mi>T</mi></mrow></mfrac></msup><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>E</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>≥</mo><msub><mi>E</mi><mi>t</mi></msub></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">P=\left\{\begin{array}{ll}1, &amp; E_{t+1}&lt;E_{t} \\e^{\frac{-\left\{E_{t+1}-E_{t}\right)}{k T}}, &amp; E_{t+1} \geq E_{t}\end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6747em;"><span style="top:-4.1242em;"><span class="pstrut" style="height:3.2894em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.4747em;"><span class="pstrut" style="height:3.2894em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2894em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3235em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.6245em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="minner mtight"><span class="mopen sizing reset-size1 size3 mtight delimcenter" style="top:0.0714em;"><span class="mtight">{</span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:-0.0576em;margin-right:0.1em;"><span class="pstrut" style="height:2.6444em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:-0.0576em;margin-right:0.1em;"><span class="pstrut" style="height:2.6151em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2703em;"><span></span></span></span></span></span></span><span class="mclose sizing reset-size1 size3 mtight delimcenter" style="top:0.0714em;"><span class="mtight">)</span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1747em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6747em;"><span style="top:-4.1242em;"><span class="pstrut" style="height:3.2894em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4747em;"><span class="pstrut" style="height:3.2894em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1747em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在上式中，P为接受新解的概率。比如，当前解是x_t，对应的系统能量（目标函数）为E_t，局部搜索后，产生新解x_t+1，那要不要接受这个新解呢？判断准则就是上边的这个公式。</p><p>根据上边这个公式，我们可以看出（注意此处是寻找最小值）：</p><p>当新解对应的目标函数小于当前解的目标函数值的时候，一定会接受新解（接受新解的概率为1）；</p><p>当新解对应的目标函数大于当前解的目标函数值的时候，则以一定的概率接受新解，你再看细点，当其他变量一定的情况下，新解对应的目标函数值超过当前解目标函数值越多，则接受这个新解的概率越小（想一想，这是不是正好符合我们的直观感觉）；此外，接受新解的概率还受到降温系数k和初始温度T的影响。</p><h3 id="流程解释2">流程解释2</h3><p>既然叫模拟退火算法，那就模拟的退火的过程，那算法的流程应该和退火的过程相一致。<br>回顾一下退火过程，在降温过程中实际上是分为两个层次的：<br>层次一：每降到一个温度时，会涉及到一个等温过程，见第一部分；</p><p>层次二：温度不断下降，直至达到我们指定的温度</p><p>那么对应的算法如下：</p><ol><li>一开始要给定一个相对较高的初始温度T，产生一个初始解x0（可以采用随机产生），计算对应的目标函数值E（x0）；</li><li>令T=kT，其中k是0-1的值，为温度下降系数。</li><li>对当前解Xt，随机扰动，在其领域内产生一个新解X(t+1)，计算出其对应的函数值，根据上述蒙特卡洛判断准则进行判断是否接受新解；</li><li>在温度T下，迭代L次扰动和接受过程。（其实这里的L次被叫做马尔科夫链的长度）</li><li>判断是否到达终止温度，若到达，则终止，否则返回步骤2；</li></ol><h3 id="控制参数">控制参数</h3><p>该算法涉及到的各项控制参数和各个需要自行给定的变量如下表所示。</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">T</td><td style="text-align:center">初始温度</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">马尔科夫链的长度，即等温过程的迭代次数</td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">温度下降速率，为0-1之间的数</td></tr><tr><td style="text-align:center">T(终)</td><td style="text-align:center">算法停止温度</td></tr><tr><td style="text-align:center">X（0）</td><td style="text-align:center">初始解</td></tr></tbody></table><h3 id="算法特点">算法特点</h3><ol><li>初始温度和马尔科夫链长度的设置问题。理论上来说，初始温度越高，且马尔科夫链越长，算法搜索越充分，得到全局最优解的可能性越大，但这也以为这需要耗费更多的计算时间。这个可以在算法里使用控制变量法进行测试。</li><li>退火问题。温度下降速率k越小，温度下降就越快，对应的迭代次数就越少，这样就可能导致得不到全局最优解；此外，到后期温度衰减很慢，对于这一点，我们可以将温度下降系数k设置为动态的，即随着温度的下降，温度下降系数也不断降低，比如k = 0.99k，以加快后期温度下降，加快算法收敛。</li><li>扰动算子。扰动不宜过大，这样可能会错过全局最优解。<br>置为动态的，即随着温度的下降，温度下降系数也不断降低，比如k = 0.99k，以加快后期温度下降，加快算法收敛。</li></ol><p>具体流程图如下：</p><p><img src="https://pic4.zhimg.com/80/v2-e1529b1b1577eecd16fb8a5418d51533_720w.jpg" alt="img"></p><p>其中有几个需要注意的点：</p><ul><li>初始点的选取对算法结果有一定的影响，最好是多次运行对结果进行综合判断。</li><li>在算法运行初期，温度下降快，避免接受过多的差结果。当运行时间增加，温度下降减缓，以便于更快稳定结果。</li><li>当迭代次数增加到一定次数时，结果可能已经达到稳定，但是距离算法结束还有一段时间。在设计程序时应该加入适当的输出条件，满足输出条件即可结束程序。</li></ul><h2 id="4-模拟退火的应用"><strong>4.模拟退火的应用</strong></h2><p>模拟退火算法作为一种通用的随机搜索算法，现已广泛用于<code>VLSI</code>设计、图像识别和神经网计算机的研究。模拟退火算法的应用如下：</p><ul><li>模拟退火算法在<code>VLSI</code>设计中的应用<br>利用模拟退火算法进行<code>VLSI</code>(<code>Very Large Scale Integration</code>,超大规模集成电路)的最优设计，是目前模拟退火算法最成功的应用实例之一。用模拟退火算法几乎可以很好地完成所有优化的<code>VLSI</code>设计工作。如全局布线、布板、布局和逻辑最小化等等。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-b74a10d5aea56bf8dc6280bb9e186544_720w.jpg" alt="img"></p><ul><li>模拟退火算法在图像处理中的应用<br>模拟退火算法可用来进行图像恢复等工作，即把一幅被污染的图像重新恢复成清晰的原图，滤掉其中被畸变的部分。因此它在图像处理方面的应用前景是广阔的。</li><li>模拟退火算法在神经网计算机中的应用<br>模拟退火算法具有跳出局部最优陷阱的能力。在<code>Boltzmann</code>机中，即使系统落入了局部最优的陷阱，经过一段时间后，它还能再跳出来，系统最终将往全局最优值的方向收敛。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-03bb8b2fb03d3dd294d3b9189b9840da_720w.jpg" alt="img"></p><ul><li>模拟退火算法的其他应用<br>除了上述应用外，模拟退火算法还用于其它各种组合优化问题，如<code>TSP</code>和<code>Knapsack</code>问题等。大量的模拟实验表明，模拟退火算法在求解这些问题时能产生令人满意的近似最优解，而且所用的时间也不很长。</li></ul><h2 id="5-小结"><strong>5.小结</strong></h2><p>总之，模拟退火算法是通过赋予搜索过程一种时变且最终趋于零的概率突跳性，从而可有效避免陷入局部极小并最终趋于全局最优的串行结构的优化算法。算法从某一较高初温出发，伴随温度参数的不断下降,结合一定的概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。</p><p>至此，本文从金属退火的原理，爬山算法，模拟退火算法思想以及原理，到模拟退火的流程和应用方面对模拟退火算法进行了简单的阐述，希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟退火 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO学习笔记</title>
      <link href="/2022/09/08/YOLO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/08/YOLO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>推荐博客</h1><p><a href="https://blog.csdn.net/wjinjie/article/details/107509243?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163249930316780271530764%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163249930316780271530764&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107509243.pc_search_result_cache&amp;utm_term=yolo&amp;spm=1018.2226.3001.4187">从yolov1至yolov4的进阶之路</a></p><p><a href="https://zhuanlan.zhihu.com/p/183261974">你一定从未看过如此通俗易懂的YOLO系列(从v1到v5)模型解读 (上)</a></p><p><a href="https://zhuanlan.zhihu.com/p/183781646">你一定从未看过如此通俗易懂的YOLO系列(从v1到v5)模型解读 (中)</a></p><p><a href="https://zhuanlan.zhihu.com/p/186014243">你一定从未看过如此通俗易懂的YOLO系列(从v1到v5)模型解读 (下)</a></p><p><a href="https://zhuanlan.zhihu.com/p/94986199">写给小白的Yolo介绍</a></p><p>比较流行的算法可以分为两类，一类是基于Region Proposal的R-CNN系算法（R-CNN，Fast R-CNN, Faster R-CNN），它们是two-stage的，需要先使用启发式方法（selective search）或者CNN网络（RPN）产生Region Proposal，然后再在Region Proposal上做分类与回归。</p><h1>YOLO（You Only Look Once）</h1><img src="https://pjreddie.com/media/image/yologo_2.png" alt="img" style="zoom: 25%;" /><p><strong>YOLO v1：直接回归出位置。</strong></p><p><strong>YOLO v2：全流程多尺度方法。</strong></p><p><strong>YOLO v3：多尺度检测头，resblock darknet53</strong></p><p><strong>YOLO v4：cspdarknet53，spp，panet，tricks</strong></p><h2 id="0-前言">0 前言</h2><p>本文目的是用尽量浅显易懂的语言让零基础小白能够理解什么是YOLO系列模型，以及他们的设计思想和改进思路分别是什么。我不会把YOLO的论文给你用软件翻译一遍，这样做毫无意义；也不会使用太专业晦涩的名词和表达，对于每一个新的概念都会解释得尽量通俗一些，目的是使得你能像看故事一样学习YOLO模型，我觉得这样的学习方式才是知乎博客的意义所在。</p><p>为了使本文<strong>尽量生动有趣</strong>，我用葫芦娃作为例子展示YOLO的过程(真的是尽力了。。。)。</p><p><img src="https://pic2.zhimg.com/80/v2-6f33f7b365e952d0cb1436c540135a0d_720w.jpg" alt="img"></p><p>葫芦娃</p><p>同时，会对<strong>YOLO v1和YOLOv5</strong>的代码进行解读，其他的版本就只介绍改进了。</p><hr><h2 id="1-先从一款强大的app说起">1 先从一款强大的app说起</h2><p><img src="https://pic1.zhimg.com/80/v2-6821e6ed09cedb367cde596fbfcb4328_720w.jpg" alt="img">i detection APP</p><p><strong>YOLO v5</strong>其实一开始是以一款<strong>app</strong>进入人们的视野的，就是上图的这个，叫：<strong>i detection</strong>(图上标的是YOLO v4，但其实算法是YOLO v5)，使用<strong>iOS</strong>系列的小伙伴呢，就可以立刻<strong>点赞后</strong>关掉我这篇文章，去下载这个app玩一玩。在任何场景下(工业场景，生活场景等等)都可以试试这个app和这个算法，这个app中间还有一个<strong>button</strong>，来调节app使用的模型的大小，更大的模型实时性差但精度高，更小的模型实时性好但精度差。</p><p>值得一提的是，这款app就是<strong>YOLO v5的作者</strong>亲自完成的。而且，我写这篇文章的时候YOLO v5的论文还没有出来，还在实验中，等论文出来应该是2020年底或者2021年初了。</p><p><strong>读到这里，你觉得YOLO v5的最大特点是什么？</strong></p><p><strong>答案就是：一个字：快</strong>，应用于移动端，模型小，速度快。</p><p>首先我个人觉得任何一个模型都有下面3部分组成：</p><ul><li><strong>前向传播部分：90%</strong></li><li><strong>损失函数部分</strong></li><li><strong>反向传播部分</strong></li></ul><p>其中前向传播部分占用的时间应该在90%左右，即搞清楚前向传播部分也就搞清楚了这模型的实现流程和细节。本着这一原则，我们开始YOLO系列模型的解读：</p><hr><h2 id="2-不得不谈的分类模型">2 不得不谈的分类模型</h2><p>在进入目标检测任务之前首先得学会图像分类任务，这个任务的特点是输入一张图片，输出是它的类别。</p><p>对于<strong>输入图片</strong>，我们一般用一个矩阵表示。</p><p>对于<strong>输出结果</strong>，我们一般用一个one-hot vector表示： <img src="https://www.zhihu.com/equation?tex=%5B0%2C0%2C1%2C0%2C0%2C0%5D" alt="[公式]"> ，哪一维是1，就代表图片属于哪一类。</p><p>所以，在设计神经网络时，结构大致应该长这样：</p><p>img <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp16<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp32<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp64<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp128<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> …<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> fc256-fc[10]</p><p>这里的cbrp指的是conv，bn，relu，pooling的串联。</p><p>由于输入要是one-hot形式，所以最后我们设计了2个fc层(fully connencted layer)，我们称之为**“分类头”<strong>或者</strong>“决策层”**。</p><hr><h2 id="3-YOLO系列思想的雏形：YOLO-v0">3 YOLO系列思想的雏形：YOLO v0</h2><p>有了上面的分类器，我们能不能用它来做检测呢？</p><p>要回答这个问题，首先得看看检测器和分类器的输入输出有什么不一样。首先他们的输入都是image，但是分类器的输出是一个one-hot vector，而检测器的输出是一个框(Bounding Box)。</p><p><strong>框</strong>，该怎么表示？</p><p>在一个图片里面表示一个框，有很多种方法，比如：</p><p><img src="https://pic3.zhimg.com/80/v2-5d8895c050a05b9ce813b5289ec2a4da_720w.jpg" alt="img">x,y,w,h表示一个框</p><ul><li><strong>x,y,w,h</strong>(如上图)</li><li><strong>p1,p2,p3,p4</strong>(4个点坐标)</li><li><strong>cx,cy,w,h</strong>(cx,cy为中心点坐标)</li><li><strong>x,y,w,h</strong>,<strong>angle</strong>(还有的目标是有角度的，这时叫做Rotated Bounding Box)</li><li>…</li></ul><p>所以表示的方法不是一成不变的，但你会发现：不管你用什么形式去表达这个Bounding Box，你模型输出的结果一定是一个vector，那这个vector和分类模型输出的vector本质上有什么区别吗？</p><p><strong>答案是：没有</strong>，都是向量而已，只是分类模型输出是one-hot向量，检测模型输出是我们标注的结果。</p><p>所以你应该会发现，检测的方法呼之欲出了。<strong>那分类模型可以用来做检测吗？</strong></p><p><strong>当然可以，<strong>这时，你可以把检测的任务当做是</strong>遍历性的分类任务。</strong></p><p><strong>如何遍历？</strong></p><p><strong>我们的目标是一个个框，那就用这个框去遍历所有的位置，所有的大小。</strong></p><p>比如下面这张图片，我需要你检测葫芦娃的脸，如图1所示：</p><p><img src="https://pic4.zhimg.com/80/v2-a1843eda0e8f2c6ea8cddb5180da1da3_720w.jpg" alt="img">图1：检测葫芦娃的脸</p><p>我们可以对边框的区域进行二分类：属于头或者不属于头。</p><p>你先预设一个框的大小，然后在图片上遍历这个框，比如第一行全都不是头。第4个框只有一部分目标在，也不算。第5号框算是一个头，我们记住它的位置。这样不断地滑动，就是遍历性地分类。</p><p>接下来要遍历框的大小：因为你刚才是预设一个框的大小，但葫芦娃的头有大有小，你还得遍历框的大小，如下图2所示：</p><p><img src="https://pic4.zhimg.com/80/v2-9c3d5b1c85adf80791780697b9ad8ecb_720w.jpg" alt="img">图2：遍历框的大小</p><p>还没有结束，刚才滑窗时是挨个滑，但其实没有遍历所有的位置，更精确的遍历方法应该如下图3所示：</p><p><img src="https://pic2.zhimg.com/80/v2-eda9abf77cb3597a41cc460c6f4f6d0d_720w.jpg" alt="img"></p><p>图3：更精确地遍历框的位置</p><p>这种方法其实就是RCNN全家桶的初衷，专业术语叫做：<strong>滑动窗口分类方法</strong>。</p><p>现在需要你思考一个问题：<strong>这种方法的精确和什么因素有关？</strong></p><p><strong>答案是：遍历得彻不彻底</strong>。遍历得越精确，检测器的精度就越高。所以这也就带来一个问题就是：<strong>检测的耗时非常大</strong>。</p><p>举个例子：比如输入图片大小是(800,1000)也就意味着有800000个位置。窗口大小最小 <img src="https://www.zhihu.com/equation?tex=%281%5Ctimes1%29" alt="[公式]"> ,最大 <img src="https://www.zhihu.com/equation?tex=%28800%5Ctimes1000%29" alt="[公式]"> ，所以这个遍历的次数是<strong>无限次</strong>。我们看下伪代码：</p><p><img src="https://pic4.zhimg.com/80/v2-72224eb25b6bcfce14d31a5a571422f3_720w.jpg" alt="img"></p><p>滑动窗口分类方法伪代码</p><p>那这种方法如何训练呢？</p><p>本质上还是训练一个二分类器。这个二分类器的<strong>输入是一个框的内容，输出是(前景/背景)</strong>。</p><p><strong>第1个问题：</strong></p><p>框有不同的大小，对于不同大小的框，输入到相同的二分类器中吗？</p><p>是的。要先把不同大小的input归一化到统一的大小。</p><p><strong>第2个问题：</strong></p><p>背景图片很多，前景图片很少：二分类样本不均衡。</p><p>确实是这样，你看看一张图片有多少框对应的是背景，有多少框才是葫芦娃的头。</p><p>以上就是传统检测方法的主要思路：</p><ul><li>耗时。</li><li>操作复杂，需要手动生成大量的样本。</li></ul><p><strong>到现在为止，我们用分类的算法设计了一个检测器，它存在着各种各样的问题，现在是优化的时候了(接下来正式进入YOLO系列方法了)：</strong></p><p>YOLO的作者当时是这么想的：你分类器输出一个one-hot vector，那我把它换成**(x,y,w,h,c)**，c表示confidence置信度，把问题转化成一个回归问题，直接回归出Bounding Box的位置不就好了吗？</p><p>刚才的分类器是：img <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp16<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp32<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp64<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp128<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> …<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> fc256-fc[10]</p><p>现在我变成：img <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp16<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp32<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp64<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp128<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> …<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> fc256-fc[5]，这个输出是**(x,y,w,h,c)**，不就变成了一个检测器吗？</p><p><strong>本质上都是矩阵映射到矩阵，只是代表的意义不一样而已。</strong></p><blockquote><p>传统的方法为什么没有这么做呢？我想肯定是效果不好，终其原因是算力不行，conv操作还没有推广。</p></blockquote><p>好，现在模型是：</p><p>img <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp16<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp32<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp64<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp128<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> …<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> fc256-fc[5] <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> c,x,y,w,h</p><p><img src="https://pic2.zhimg.com/80/v2-833df61bdd1b13d0647acf5fbe139339_720w.jpg" alt="img"></p><p>那如何组织训练呢？找1000张图片，把label设置为 <img src="https://www.zhihu.com/equation?tex=%281%2Cx%5E%7B%2A%7D%2Cy%5E%7B%2A%7D%2Cw%5E%7B%2A%7D%2Ch%5E%7B%2A%7D%29" alt="[公式]"> 。这里 <img src="https://www.zhihu.com/equation?tex=x%5E%7B%2A%7D" alt="[公式]"> 代表真值。有了数据和标签，就完成了设计。</p><p>我们会发现，这种方法比刚才的<strong>滑动窗口分类方法</strong>简单太多了。这一版的思路我把它叫做<strong>YOLO v0</strong>，因为它是<strong>You Only Look Once</strong>最简单的版本。</p><hr><h2 id="4-YOLO-v1终于诞生">4 YOLO v1终于诞生</h2><ul><li><strong>需求1：YOLO v0只能输出一个目标，那比如下图4的多个目标怎么办呢？</strong></li></ul><p><img src="https://pic1.zhimg.com/80/v2-bdf872e1bc2ac749425d3e45b123b3ec_720w.jpg" alt="img"></p><p>图4：多个目标情况</p><p>你可能会回答：我输出N个向量不就行了吗？但具体输出多少个合适呢？图4有7个目标，那有的图片有几百个目标，你这个N又该如何调整呢？</p><p><strong>答：为了保证所有目标都被检测到，我们应该输出尽量多的目标。</strong></p><p><img src="https://pic1.zhimg.com/80/v2-de3aec28683d4e58fca1218ddfaff670_720w.jpg" alt="img">输出尽量多的目标</p><p>但这种方法也不是最优的，最优的应该是下图这样：</p><p><img src="https://pic3.zhimg.com/80/v2-0c9a23e1c1740d62ccf50cdc97b0bcb2_720w.jpg" alt="img"></p><p>图5：用一个(c,x,y,w,h)去负责image某个区域的目标</p><p>如图5所示：用一个(c,x,y,w,h)去负责image某个区域的目标。</p><p>比如说图片设置为16个区域，每个区域用1个(c,x,y,w,h)去负责：</p><p><img src="https://pic2.zhimg.com/80/v2-a6230457e694322c04998b7d0536a889_720w.jpg" alt="img">图6：图片设置为16个区域</p><p>就可以一次输出16个框，每个框是1个(c,x,y,w,h)，如图6所示。</p><p>为什么这样子更优？因为conv操作是位置强相关的，就是原来的目标在哪里，你conv之后的feature map上还在哪里，所以图片划分为16个区域，结果也应该分布在16个区域上，所以我们的<strong>结果(Tensor)的维度size是：(5,4,4)</strong>。</p><p>那现在你可能会问：<strong>c的真值该怎么设置呢？</strong></p><p>**答：**看葫芦娃的大娃，他的脸跨了4个区域(grid)，但只能某一个grid的c=1，其他的c=0。那么该让哪一个grid的c=1呢？就看他的脸的中心落在了哪个grid里面。根据这一原则，c的真值为下图7所示：</p><p><img src="https://pic4.zhimg.com/80/v2-02a45bc027de8ff65693bcf1ae21c2e3_720w.jpg" alt="img">图7：c的label值</p><p>但是你发现7个葫芦娃只有6个1，原因是某一个grid里面有2个目标，确实如此，第三行第三列的grid既有<strong>水娃</strong>又有<strong>隐身娃</strong>。这种一个区域有多个目标的情况我们<strong>目前没法解决，因为我们的模型现在能力就这么大，只能在一个区域中检测出一个目标，如何改进我们马上就讨论，你可以现在先自己想一想。</strong></p><p>总之现在我们设计出了模型的输出结果，那距离完成模型的设计还差一个损失函数，那Loss咋设计呢？看下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loss = 0</span><br><span class="line">for img in img_all:</span><br><span class="line">   for i in range(4):</span><br><span class="line">      for j in range(4):</span><br><span class="line">         loss_ij = lamda_1*(c_pred-c_label)**2 + c_label*(x_pred-x_label)**2 +\</span><br><span class="line">                     c_label*(y_pred-y_label)**2 + c_label*(w_pred-w_label)**2 + \</span><br><span class="line">                     c_label*(h_pred-h_label)**2</span><br><span class="line">         loss += loss_ij</span><br><span class="line">loss.backward()</span><br></pre></td></tr></table></figure><blockquote><p>遍历所有图片，遍历所有位置，计算loss。</p></blockquote><ul><li>好现在模型设计完了，回到刚才的问题：模型现在能力就这么大，只能在一个区域中检测出一个目标，如何改进？</li></ul><p>**答：**刚才区域是 <img src="https://www.zhihu.com/equation?tex=4%5Ctimes4" alt="[公式]"> ，现在变成 <img src="https://www.zhihu.com/equation?tex=40%5Ctimes40" alt="[公式]"> ，或者更大，使区域更密集，就可以缓解多个目标的问题，但无法从根本上去解决。</p><ul><li>另一个问题，按上面的设计你检测得到了16个框，可是图片上只有7个葫芦娃的脸，怎么从16个结果中筛选出7个我们要的呢？</li></ul><p><strong>答：</strong></p><p>**法1：聚类。**聚成7类，在这7个类中，选择confidence最大的框。听起来挺好。</p><p>**法1的bug：**2个目标本身比较近聚成了1个类怎么办？如果不知道到底有几个目标呢？为何聚成7类？不是3类？</p><p>**法2：NMS(非极大值抑制)。**2个框重合度很高，大概率是一个目标，那就只取一个框。</p><p>重合度的计算方法：交并比IoU=两个框的交集面积/两个框的并集面积。</p><p>具体算法：</p><p><img src="https://pic2.zhimg.com/80/v2-f2cf821fc64f14d2b60ae2f61409e3f5_720w.jpg" alt="img"></p><p>面试必考的NMS</p><p>**法1的bug：**2个目标本身比较近怎么办？依然没有解决。</p><p>如果不知道到底有几个目标呢？NMS自动解决了这个问题。</p><p>**面试的时候会问这样一个问题：**NMS的适用情况是什么？</p><p>**答：**1图多目标检测时用NMS。</p><p>到现在为止我们终于解决了第4节开始提出的多个目标的问题，现在又有了新的需求：</p><ul><li><strong>需求2：多类的目标怎么办呢？</strong></li></ul><p>比如说我现在既要你检测<strong>葫芦娃的脸</strong>，又要你检测<strong>葫芦娃的葫芦</strong>，怎么设计？</p><p>img <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp16<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp32<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp64<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp128<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> …<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> fc256-fc[5+2]*N <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> [c,x,y,w,h,one-hot]*N</p><p>2个类，one-hot就是[0,1],[1,0]这样子，如下图8所示：</p><p><img src="https://pic2.zhimg.com/80/v2-38ce7b4f57bc0833a66a6baf5559da99_720w.jpg" alt="img"></p><p>图8：多类的目标的label</p><p>伪代码依然是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">loss = 0</span><br><span class="line">for img in img_all:</span><br><span class="line">   for i in range(3):</span><br><span class="line">      for j in range(4):</span><br><span class="line">         c_loss = lamda_1*(c_pred-c_label)**2</span><br><span class="line">         geo_loss = c_label*(x_pred-x_label)**2 +\</span><br><span class="line">                     c_label*(y_pred-y_label)**2 + c_label*(w_pred-w_label)**2 + \</span><br><span class="line">                     c_label*(h_pred-h_label)**2</span><br><span class="line">         class_loss = 1/m * mse_loss(p_pred, p_label)</span><br><span class="line">         loss_ij =c_loss  + geo_loss + class_loss</span><br><span class="line">         loss += loss_ij</span><br><span class="line">loss.backward()</span><br></pre></td></tr></table></figure><p>至此，多个类的问题也解决了，现在又有了新的需求：</p><ul><li><strong>需求3：小目标检测怎么办呢？</strong></li></ul><p>小目标总是检测不佳，所以我们专门设计神经元去拟合小目标。</p><p><img src="https://pic2.zhimg.com/80/v2-efb58a2c9d3e881df099789f640471ad_720w.jpg" alt="img"></p><p>图9：多类的小目标的label，分别预测大目标和小目标</p><p>对于每个区域，我们用2个五元组(c,x,y,w,h)，一个负责回归大目标，一个负责回归小目标，同样添加one-hot vector，one-hot就是[0,1],[1,0]这样子，来表示属于哪一类(葫芦娃的头or葫芦娃的葫芦)。</p><p>伪代码变为了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">loss = 0</span><br><span class="line">for img in img_all:</span><br><span class="line">   for i in range(3):</span><br><span class="line">      for j in range(4):</span><br><span class="line">         c_loss = lamda_1*(c_pred-c_label)**2</span><br><span class="line">         geo_loss = c_label_big*(x_big_pred-x_big_label)**2 +\</span><br><span class="line">                     c_label_big*(y_big_pred-y_big_label)**2 + c_label_big*(w_big_pred-w_big_label)**2 + \</span><br><span class="line">                     c_label_big*(h_big_pred-h_big_label)**2 +\</span><br><span class="line">                     c_label_small*(x_small_pred-x_small_label)**2 +\</span><br><span class="line">                     c_label_small*(y_small_pred-y_small_label)**2 + c_label_small*(w_small_pred-w_small_label)**2 + \</span><br><span class="line">                     c_label_small*(h_small_pred-h_small_label)**2</span><br><span class="line">         class_loss = 1/m * mse_loss(p_pred, p_label)</span><br><span class="line">         loss_ij =c_loss  + geo_loss + class_loss</span><br><span class="line">         loss += loss_ij</span><br><span class="line">loss.backward()</span><br></pre></td></tr></table></figure><p>至此，小目标的问题也有了解决方案。</p><p>到这里，我们设计的检测器其实就是YOLO v1，只是有的参数跟它不一样，我们看论文里的图：</p><p><img src="https://pic3.zhimg.com/80/v2-ce26d13cfd3b7145f4594524435a9b92_720w.jpg" alt="img"></p><p>YOLO v1</p><p><img src="https://pic4.zhimg.com/80/v2-3af308f7096bda4c621c077302b90533_720w.jpg" alt="img"></p><p>YOLO v1</p><p>YOLO v1其实就是把我们划分的16个区域变成了 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> 个区域，我们预测16个目标，YOLO v1预测49个目标。我们是2类(葫芦娃的头or葫芦娃的葫芦)，YOLO v1是20类。</p><p><img src="https://www.zhihu.com/equation?tex=30%3D5%2A2%28c_%7Bbig%7D%2Cx_%7Bbig%7D%2Cy_%7Bbig%7D%2Cw_%7Bbig%7D%2Ch_%7Bbig%7D%2C+c_%7Bsmall%7D%2Cx_%7Bsmall%7D%2Cy_%7Bsmall%7D%2Cw_%7Bsmall%7D%2Ch_%7Bsmall%7D%29%2B20+classes" alt="[公式]"></p><p>backbone也是一堆卷积+检测头(FC层)，所以说设计到现在，我们其实是把YOLO v1给设计出来了。</p><p>再看看作者的解释：</p><p><img src="https://pic2.zhimg.com/80/v2-6b90a56a5c57d2ed05ec620f4230ca45_720w.png" alt="img"></p><p>发现train的时候用的小图片，检测的时候用的是大图片(肯定是经过了无数次试验证明了效果好)。</p><p>结构学完了，再看loss函数，并比较下和我们设计的loss函数有什么区别。</p><p><img src="https://pic4.zhimg.com/80/v2-f81c565d41b681263689626331325ac3_720w.jpg" alt="img"></p><p>YOLO v1 loss函数</p><p><strong>解读一下这个损失函数：</strong></p><p>我们之前说的损失函数是设计了3个for循环，而作者为了方便写成了求和的形式：</p><ul><li>前2行计算前景的geo_loss。</li><li>第3行计算前景的confidence_loss。</li><li>第4行计算背景的confidence_loss。</li><li>第5行计算分类损失class_loss。</li></ul><p>伪代码上面已经有了，现在我们总体看一下这个模型：</p><p>img <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp192<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp256<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp512<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> cbrp1024<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> …<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> fc4096-fc[5+2]*N <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7%5Ctimes30" alt="[公式]"></p><p>检测层的设计：回归坐标值+one-hot分类</p><p><img src="https://pic2.zhimg.com/80/v2-bf46a1073c877181e06cba19b8c20995_720w.jpg" alt="img"></p><p>检测层的设计</p><ul><li><strong>样本不均衡的问题解决了吗？</strong></li></ul><p>没有计算背景的geo_loss，只计算了前景的geo_loss，这个问题YOLO v1回避了，依然存在。</p><p><strong>最后我们解读下YOLO v1的代码：</strong></p><p><strong>1.模型定义：</strong></p><p>定义特征提取层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class VGG(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">       super(VGG,self).__init__()</span><br><span class="line">       # the vgg&#x27;s layers</span><br><span class="line">       #self.features = features</span><br><span class="line">       cfg = [64,64,&#x27;M&#x27;,128,128,&#x27;M&#x27;,256,256,256,&#x27;M&#x27;,512,512,512,&#x27;M&#x27;,512,512,512,&#x27;M&#x27;]</span><br><span class="line">       layers= []</span><br><span class="line">       batch_norm = False</span><br><span class="line">       in_channels = 3</span><br><span class="line">       for v in cfg:</span><br><span class="line">           if v == &#x27;M&#x27;:</span><br><span class="line">               layers += [nn.MaxPool2d(kernel_size=2,stride = 2)]</span><br><span class="line">           else:</span><br><span class="line">               conv2d = nn.Conv2d(in_channels,v,kernel_size=3,padding = 1)</span><br><span class="line">               if batch_norm:</span><br><span class="line">                   layers += [conv2d,nn.Batchnorm2d(v),nn.ReLU(inplace=True)]</span><br><span class="line">               else:</span><br><span class="line">                   layers += [conv2d,nn.ReLU(inplace=True)]</span><br><span class="line">               in_channels = v</span><br><span class="line">       # use the vgg layers to get the feature</span><br><span class="line">       self.features = nn.Sequential(*layers)</span><br><span class="line">       # 全局池化</span><br><span class="line">       self.avgpool = nn.AdaptiveAvgPool2d((7,7))</span><br><span class="line">       # 决策层：分类层</span><br><span class="line">       self.classifier = nn.Sequential(</span><br><span class="line">           nn.Linear(512*7*7,4096),</span><br><span class="line">           nn.ReLU(True),</span><br><span class="line">           nn.Dropout(),</span><br><span class="line">           nn.Linear(4096,4096),</span><br><span class="line">           nn.ReLU(True),</span><br><span class="line">           nn.Dropout(),</span><br><span class="line">           nn.Linear(4096,1000),</span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line">       for m in self.modules():</span><br><span class="line">           if isinstance(m,nn.Conv2d):</span><br><span class="line">               nn.init.kaiming_normal_(m.weight,mode=&#x27;fan_out&#x27;,nonlinearity=&#x27;relu&#x27;)</span><br><span class="line">               if m.bias is not None: </span><br><span class="line">                   nn.init.constant_(m.bias,0)</span><br><span class="line">           elif isinstance(m,nn.BatchNorm2d):</span><br><span class="line">               nn.init.constant_(m.weight,1)</span><br><span class="line">               nn.init.constant_(m.bias,1)</span><br><span class="line">           elif isinstance(m,nn.Linear):</span><br><span class="line">               nn.init.normal_(m.weight,0,0.01)</span><br><span class="line">               nn.init.constant_(m.bias,0)</span><br><span class="line"></span><br><span class="line">    def forward(self,x):</span><br><span class="line">         x = self.features(x)</span><br><span class="line">         x_fea = x</span><br><span class="line">         x = self.avgpool(x)</span><br><span class="line">         x_avg = x</span><br><span class="line">         x = x.view(x.size(0),-1)</span><br><span class="line">         x = self.classifier(x)</span><br><span class="line">         return x,x_fea,x_avg</span><br><span class="line">    def extractor(self,x):</span><br><span class="line">         x = self.features(x)</span><br><span class="line">         return x</span><br></pre></td></tr></table></figure><p>定义检测头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.detector = nn.Sequential(</span><br><span class="line">   nn.Linear(512*7*7,4096),</span><br><span class="line">   nn.ReLU(True),</span><br><span class="line">   nn.Dropout(),</span><br><span class="line">   nn.Linear(4096,1470),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>整体模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class YOLOV1(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">       super(YOLOV1,self).__init__()</span><br><span class="line">       vgg = VGG()</span><br><span class="line">       self.extractor = vgg.extractor</span><br><span class="line">       self.avgpool = nn.AdaptiveAvgPool2d((7,7))</span><br><span class="line">       # 决策层：检测层</span><br><span class="line">       self.detector = nn.Sequential(</span><br><span class="line">          nn.Linear(512*7*7,4096),</span><br><span class="line">          nn.ReLU(True),</span><br><span class="line">          nn.Dropout(),</span><br><span class="line">          #nn.Linear(4096,1470),</span><br><span class="line">          nn.Linear(4096,245),</span><br><span class="line">          #nn.Linear(4096,5),</span><br><span class="line">       )</span><br><span class="line">       for m in self.modules():</span><br><span class="line">           if isinstance(m,nn.Conv2d):</span><br><span class="line">               nn.init.kaiming_normal_(m.weight,mode=&#x27;fan_out&#x27;,nonlinearity=&#x27;relu&#x27;)</span><br><span class="line">               if m.bias is not None: </span><br><span class="line">                   nn.init.constant_(m.bias,0)</span><br><span class="line">           elif isinstance(m,nn.BatchNorm2d):</span><br><span class="line">               nn.init.constant_(m.weight,1)</span><br><span class="line">               nn.init.constant_(m.bias,1)</span><br><span class="line">           elif isinstance(m,nn.Linear):</span><br><span class="line">               nn.init.normal_(m.weight,0,0.01)</span><br><span class="line">               nn.init.constant_(m.bias,0)</span><br><span class="line">    def forward(self,x):</span><br><span class="line">        x = self.extractor(x)</span><br><span class="line">        #import pdb</span><br><span class="line">        #pdb.set_trace()</span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        x = x.view(x.size(0),-1)</span><br><span class="line">        x = self.detector(x)</span><br><span class="line">        b,_ = x.shape</span><br><span class="line">        #x = x.view(b,7,7,30)</span><br><span class="line">        x = x.view(b,7,7,5)</span><br><span class="line">        </span><br><span class="line">        #x = x.view(b,1,1,5)</span><br><span class="line">        return x</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    vgg = VGG()</span><br><span class="line">    x  = torch.randn(1,3,512,512)</span><br><span class="line">    feature,x_fea,x_avg = vgg(x)</span><br><span class="line">    print(feature.shape)</span><br><span class="line">    print(x_fea.shape)</span><br><span class="line">    print(x_avg.shape)</span><br><span class="line"> </span><br><span class="line">    yolov1 = YOLOV1()</span><br><span class="line">    feature = yolov1(x)</span><br><span class="line">    # feature_size b*7*7*30</span><br><span class="line">    print(feature.shape)</span><br></pre></td></tr></table></figure><p><strong>2.模型训练：</strong></p><p>主函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    train()</span><br></pre></td></tr></table></figure><p>下面看train()函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def train():</span><br><span class="line">    for epoch in range(epochs):</span><br><span class="line">        ts = time.time()</span><br><span class="line">        for iter, batch in enumerate(train_loader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            # 取图片</span><br><span class="line">            inputs = input_process(batch)</span><br><span class="line">            # 取标注</span><br><span class="line">            labels = target_process(batch)</span><br><span class="line">            </span><br><span class="line">            # 获取得到输出</span><br><span class="line">            outputs = yolov1_model(inputs)</span><br><span class="line">            #import pdb</span><br><span class="line">            #pdb.set_trace()</span><br><span class="line">            #loss = criterion(outputs, labels)</span><br><span class="line">            loss,lm,glm,clm = lossfunc_details(outputs,labels)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            #print(torch.cat([outputs.detach().view(1,5),labels.view(1,5)],0).view(2,5))</span><br><span class="line">            if iter % 10 == 0:</span><br><span class="line">            #    print(torch.cat([outputs.detach().view(1,5),labels.view(1,5)],0).view(2,5))</span><br><span class="line">                print(&quot;epoch&#123;&#125;, iter&#123;&#125;, loss: &#123;&#125;, lr: &#123;&#125;&quot;.format(epoch, iter, loss.data.item(),optimizer.state_dict()[&#x27;param_groups&#x27;][0][&#x27;lr&#x27;]))</span><br><span class="line">        </span><br><span class="line">        #print(&quot;Finish epoch &#123;&#125;, time elapsed &#123;&#125;&quot;.format(epoch, time.time() - ts))</span><br><span class="line">        #print(&quot;*&quot;*30)</span><br><span class="line">        #val(epoch)</span><br><span class="line">        scheduler.step()</span><br></pre></td></tr></table></figure><p>训练过程比较常规，先取1个batch的训练数据，分别得到inputs和labels，依次计算loss，反传，step等。</p><p>下面说下2个训练集的数据处理函数：</p><p>input_process：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def input_process(batch):</span><br><span class="line">    #import pdb</span><br><span class="line">    #pdb.set_trace()</span><br><span class="line">    batch_size=len(batch[0])</span><br><span class="line">    input_batch= torch.zeros(batch_size,3,448,448)</span><br><span class="line">    for i in range(batch_size):</span><br><span class="line">        inputs_tmp = Variable(batch[0][i])</span><br><span class="line">        inputs_tmp1=cv2.resize(inputs_tmp.permute([1,2,0]).numpy(),(448,448))</span><br><span class="line">        inputs_tmp2=torch.tensor(inputs_tmp1).permute([2,0,1])</span><br><span class="line">        input_batch[i:i+1,:,:,:]= torch.unsqueeze(inputs_tmp2,0)</span><br><span class="line">    return input_batch </span><br></pre></td></tr></table></figure><blockquote><p>batch[0]为image，batch[1]为label，batch_size为1个batch的图片数量。<br>batch[0][i]为这个batch的第i张图片，inputs_tmp2为尺寸变成了3,448,448之后的图片，再经过unsqueeze操作拓展1维，size=[1,3,448,448]，存储在input_batch中。</p></blockquote><p>最后，返回的是size=[batch_size,3,448,448]的输入数据。</p><p>target_process：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def target_process(batch,grid_number=7):</span><br><span class="line">    # batch[1]表示label</span><br><span class="line">    # batch[0]表示image</span><br><span class="line">    batch_size=len(batch[0])</span><br><span class="line">    target_batch= torch.zeros(batch_size,grid_number,grid_number,30)</span><br><span class="line">    #import pdb</span><br><span class="line">    #pdb.set_trace()</span><br><span class="line">    for i in range(batch_size):</span><br><span class="line">        labels = batch[1]</span><br><span class="line">        batch_labels = labels[i]</span><br><span class="line">        #import pdb</span><br><span class="line">        #pdb.set_trace()</span><br><span class="line">        number_box = len(batch_labels[&#x27;boxes&#x27;])</span><br><span class="line">        for wi in range(grid_number):</span><br><span class="line">            for hi in range(grid_number):</span><br><span class="line">                # 遍历每个标注的框</span><br><span class="line">                for bi in range(number_box):</span><br><span class="line">                    bbox=batch_labels[&#x27;boxes&#x27;][bi]</span><br><span class="line">                    _,himg,wimg = batch[0][i].numpy().shape</span><br><span class="line">                    bbox = bbox/ torch.tensor([wimg,himg,wimg,himg])</span><br><span class="line">                    #import pdb</span><br><span class="line">                    #pdb.set_trace()</span><br><span class="line">                    center_x= (bbox[0]+bbox[2])*0.5</span><br><span class="line">                    center_y= (bbox[1]+bbox[3])*0.5</span><br><span class="line">                    #print(&quot;[%s,%s,%s],[%s,%s,%s]&quot;%(wi/grid_number,center_x,(wi+1)/grid_number,hi/grid_number,center_y,(hi+1)/grid_number))</span><br><span class="line">                    if center_x&lt;=(wi+1)/grid_number and center_x&gt;=wi/grid_number and center_y&lt;=(hi+1)/grid_number and center_y&gt;= hi/grid_number:</span><br><span class="line">                        #pdb.set_trace()</span><br><span class="line">                        cbbox =  torch.cat([torch.ones(1),bbox])</span><br><span class="line">                        # 中心点落在grid内，</span><br><span class="line">                        target_batch[i:i+1,wi:wi+1,hi:hi+1,:] = torch.unsqueeze(cbbox,0)</span><br><span class="line">                    #else:</span><br><span class="line">                        #cbbox =  torch.cat([torch.zeros(1),bbox])</span><br><span class="line">                #import pdb</span><br><span class="line">                #pdb.set_trace()</span><br><span class="line">                #rint(target_batch[i:i+1,wi:wi+1,hi:hi+1,:])</span><br><span class="line">                #target_batch[i:i+1,wi:wi+1,hi:hi+1,:] = torch.unsqueeze(cbbox,0)</span><br><span class="line">    return target_batch</span><br></pre></td></tr></table></figure><blockquote><p>要从batch里面获得label，首先要想清楚label(就是bounding box)应该是什么size，输出的结果应该是 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7%5Ctimes30" alt="[公式]"> 的，所以label的size应该是：[batch_size,7,7,30]。在这个程序里我们实现的是输出 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7%5Ctimes5" alt="[公式]"> 。这个 <img src="https://www.zhihu.com/equation?tex=5" alt="[公式]"> 就是x,y,w,h，所以label的size应该是：[batch_size,7,7,5]<br>batch_labels表示这个batch的第i个图片的label，number_box表示这个图有几个真值框。<br>接下来3重循环遍历每个grid的每个框，bbox表示正在遍历的这个框。<br>bbox = bbox/ torch.tensor([wimg,himg,wimg,himg])表示对x,y,w,h进行归一化。<br>接下来if语句得到confidence的真值，存储在target_batch中返回。</p></blockquote><p>最后是loss函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">def lossfunc_details(outputs,labels):</span><br><span class="line">    # 判断维度</span><br><span class="line">    assert ( outputs.shape == labels.shape),&quot;outputs shape[%s] not equal labels shape[%s]&quot;%(outputs.shape,labels.shape)</span><br><span class="line">    #import pdb</span><br><span class="line">    #pdb.set_trace()</span><br><span class="line">    b,w,h,c = outputs.shape</span><br><span class="line">    loss = 0</span><br><span class="line">    #import pdb</span><br><span class="line">    #pdb.set_trace()</span><br><span class="line">    conf_loss_matrix = torch.zeros(b,w,h)</span><br><span class="line">    geo_loss_matrix = torch.zeros(b,w,h)</span><br><span class="line">    loss_matrix = torch.zeros(b,w,h)</span><br><span class="line">    </span><br><span class="line">    for bi in range(b):</span><br><span class="line">        for wi in range(w):</span><br><span class="line">            for hi in range(h):</span><br><span class="line">                #import pdb</span><br><span class="line">                #pdb.set_trace()</span><br><span class="line">                # detect_vector=[confidence,x,y,w,h]</span><br><span class="line">                detect_vector = outputs[bi,wi,hi]</span><br><span class="line">                gt_dv = labels[bi,wi,hi]</span><br><span class="line">                conf_pred = detect_vector[0]</span><br><span class="line">                conf_gt = gt_dv[0]</span><br><span class="line">                x_pred = detect_vector[1]</span><br><span class="line">                x_gt = gt_dv[1]</span><br><span class="line">                y_pred = detect_vector[2]</span><br><span class="line">                y_gt = gt_dv[2]</span><br><span class="line">                w_pred = detect_vector[3]</span><br><span class="line">                w_gt = gt_dv[3]</span><br><span class="line">                h_pred = detect_vector[4]</span><br><span class="line">                h_gt = gt_dv[4]</span><br><span class="line">                loss_confidence = (conf_pred-conf_gt)**2 </span><br><span class="line">                #loss_geo = (x_pred-x_gt)**2 + (y_pred-y_gt)**2 + (w_pred**0.5-w_gt**0.5)**2 + (h_pred**0.5-h_gt**0.5)**2</span><br><span class="line">            </span><br><span class="line">                loss_geo = (x_pred-x_gt)**2 + (y_pred-y_gt)**2 + (w_pred-w_gt)**2 + (h_pred-h_gt)**2</span><br><span class="line">                loss_geo = conf_gt*loss_geo</span><br><span class="line">                loss_tmp = loss_confidence + 0.3*loss_geo</span><br><span class="line">                #print(&quot;loss[%s,%s] = %s,%s&quot;%(wi,hi,loss_confidence.item(),loss_geo.item()))</span><br><span class="line">                loss += loss_tmp</span><br><span class="line">                conf_loss_matrix[bi,wi,hi]=loss_confidence</span><br><span class="line">                geo_loss_matrix[bi,wi,hi]=loss_geo</span><br><span class="line">                loss_matrix[bi,wi,hi]=loss_tmp</span><br><span class="line">    #打印出batch中每张片的位置loss,和置信度输出</span><br><span class="line">    print(geo_loss_matrix)</span><br><span class="line">    print(outputs[0,:,:,0]&gt;0.5)</span><br><span class="line">    return loss,loss_matrix,geo_loss_matrix,conf_loss_matrix</span><br></pre></td></tr></table></figure><blockquote><p>首先需要注意：label和output的size应该是：[batch_size,7,7,5]。<br>outputs[bi,wi,hi]就是一个5位向量： <img src="https://www.zhihu.com/equation?tex=%28c%5E%7Bpred%7D%2Cx%5E%7Bpred%7D%2Cy%5E%7Bpred%7D%2Cw%5E%7Bpred%7D%2Ch%5E%7Bpred%7D%29" alt="[公式]"> 。<br>我们分别计算了loss_confidence和loss_geo，因为我们实现的这个模型只检测1个类，所以没有class_loss。</p></blockquote><p>为了使本文<strong>尽量生动有趣</strong>，我仍然用葫芦娃作为例子展示YOLO的过程(真的是尽力了。。。)。</p><p><img src="https://pic2.zhimg.com/80/v2-6f33f7b365e952d0cb1436c540135a0d_720w.jpg" alt="img">葫芦娃</p><p>下面进入正题，首先回顾下YOLO v1的模型结构，忘记了的同学请看上面的文章<strong>并点赞</strong>，如下面2图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-adc371c1de58af018e9b097f73105b4c_720w.jpg" alt="img">YOLO</p><p><img src="https://pic2.zhimg.com/80/v2-3c018cd25d7e0f696bdf78e64da76655_720w.jpg" alt="img">YOLO</p><p>我们认为，<strong>检测模型=特征提取器+检测头</strong></p><p>在YOLO v1的模型中检测头就是最后的2个全连接层(Linear in PyTorch)，它们是参数量最大的2个层，也是最值得改进的2个层。后面的YOLO模型都对这里进行改进：</p><p>YOLO v1一共预测49个目标，一共98个框。</p><h2 id="5-YOLO-v2">5 YOLO v2</h2><ul><li><strong>检测头的改进：</strong></li></ul><p>YOLO v1虽然快，但是预测的框不准确，很多目标找不到：</p><ul><li><strong>预测的框不准确：准确度不足。</strong></li><li><strong>很多目标找不到：recall不足。</strong></li></ul><p>我们一个问题一个问题解决，首先第1个：</p><ul><li><strong>问题1：预测的框不准确：</strong></li></ul><p><strong>当时别人是怎么做的？</strong></p><p>同时代的检测器有R-CNN，人家预测的是偏移量。</p><p>什么是偏移量？</p><p><img src="https://pic4.zhimg.com/80/v2-4883b178ed0e2bb95f1d504dc6bed6a7_720w.jpg" alt="img">YOLO v2</p><p>之前YOLO v1直接预测x,y,w,h，范围比较大，现在我们想预测一个稍微小一点的值，来增加准确度。</p><p>不得不先介绍2个新概念：<strong>基于grid的偏移量和基于anchor的偏移量</strong>。什么意思呢？</p><p><strong>基于anchor的偏移量</strong>的意思是，anchor的位置是固定的，<strong>偏移量=目标位置-anchor的位置</strong>。</p><p><strong>基于grid的偏移量</strong>的意思是，grid的位置是固定的，<strong>偏移量=目标位置-grid的位置</strong>。</p><p><strong>Anchor是什么玩意？</strong></p><p>Anchor是R-CNN系列的一个概念，你可以把它理解为一个预先定义好的框，它的位置，宽高都是已知的，是一个参照物，供我们预测时参考。</p><p>上面的图就是YOLO v2给出的改进，你可能现在看得一脸懵逼，我先解释下各个字母的含义：</p><p><img src="https://www.zhihu.com/equation?tex=b_%7Bx%7D%2Cb_%7By%7D%2Cb_%7Bw%7D%2Cb_%7Bh%7D" alt="[公式]"> ：模型最终得到的的检测结果。</p><p><img src="https://www.zhihu.com/equation?tex=t_%7Bx%7D%2Ct_%7By%7D%2Ct_%7Bw%7D%2Ct_%7Bh%7D" alt="[公式]"> ：模型要预测的值。</p><p><img src="https://www.zhihu.com/equation?tex=c_%7Bx%7D%2Cc_%7By%7D" alt="[公式]"> ：grid的左上角坐标，如下图所示。</p><p><img src="https://www.zhihu.com/equation?tex=p_%7Bw%7D%2Cp_%7Bh%7D" alt="[公式]"> ：Anchor的宽和高，这里的anchor是人为定好的一个框，宽和高是固定的。</p><p><img src="https://pic1.zhimg.com/80/v2-cc3885ebc9f24892cf30c58c564044c0_720w.jpg" alt="img"></p><p>通过这样的定义我们从<strong>直接预测位置</strong>改为<strong>预测一个偏移量</strong>，基于<strong>Anchor框的宽和高</strong>和<strong>grid的先验位置</strong>的<strong>偏移量</strong>，得到最终目标的位置，这种方法也叫作<strong>location prediction</strong>。</p><p><strong>这里还涉及到一个尺寸问题：</strong></p><p>刚才说到 <img src="https://www.zhihu.com/equation?tex=t_%7Bx%7D%2Ct_%7By%7D%2Ct_%7Bw%7D%2Ct_%7Bh%7D" alt="[公式]"> 是模型要预测的值，这里 <img src="https://www.zhihu.com/equation?tex=c_%7Bx%7D%2Cc_%7By%7D" alt="[公式]"> 为grid的坐标，画个图就明白了：</p><p><img src="https://pic3.zhimg.com/80/v2-e31634384bb34bbbb1de0e8ddfc5ddc2_720w.jpg" alt="img">图1：原始值</p><p>如图1所示，假设此图分为9个grid，GT如红色的框所示，Anchor如紫色的框所示。图中的数字为image的真实信息。</p><p>我们首先会对这些值<strong>归一化</strong>，结果如下图2所示：</p><p><img src="https://pic3.zhimg.com/80/v2-63ca4ed417c5db83b18c95a42a7f60f2_720w.jpg" alt="img">图2：要预测的值</p><p>归一化之后你会发现，要预测的值就变为了：</p><p><img src="https://www.zhihu.com/equation?tex=t_%7Bx%7D%2Ct_%7By%7D%2Ct_%7Bw%7D%2Ct_%7Bh%7D%3D0.172%2C-0.148%2C-0.340%2C-0.326" alt="[公式]"></p><p>这是一个偏移量，且值很小，有利于神经网络的学习。</p><p>**你可能会有疑问：**为什么YOLO v2改预测偏移量而不是直接去预测 <img src="https://www.zhihu.com/equation?tex=%28x%2Cy%2Cw%2Ch%29" alt="[公式]"> ？</p><p>上面我说了作者看到了同时代的R-CNN，人家预测的是偏移量。另一个重要的原因是：直接预测位置会导致神经网络在一开始训练时不稳定，使用偏移量会使得训练过程更加稳定，性能指标提升了5%左右。</p><p>位置上不使用Anchor框，宽高上使用Anchor框。以上就是YOLO v2的一个改进。用了YOLO v2的改进之后确实是更准确了，但别激动，上面还有一个问题呢~</p><ul><li><strong>问题2：很多目标找不到：</strong></li></ul><p>你还记得上一篇讲得<strong>YOLO v1一次能检测多少个目标吗</strong>？答案是<strong>49个目标</strong>，98个框，并且2个框对应一个类别。可以是大目标也可以是小目标。因为输出的尺寸是：[N, 7, 7, 30]。式中N为图片数量，7,7为49个区域(grid)。</p><p><img src="https://www.zhihu.com/equation?tex=30%3D2%5Ctimes5%28c%2Cx%2Cy%2Cw%2Ch%29%2B1%5Ctimes20+classes" alt="[公式]"></p><p>YOLO v2首先把 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> 个区域改为 <img src="https://www.zhihu.com/equation?tex=13%5Ctimes13" alt="[公式]"> 个区域，每个区域有5个anchor，且每个anchor对应着1个类别，那么，输出的尺寸就应该为：[N,13,13,125]。</p><p><img src="https://www.zhihu.com/equation?tex=125%3D5%5Ctimes5%28c%2Cx%2Cy%2Cw%2Ch%29%2B5%5Ctimes20+classes" alt="[公式]"></p><p>这里面有个bug，就是YOLO v2先对每个区域得到了5个anchor作为参考，那你就会问2个问题：</p><p><strong>1.为什么要用Anchor呢？</strong></p><p><strong>答：一开始YOLO v1的初始训练过程很不稳定</strong>，在YOLO v2中，作者观察了很多图片的所有Ground Truth，发现：比如车，GT都是矮胖的长方形，再比如行人，GT都是瘦高的长方形，且宽高比具有相似性。那**能不能根据这一点，从数据集中预先准备几个几率比较大的bounding box，再以它们为基准进行预测呢？**这就是Anchor的初衷。</p><p><strong>2.每个区域的5个anchor是如何得到的？</strong></p><p>下图可以回答你的问题：</p><p><img src="https://pic1.zhimg.com/80/v2-7e157d61f41ca02634f06b0b78c71684_720w.jpg" alt="img">methods to get the 5 anchor</p><p>方法：对于任意一个数据集，就比如说COCO吧(紫色的anchor)，先对训练集的GT bounding box进行聚类，聚成几类呢？作者进行了实验之后发现<strong>5</strong>类的<strong>recall vs. complexity</strong>比较好，现在聚成了<strong>5</strong>类，当然9类的mAP最好，预测的最全面，但是在复杂度上升很多的同时对模型的准确度提升不大，所以采用了一个比较折中的办法选取了5个聚类簇，即使用5个先验框。</p><p>所以到现在为止，有了anchor再结合刚才的 <img src="https://www.zhihu.com/equation?tex=t_%7Bx%7D%2Ct_%7By%7D%2Ct_%7Bw%7D%2Ct_%7Bh%7D" alt="[公式]"> ，就可以求出目标位置。</p><p><strong>anchor是从数据集中统计得到的(Faster-RCNN中的Anchor的宽高和大小是手动挑选的)。</strong></p><ul><li><strong>损失函数为：</strong></li></ul><p><img src="https://pic1.zhimg.com/80/v2-faed5df5818795d5fc047815f0338768_720w.jpg" alt="img">YOLO v2损失函数</p><blockquote><p>这里的W=13,H=13,A=5。<br>每个 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="[公式]"> 都是一个权重值。c表示类别，r表示rectangle，即(x,y,w,h)。<br>第1,4行是confidence_loss，注意这里的真值变成了0和IoU(GT, anchor)的值，你看看这些细节。。。<br>第5行是class_loss。<br>第2,3行：t是迭代次数，即前12800步我们计算这个损失，后面不计算了。这部分意义何在？<br>意思是：前12800步我们会优化<strong>预测的(x,y,w,h)与anchor的(x,y,w,h)的距离+预测的(x,y,w,h)与GT的(x,y,w,h)的距离</strong>，12800步之后就只优化<strong>预测的(x,y,w,h)与GT的(x,y,w,h)的距离，为啥？因为这时的预测结果已经较为准确了，anchor已经满足我了我们了，而在一开始预测不准的时候，用上anchor可以加速训练。</strong><br><strong>你看看这操作多么的细节。。。</strong><br><img src="https://www.zhihu.com/equation?tex=1_%7Bk%7D%5E%7Btruth%7D" alt="[公式]"> 是什么？第k个anchor与所有GT的IoU的maximum，如果大于一个阈值，就 <img src="https://www.zhihu.com/equation?tex=1_%7Bk%7D%5E%7Btruth%7D%3D1" alt="[公式]"> ，否则的话： <img src="https://www.zhihu.com/equation?tex=1_%7Bk%7D%5E%7Btruth%7D%3D0" alt="[公式]"> 。</p></blockquote><p>好，到现在为止，YOLO v2做了这么多改进，整体性能大幅度提高，但是小目标检测仍然是YOLO v2的痛。直到kaiming大神的ResNet出现，backbone可以更深了，所以darknet53诞生。</p><p>最后我们做个比较：</p><p><img src="https://pic1.zhimg.com/80/v2-e4dce0794b6d4aa5a67133633baed6b4_720w.jpg" alt="img">YOLO v1和v2的比较</p><hr><h2 id="6-YOLO-v3">6 YOLO v3</h2><ul><li><strong>检测头的改进：</strong></li></ul><p>之前在说小目标检测仍然是YOLO v2的痛，YOLO v3是如何改进的呢？如下图所示。</p><p><img src="https://pic1.zhimg.com/80/v2-4cf1b6f6afec393122305ca2bb2725a4_720w.jpg" alt="img">YOLO v3</p><p>我们知道，YOLO v2的检测头已经由YOLO v1的 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> 变为 <img src="https://www.zhihu.com/equation?tex=13%5Ctimes13" alt="[公式]">了，我们看YOLO v3检测头分叉了，分成了3部分：</p><ul><li>13<em>13</em>3*(4+1+80)</li><li>26<em>26</em>3*(4+1+80)</li><li>52<em>52</em>3*(4+1+80)</li></ul><p>预测的框更多更全面了，并且分级了。</p><p>我们发现3个分支分别为<strong>32倍下采样，16倍下采样，8倍下采样</strong>，分别取预测<strong>大，中，小目标</strong>。为什么这样子安排呢？</p><p>因为<strong>32倍下采样</strong>每个点感受野更大，所以去预测<strong>大目标，8倍下采样</strong>每个点感受野最小，所以去预测<strong>小目标。专人专事。</strong></p><p><strong>发现预测地更准确了，性能又提升了。</strong></p><p>又有人会问，你现在是3个分支，我改成5个，6个分支会不会更好？</p><p>理论上会，但还是那句话，作者遵循recall vs. complexity的trade off。</p><p>图中的123456789是什么意思？</p><p><strong>答：框</strong>。每个grid设置9个先验框，3个大的，3个中的，3个小的。</p><p>每个分支预测3个框，每个框预测5元组+80个one-hot vector类别，所以一共size是：</p><p><strong>3*(4+1+80)</strong></p><p><strong>每个分支的输出size为：</strong></p><ul><li><strong>[13,13,3*(4+1+80)]</strong></li><li><strong>[26,26,3*(4+1+80)]</strong></li><li><strong>[52,52,3*(4+1+80)]</strong></li></ul><p><strong>当然你也可以用5个先验框，这时每个分支的输出size为：</strong></p><ul><li><strong>[13,13,5*(4+1+80)]</strong></li><li><strong>[26,26,5*(4+1+80)]</strong></li><li><strong>[52,52,5*(4+1+80)]</strong></li></ul><p><strong>读到这里，请你数一下YOLO v3可以预测多少个bounding box？</strong></p><p><img src="https://www.zhihu.com/equation?tex=%2813%5Ctimes13%2B26%5Ctimes26%2B52%5Ctimes52%29%5Ctimes3%3D10467%28YOLO+v3%29%3E%3E845%28YOLO+v2%29%3D13%5Ctimes13%5Ctimes5" alt="[公式]"></p><p>多了这么多可以预测的bounding box，模型的能力增强了。</p><p><strong>为确定priors</strong>，YOLO v3 应用<strong>k均值聚类</strong>。然后它<strong>预先选择9个聚类簇</strong>。</p><p>对于<strong>COCO数据集</strong>，锚定框的宽度和高为**(10 ×13)，(16 ×30)，(33 ×23)，(30 ×61)，(62 ×45)，(59 ×119)，(116 × 90)，( 156 ×198)，(373373×326326)**。这应该是按照输入图像的尺寸416×416 计算得到的。这 9个priors根据它们的尺度分为3个不同的组。在检测目标时，给一特定的特征图分配一个组。</p><p>就对应了下面这个图：</p><p><img src="https://pic4.zhimg.com/80/v2-24ff3cd5062021493490e28e7d73d6bf_720w.jpg" alt="img">YOLO v3</p><p>检测头是<strong>DBL</strong>，定义在图上，没有了FC。</p><p>还有一种画法，更加直观一点：</p><p><img src="https://pic3.zhimg.com/80/v2-085b6d95dc53894e5de4fe95d2249b06_720w.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-151886b99cf8a93f116cd845a4524c89_720w.jpg" alt="img">YOLO v3 head</p><p><strong>anchor和YOLO v2一样，依然是从数据集中统计得到的。</strong></p><ul><li><strong>损失函数为：</strong></li></ul><p><img src="https://pic4.zhimg.com/80/v2-1714579e2a7f9ca88335bdaeae9e1c4f_720w.jpg" alt="img">YOLO v3损失函数</p><blockquote><p>第4行说明：loss分3部分组成：<br>第1行代表geo_loss，S代表13,26,52，就是grid是几乘几的。B=5。<br>第2行代表confidence_loss，和YOLO v2一模一样。<br>第3行代表class_loss，和YOLO v2的区别是改成了交叉熵。</p></blockquote><ul><li><strong>边界框预测和代价函数的计算：</strong></li></ul><p>YOLO v3使用多标签分类，用多个独立的logistic分类器代替softmax函数，以计算输入属于特定标签的可能性。在计算分类损失进行训练时，YOLO v3对每个标签使用二元交叉熵损失。</p><p><strong>正负样本的确定：</strong></p><blockquote><p>如果<strong>边界框先验（锚定框）与 GT 目标比其他目标重叠多</strong>，则相应的<strong>目标性得分应为 1</strong>。<br>对于<strong>重叠大于等于0.5的其他先验框(anchor)</strong>，忽略，<strong>不算损失</strong>。<br>每个 GT 目标<strong>仅与一个先验边界框相关联</strong>。 如果没有分配先验边界框，则不会导致<strong>分类和定位损失，只会有目标性的置信度损失。</strong><br>使用**tx和ty(<strong>而不是 bx 和by</strong>)**来计算损失。</p></blockquote><p><img src="https://pic2.zhimg.com/80/v2-1e31f33f86d3f2bb9c7d516efd974765_720w.jpg" alt="img">使用tx和ty(而不是 bx 和by)来计算损失</p><p><img src="https://pic1.zhimg.com/80/v2-5b4352b9a3138190717febf40e5f0384_720w.png" alt="img">交叉熵损失</p><p><strong>总结起来就是下面4句话：</strong></p><ul><li>正样本：与GT的IOU最大的框。</li><li>负样本：与GT的IOU&lt;0.5 的框。</li><li>忽略的样本：与GT的IOU&gt;0.5 但不是最大的框。</li><li>使用 tx 和ty （而不是 bx 和by ）来计算损失。</li></ul><p>最后我们做个比较：</p><p><img src="https://pic4.zhimg.com/80/v2-e35154c0fe812a210295ca8c3cd92df3_720w.jpg" alt="img">YOLO v1 v2和v3的比较</p><hr><h2 id="7-疫情都挡不住的YOLO-v4">7 疫情都挡不住的YOLO v4</h2><p>第一次看到YOLO v4公众号发文是在疫情期间，那时候还来不了学校。不得不说疫情也挡不住作者科研的动力。</p><ul><li><strong>检测头的改进：</strong></li></ul><p>YOLO v4的作者换成了Alexey Bochkovskiy大神，检测头总的来说还是多尺度的，3个尺度，分别负责大中小目标。只不过多了一些细节的改进：</p><p><strong>1.Using multi-anchors for single ground truth</strong></p><p>之前的YOLO v3是1个anchor负责一个GT，YOLO v4中用多个anchor去负责一个GT。方法是：对于 <img src="https://www.zhihu.com/equation?tex=GT_%7Bj%7D" alt="[公式]"> 来说，只要 <img src="https://www.zhihu.com/equation?tex=IoU%28anchor_%7Bi%7D%2CGT_%7Bj%7D%29%3Ethreshold" alt="[公式]"> ，就让 <img src="https://www.zhihu.com/equation?tex=anchor_%7Bi%7D" alt="[公式]"> 去负责 <img src="https://www.zhihu.com/equation?tex=GT_%7Bj%7D" alt="[公式]"> 。</p><p>这就相当于你anchor框的数量没变，但是选择的<strong>正样本</strong>的比例增加了，就<strong>缓解了正负样本不均衡的问题</strong>。</p><p><strong>2.Eliminate_grid sensitivity</strong></p><p>还记得之前的YOLO v2的这幅图吗？YOLO v2，YOLO v3都是预测4个这样的偏移量</p><p><img src="https://pic3.zhimg.com/80/v2-63ca4ed417c5db83b18c95a42a7f60f2_720w.jpg" alt="img">图3：YOLO v2，YOLO v3要预测的值</p><p>这里其实还隐藏着一个问题：</p><p>模型预测的结果是： <img src="https://www.zhihu.com/equation?tex=t_%7Bx%7D%2Ct_%7By%7D%2Ct_%7Bw%7D%2Ct_%7Bh%7D" alt="[公式]"> ，那么最终的结果是： <img src="https://www.zhihu.com/equation?tex=b_%7Bx%7D%2Cb_%7By%7D%2Cb_%7Bw%7D%2Cb_%7Bh%7D" alt="[公式]"> 。这个 <img src="https://www.zhihu.com/equation?tex=b" alt="[公式]"> 按理说应该能取到一个grid里面的任意位置。但是实际上边界的位置是取不到的，因为sigmoid函数的值域是： <img src="https://www.zhihu.com/equation?tex=%280%2C1%29" alt="[公式]"> ，它不是 <img src="https://www.zhihu.com/equation?tex=%5B0%2C1%5D" alt="[公式]"> 。所以作者提出的Eliminate_grid sensitivity的意思是：将 <img src="https://www.zhihu.com/equation?tex=b_%7Bx%7D%2Cb_%7By%7D" alt="[公式]"> 的计算公式改为：</p><p><img src="https://www.zhihu.com/equation?tex=b_%7Bx%7D%3D1.1%5Ccdot%5Csigma%28t_%7Bx%7D%29%2Bc_%7Bx%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=b_%7By%7D%3D1.1%5Ccdot%5Csigma%28t_%7By%7D%29%2Bc_%7By%7D" alt="[公式]"></p><p>这里的1.1就是一个示例，你也可以是1.05,1.2等等，反正要乘上一个略大于1的数，作者发现经过这样的改动以后效果会再次提升。</p><p><strong>3.CIoU-loss</strong></p><p>之前的YOLO v2，YOLO v3在计算geo_loss时都是用的MSE Loss，之后人们开始使用IoU Loss。</p><p><img src="https://www.zhihu.com/equation?tex=L_%7BIoU%7D%3D1-%5Cfrac%7B%7CB%5Ccap+B_%7Bgt%7D%7C%7D%7B%7CB%5Ccup+B_%7Bgt%7D%7C%7D" alt="[公式]"> 它可以反映预测检测框与真实检测框的检测效果。</p><p>但是问题也很多：不能反映两者的距离大小（重合度）。同时因为loss=0，**当GT和bounding box不挨着时，没有梯度回传，无法进行学习训练。**如下图4所示，三种情况IoU都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差：</p><p><img src="https://pic2.zhimg.com/80/v2-a52e8fc7166b29c08b80de1ead22ec79_720w.jpg" alt="img">图4：IoU Loss不能反映两者的距离大小</p><ul><li><strong>所以接下来的改进是：</strong></li></ul><p><img src="https://www.zhihu.com/equation?tex=L_%7BGIoU%7D%3D1-IoU%2B%5Cfrac%7B%7CC-B%5Ccup+B_%7Bgt%7D%7C%7D%7B%7CC%7C%7D" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=C" alt="[公式]"> 为同时包含了预测框和真实框的最小框的面积。</p><p><img src="https://pic1.zhimg.com/80/v2-4ccbf64fa4eefb0e321809a803f90c74_720w.jpg" alt="img">图4：GIoU Loss</p><p>GIoU Loss可以解决上面IoU Loss对距离不敏感的问题。但是GIoU Loss存在训练过程中发散等问题。</p><ul><li><strong>接下来的改进是：</strong></li></ul><p><img src="https://www.zhihu.com/equation?tex=L_%7BDIoU%7D+%3D+1-IoU+%2B+%5Cfrac%7B%5Crho%5E%7B2%7D%28b%2Cb%5E%7Bgt%7D%29%7D%7Bc%5E%7B2%7D%7D" alt="[公式]"></p><p>其中， <img src="https://www.zhihu.com/equation?tex=b" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=b%5E%7Bgt%7D" alt="[公式]"> 分别代表了预测框和真实框的中心点，且<img src="https://www.zhihu.com/equation?tex=%5Crho" alt="[公式]">代表的是计算两个中心点间的欧式距离。<img src="https://www.zhihu.com/equation?tex=c" alt="[公式]">代表的是能够同时包含预测框和真实框的<strong>最小闭包区域</strong>的对角线距离。</p><p><img src="https://pic1.zhimg.com/80/v2-2345aacc478cc5523d439ffcd84958ac_720w.jpg" alt="img">图5：DIoU Loss</p><p><strong>DIoU loss</strong>可以直接最小化两个目标框的距离，因此比GIoU loss收敛快得多。</p><p><strong>DIoU loss除了这一点之外，还有一个好处是：</strong></p><p><img src="https://pic3.zhimg.com/80/v2-3db202166e0c206001ca03e191489532_720w.jpg" alt="img">IoU Loss和GIoU loss都一样时</p><p>如上图所示，此3种情况IoU Loss和GIoU loss都一样，但是DIoU Loss右图最小，中间图次之，左图最大。</p><p>这里就是一道面试题：<strong>请总结DIoU loss的好处是？</strong></p><p><strong>答：</strong></p><ul><li>收敛快(需要的epochs少)。</li><li>缓解了Bounding box全包含GT问题。</li></ul><p><strong>但是</strong>DIoU loss只是<strong>缓解了Bounding box全包含GT问题</strong>，<strong>依然没有彻底解决包含的问题</strong>，即：</p><p><img src="https://pic4.zhimg.com/80/v2-96838980b7fd4443661cf0019802ea7b_720w.jpg" alt="img"></p><p>这2种情况<img src="https://www.zhihu.com/equation?tex=b" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=b%5E%7Bgt%7D" alt="[公式]">是重合的，DIoU loss的第3项没有区别，所以在这个意义上DIoU loss依然存在问题。</p><ul><li><strong>接下来的改进是：</strong></li></ul><p>惩罚项如下面公式：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BR%7D_%7BC+I+o+U%7D%3D%5Cfrac%7B%5Crho%5E%7B2%7D%5Cleft%28%5Cmathbf%7Bb%7D%2C+%5Cmathbf%7Bb%7D%5E%7Bg+t%7D%5Cright%29%7D%7Bc%5E%7B2%7D%7D%2B%5Calpha+v" alt="[公式]"> 其中 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]"> 是权重函数，</p><p>而 <img src="https://www.zhihu.com/equation?tex=%5Cnu" alt="[公式]"> 用来度量长宽比的相似性，定义为<img src="https://www.zhihu.com/equation?tex=v%3D%5Cfrac%7B4%7D%7B%5Cpi%5E%7B2%7D%7D%5Cleft%28%5Carctan+%5Cfrac%7Bw%5E%7Bg+t%7D%7D%7Bh%5E%7Bg+t%7D%7D-%5Carctan+%5Cfrac%7Bw%7D%7Bh%7D%5Cright%29%5E%7B2%7D" alt="[公式]"></p><p>完整的 CIoU 损失函数定义：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathcal%7BL%7D_%7BC+I+o+U%7D%3D1-I+o+U%2B%5Cfrac%7B%5Crho%5E%7B2%7D%5Cleft%28%5Cmathbf%7Bb%7D%2C+%5Cmathbf%7Bb%7D%5E%7Bg+t%7D%5Cright%29%7D%7Bc%5E%7B2%7D%7D%2B%5Calpha+v" alt="[公式]"></p><p>最后，CIoU loss的梯度类似于DIoU loss，但还要考虑 <img src="https://www.zhihu.com/equation?tex=%5Cnu" alt="[公式]"> 的梯度。在长宽在 <img src="https://www.zhihu.com/equation?tex=%5B0%2C1%5D" alt="[公式]"> 的情况下， <img src="https://www.zhihu.com/equation?tex=w%5E%7B2%7D%2Bh%5E%7B2%7D" alt="[公式]"> 的值通常很小，会导致梯度爆炸，因此在 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7Bw%5E%7B2%7D%2Bh%5E%7B2%7D%7D" alt="[公式]"> 实现时将替换成1。</p><p>CIoU loss实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">def bbox_overlaps_ciou(bboxes1, bboxes2):</span><br><span class="line">    rows = bboxes1.shape[0]</span><br><span class="line">    cols = bboxes2.shape[0]</span><br><span class="line">    cious = torch.zeros((rows, cols))</span><br><span class="line">    if rows * cols == 0:</span><br><span class="line">        return cious</span><br><span class="line">    exchange = False</span><br><span class="line">    if bboxes1.shape[0] &gt; bboxes2.shape[0]:</span><br><span class="line">        bboxes1, bboxes2 = bboxes2, bboxes1</span><br><span class="line">        cious = torch.zeros((cols, rows))</span><br><span class="line">        exchange = True</span><br><span class="line"></span><br><span class="line">    w1 = bboxes1[:, 2] - bboxes1[:, 0]</span><br><span class="line">    h1 = bboxes1[:, 3] - bboxes1[:, 1]</span><br><span class="line">    w2 = bboxes2[:, 2] - bboxes2[:, 0]</span><br><span class="line">    h2 = bboxes2[:, 3] - bboxes2[:, 1]</span><br><span class="line"></span><br><span class="line">    area1 = w1 * h1</span><br><span class="line">    area2 = w2 * h2</span><br><span class="line"></span><br><span class="line">    center_x1 = (bboxes1[:, 2] + bboxes1[:, 0]) / 2</span><br><span class="line">    center_y1 = (bboxes1[:, 3] + bboxes1[:, 1]) / 2</span><br><span class="line">    center_x2 = (bboxes2[:, 2] + bboxes2[:, 0]) / 2</span><br><span class="line">    center_y2 = (bboxes2[:, 3] + bboxes2[:, 1]) / 2</span><br><span class="line"></span><br><span class="line">    inter_max_xy = torch.min(bboxes1[:, 2:],bboxes2[:, 2:])</span><br><span class="line">    inter_min_xy = torch.max(bboxes1[:, :2],bboxes2[:, :2])</span><br><span class="line">    out_max_xy = torch.max(bboxes1[:, 2:],bboxes2[:, 2:])</span><br><span class="line">    out_min_xy = torch.min(bboxes1[:, :2],bboxes2[:, :2])</span><br><span class="line"></span><br><span class="line">    inter = torch.clamp((inter_max_xy - inter_min_xy), min=0)</span><br><span class="line">    inter_area = inter[:, 0] * inter[:, 1]</span><br><span class="line">    inter_diag = (center_x2 - center_x1)**2 + (center_y2 - center_y1)**2</span><br><span class="line">    outer = torch.clamp((out_max_xy - out_min_xy), min=0)</span><br><span class="line">    outer_diag = (outer[:, 0] ** 2) + (outer[:, 1] ** 2)</span><br><span class="line">    union = area1+area2-inter_area</span><br><span class="line">    u = (inter_diag) / outer_diag</span><br><span class="line">    iou = inter_area / union</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        arctan = torch.atan(w2 / h2) - torch.atan(w1 / h1)</span><br><span class="line">        v = (4 / (math.pi ** 2)) * torch.pow((torch.atan(w2 / h2) - torch.atan(w1 / h1)), 2)</span><br><span class="line">        S = 1 - iou</span><br><span class="line">        alpha = v / (S + v)</span><br><span class="line">        w_temp = 2 * w1</span><br><span class="line">    ar = (8 / (math.pi ** 2)) * arctan * ((w1 - w_temp) * h1)</span><br><span class="line">    cious = iou - (u + alpha * ar)</span><br><span class="line">    cious = torch.clamp(cious,min=-1.0,max = 1.0)</span><br><span class="line">    if exchange:</span><br><span class="line">        cious = cious.T</span><br><span class="line">    return cious</span><br></pre></td></tr></table></figure><p>所以最终的演化过程是：</p><p><strong>MSE Loss <img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> IoU Loss<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> GIoU Loss<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> DIoU Loss<img src="https://www.zhihu.com/equation?tex=%5Crightarrow" alt="[公式]"> CIoU Loss</strong></p><ul><li><strong>YOLO v4损失函数：</strong></li></ul><p>所以基于上面的改进，YOLO v4的损失函数为：</p><p><img src="https://pic3.zhimg.com/80/v2-310600feb7204188d9738fbd062567ca_720w.jpg" alt="img">YOLO v4的损失函数</p><hr><h2 id="8-代码比论文都早的YOLO-v5">8 代码比论文都早的YOLO v5</h2><ul><li><strong>检测头的改进：</strong></li></ul><p><strong>head部分没有任何改动</strong>，和yolov3和yolov4完全相同，也是三个输出头，stride分别是8,16,32，大输出特征图检测小物体，小输出特征图检测大物体。</p><p>但采用了<strong>自适应anchor，而且这个功能还可以手动打开/关掉，具体是什么意思呢？</strong></p><p>加上了自适应anchor的功能，个人感觉YOLO v5其实变成了2阶段方法。</p><p><strong>先回顾下之前的检测器得到anchor的方法：</strong></p><p><strong>Yolo v2 v3 v4：聚类得到anchor</strong>，不是完全基于anchor的，w,h是基于anchor的，而x,y是基于grid的坐标，所以人家叫<strong>location prediction</strong>。</p><p><strong>R-CNN系列：手动指定</strong>anchor的位置。</p><p><strong>基于anchor的方法是怎么用的：</strong></p><p><img src="https://pic4.zhimg.com/80/v2-5dc0cdfb531add5071abf2abc7399467_720w.jpg" alt="img">anchor是怎么用的</p><p>有了anchor的 <img src="https://www.zhihu.com/equation?tex=%28x_%7BA%7D%2Cy_%7BA%7D%2Cw_%7BA%7D%2Ch_%7BA%7D%29" alt="[公式]"> ,和我们预测的偏移量 <img src="https://www.zhihu.com/equation?tex=t_%7Bx%7D%2Ct_%7By%7D%2Ct_%7Bw%7D%2Ct_%7Bh%7D" alt="[公式]"> ，就可以计算出最终的output： <img src="https://www.zhihu.com/equation?tex=b_%7Bx%7D%2Cb_%7By%7D%2Cb_%7Bw%7D%2Cb_%7Bh%7D" alt="[公式]"> 。</p><p>之前anchor是固定的，自适应anchor利用网络的学习功能，让 <img src="https://www.zhihu.com/equation?tex=%28x_%7BA%7D%2Cy_%7BA%7D%2Cw_%7BA%7D%2Ch_%7BA%7D%29" alt="[公式]"> 也是可以学习的。我个人觉得自适应anchor策略，影响应该不是很大，除非是<strong>刚开始设置的anchor是随意设置的</strong>，一般我们都会基于实际项目数据重新运用<strong>kmean算法聚类得到anchor</strong>，这一步本身就不能少。</p><p>最后总结一下：</p><p><img src="https://pic2.zhimg.com/80/v2-34554f1fe4165e6b85d4905b925faa79_720w.jpg" alt="img">YOLO series的比较</p><p>本文只介绍了<strong>YOLO v2 v3 v4 v5</strong>对于<strong>检测头head</strong>和<strong>损失函数loss</strong>的优化，剩下的<strong>backbone</strong>方面和<strong>输入端的优化</strong>实在是写不动了，放到下一篇吧。</p><p>下面进入正题，目标检测器模型的结构如下图1所示，之前看过了YOLO v2 v3 v4 v5对于检测头和loss函数的改进，如下图2所示，下面着重介绍backbone的改进：</p><p><img src="https://pic1.zhimg.com/80/v2-8c5bac2266cf9b9b857529805511221c_720w.jpg" alt="img">图1：检测器的结构</p><p><img src="https://pic2.zhimg.com/80/v2-b641aebaf5d009504d30a1d17a5f7019_720w.jpg" alt="img">图2：YOLO系列比较</p><p>我们发现YOLO v1只是把最后的特征分成了 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> 个grid，到了YOLO v2就变成了 <img src="https://www.zhihu.com/equation?tex=13%5Ctimes13" alt="[公式]"> 个grid，再到YOLO v3 v4 v5就变成了多尺度的**(strides=8,16,32)<strong>，更加复杂了。那</strong>为什么一代比一代检测头更加复杂呢？答案是：因为它们的提特征网络更加强大了，能够支撑起检测头做更加复杂的操作。**换句话说，如果没有backbone方面的优化，你即使用这么复杂的检测头，可能性能还会更弱。所以引出了今天的话题：</p><ul><li><strong>backbone的改进：</strong></li></ul><h2 id="YOLO-v1"><strong>YOLO v1</strong></h2><p>我们先看看YOLO v1的backbone长什么样子：</p><p><img src="https://pic2.zhimg.com/80/v2-70005c21ddd8470ae5587b231987cb7d_720w.jpg" alt="img">YOLO v1 backbone</p><p>最后2层是全连接层，其他使用了大量的卷积层，网络逐渐变宽，是非常标准化的操作。注意这里面试官可能会问你一个问题：为什么都是卷积，图上要分开画出来，不写在一起？答案是：按照feature map的分辨率画出来。分辨率A变化到分辨率B的所有卷积画在了一起。因为写代码时经常会这么做，所以问这个问题的意图是看看你是否经常写代码。</p><p>然后我们看下检测类网络的结构，如下图3所示，这个图是YOLO v4中总结的：</p><p><img src="https://pic1.zhimg.com/80/v2-d2fb92212cbfb1d29bc395000602231c_720w.jpg" alt="img">图3：检测类网络的结构</p><p>YOLO v1没有Neck，Backbone是GoogLeNet，属于Dense Prediction。<strong>1阶段的检测器属于Dense Prediction，而2阶段的检测器既有Dense Prediction，又有Sparse Prediction</strong>。</p><hr><h2 id="YOLO-v2"><strong>YOLO v2</strong></h2><p>为了进一步提升性能，YOLO v2重新训练了一个darknet-19，如下图4所示：</p><p><img src="https://pic1.zhimg.com/80/v2-3ea70cd81cb6103ad41e9bb01b3114e4_720w.jpg" alt="img">图4：darknet-19</p><p>仔细观察上面的backbone的结构(双横线上方)，提出3个问题：</p><ul><li>为什么没有 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> 卷积了？只剩下了 <img src="https://www.zhihu.com/equation?tex=3%5Ctimes3" alt="[公式]"> 卷积和 <img src="https://www.zhihu.com/equation?tex=1%5Ctimes1" alt="[公式]"> 卷积了？</li></ul><p>**答：**vgg net论文得到一个结论，<img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> 卷积可以用更小的卷积代替，且<img src="https://www.zhihu.com/equation?tex=3%5Ctimes3" alt="[公式]"> 卷积更加节约参数，使模型更小。</p><p>网络可以做得更深，更好地提取到特征。为什么？因为每做一次卷积，后面都会接一个非线性的激活函数，更深意味着非线性的能力更强了。所以，你可能以后再也见不到 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> 卷积了。</p><p>另外还用了bottleneck结构(红色框)：</p><p><img src="https://www.zhihu.com/equation?tex=3%5Ctimes3" alt="[公式]"> 卷积负责扩大感受野， <img src="https://www.zhihu.com/equation?tex=1%5Ctimes1" alt="[公式]"> 卷积负责减少参数量。</p><ul><li>为什么没有FC层了？</li></ul><p>**答：**使用了GAP(Global Average Pooling)层，把 <img src="https://www.zhihu.com/equation?tex=1000%5Ctimes7%5Ctimes7" alt="[公式]"> 映射为 <img src="https://www.zhihu.com/equation?tex=1000%5Ctimes1" alt="[公式]"> ，满足了输入不同尺度的image的需求。你不管输入图片是 <img src="https://www.zhihu.com/equation?tex=224%5Ctimes224" alt="[公式]"> 还是 <img src="https://www.zhihu.com/equation?tex=256%5Ctimes256" alt="[公式]"> ，最后都给你映射为 <img src="https://www.zhihu.com/equation?tex=1000%5Ctimes1" alt="[公式]">。</p><p>这对提高检测器的性能有什么作用呢？</p><p>对于小目标的检测，之前输入图片是固定的大小的，小目标很难被检测准确；现在允许多尺度输入图片了，只要把图片放大，小目标就变成了大目标，提高检测的精度。</p><ul><li>为什么最后一层是softmax？</li></ul><p>**答：**因为backbone网络darknet-19是单独train的，是按照分类网络去train的，用的数据集是imagenet，是1000个classes，所以最后加了一个softmax层，使用cross entropy loss。</p><p><strong>接下来总结下YOLO v2的网络结构：</strong></p><ul><li>图4中的双横线的上半部分(第0-22层)为backbone，train的方法如上文。</li><li>后面的结构如下图5所示：</li></ul><p><img src="https://pic3.zhimg.com/80/v2-1498b3c3c5ebebbb31b871329bc97b2e_720w.jpg" alt="img">图5：YOLO v2网络结构</p><ul><li>从第23层开始为检测头，其实是3个 3 * 3 * 1024 的卷积层。</li><li>同时增加了一个 passthrough 层(27层)，最后使用 1 * 1 卷积层输出预测结果，输出结果的size为 <img src="https://www.zhihu.com/equation?tex=13%5Ctimes13%5Ctimes125" alt="[公式]"> 。</li><li>route层的作用是进行层的合并(concat)，后面的数字指的是合并谁和谁。</li><li>passthrough 层可以把 <img src="https://www.zhihu.com/equation?tex=26%5Ctimes26%5Ctimes64%5Crightarrow13%5Ctimes13%5Ctimes256" alt="[公式]"> 。</li></ul><p><strong>YOLO2 的训练主要包括三个阶段：</strong></p><ol><li>先在 <strong>ImageNet 分类数据集</strong>上<strong>预训练 Darknet-19</strong>，此时模型输入为 <strong>224 * 224</strong> ，共训练 160 个 epochs。(为什么可以这样训练？因为有GAP)</li><li>将网络的输入调整为 <strong>448 * 448</strong>（注意在测试的时候使用 <strong>416 * 416</strong> 大小） ，继续在 ImageNet 数据集上 <strong>finetune 分类模型</strong>，训练 10 个 epochs。注意为什么测试的时候使用大小？<strong>答案是：<strong>将输入图像大小从</strong>448 ×448</strong> 更改为 <strong>416 ×416</strong> 。这将创建<strong>奇数空间维度(<strong>7×7 v.s 8 ×8 <strong>grid cell)</strong>。 图片的中心通常被大目标占据。 对于奇数网格单元，可以更容易确定目标所属的位置。对于一些大目标，它们中心点往落入图片中心位置，此时使用特征图中心的</strong>1个cell</strong>去预测这些目标的bounding box相对容易些，否则就要用中间<strong>4个Cells</strong>来进行预测。</li><li>修改 Darknet-19 分类模型为检测模型为图5形态，即：移除最后一个卷积层、global avgpooling 层以及 softmax 层，并且新增了3个 3 * 3 * 1024 卷积层，同时增加了一个 passthrough 层，最后使用 1 * 1 卷积层输出预测结果，并在<strong>检测数据集</strong>上继续<strong>finetune</strong> 网络。</li><li>YOLO v1的训练：先使用<strong>224 * 224</strong>的分辨率训练分类网络，再切换到<strong>448 * 448</strong>的分辨率训练检测网络。而YOLO v2在使用<strong>224 * 224</strong>的分辨率训练分类网络<strong>160 epochs</strong>之后，先使用<strong>448 * 448</strong>的分辨率finetune分类网络<strong>10 epochs</strong>，再使用<strong>448 * 448</strong>的分辨率训练检测网络。可提升4%mAP。**为什么可以改变输入维度了？**因为YOLO v2中使用了GAP(Global Average Pooling)不论输入图片多大最后都给你从 <img src="https://www.zhihu.com/equation?tex=1000%5Ctimes7%5Ctimes7%5Crightarrow1000%5Ctimes1" alt="[公式]"> ，进行分类训练。</li></ol><blockquote><p>注意这里图5有个地方得解释一下：第25层把第16层进行reorg，即passthrough操作，得到的结果为27层，再与第24层进行route，即concat操作，得到第28层。</p></blockquote><p><strong>可视化的图为：</strong></p><p><img src="https://pic3.zhimg.com/80/v2-33a0c926dc46085ac913b5262edb3a0a_720w.jpg" alt="img">图5：YOLO v2可视化结构</p><h2 id="YOLO-v3">YOLO v3</h2><p>先看下YOLO v3的backbone，如下图6所示：</p><p><img src="https://pic2.zhimg.com/80/v2-2bc3e653ec7744e36e45960d0cc060c9_720w.jpg" alt="img">图6：YOLO v3 backbone</p><p>先声明下darknet 53指的是convolution层有52层+1个conv层把1024个channel调整为1000个，你会发现YOLO v2中使用的GAP层在YOLO v3中还在用，他还是在ImageNet上先train的backbone，</p><p>观察发现依然是有bottleneck的结构和<strong>残差网络</strong>。</p><p><strong>为什么</strong>YOLO v3敢用3个检测头**？因为**他的backbone更强大了。</p><p><strong>为什么</strong>更强大了**？因为**当时已经出现了ResNet结构。</p><p>所以YOLO v3的提高，有一部分功劳应该给ResNet。</p><p>再观察发现YOLO v3没有Pooling layer了，用的是conv(stride = 2)进行下采样，<strong>为什么？</strong></p><p><strong>因为</strong>Pooling layer，不管是MaxPooling还是Average Pooling，本质上都是下采样减少计算量，本质上就是不更新参数的conv，但是他们会损失信息，所以用的是conv(stride = 2)进行下采样。</p><p>下图7是YOLO v3的网络结构：</p><p><img src="https://pic2.zhimg.com/80/v2-997f8c0bc3bde01329a52ba6afa49cfd_720w.jpg" alt="img">图7：YOLO v3 Structure</p><p><img src="https://pic4.zhimg.com/80/v2-3946e19705fcabb730daf30f9cd1408f_720w.jpg" alt="img">图8：YOLO v3 Structure</p><p>特征融合的方式更加直接，没有YOLO v2的passthrough操作，直接上采样之后concat在一起。</p><hr><h2 id="YOLO-v4">YOLO v4</h2><p>图9,10展示了YOLO v4的结构：</p><p><img src="https://pic2.zhimg.com/80/v2-0ea4884cd89aaf5b87ba1464d02f358d_720w.jpg" alt="img">图9：YOLO v4 Structure</p><p><img src="https://pic3.zhimg.com/80/v2-05a713ffc8cee40dbaa3b808aa63dcea_720w.jpg" alt="img">图10：YOLO v4 Structure</p><p><img src="https://pic1.zhimg.com/80/v2-c70a13fe3c658d20e9d11a1880619e70_720w.jpg" alt="img">图11：YOLO v4 Structure</p><p>Yolov4的结构图和Yolov3相比，因为多了<strong>CSP结构，PAN结构</strong>，如果单纯看可视化流程图，会觉得很绕，不过在绘制出上面的图形后，会觉得豁然开朗，其实整体架构和Yolov3是相同的，不过使用各种新的算法思想对各个子结构都进行了改进。</p><p><strong>YOLOv4使用了CSPDarknet53作为backbone，加上SPP模块，PANET作为neck，以及YOLO v3的head。</strong></p><p><strong>Yolov4的五个基本组件</strong>：</p><ol><li>**CBM：**Yolov4网络结构中的最小组件，由Conv+Bn+Mish激活函数三者组成。</li><li>**CBL：**由Conv+Bn+Leaky_relu激活函数三者组成。</li><li>**Res unit：**借鉴Resnet网络中的残差结构，让网络可以构建的更深。</li><li>**CSPX：**借鉴CSPNet网络结构，由三个卷积层和X个Res unint模块Concate组成。</li><li>**SPP：**采用1×1，5×5，9×9，13×13的最大池化的方式，进行多尺度融合。</li></ol><p><strong>其他基础操作：</strong></p><ol><li>**Concat：**张量拼接，维度会扩充，和Yolov3中的解释一样，对应于cfg文件中的route操作。</li><li>**add：**张量相加，不会扩充维度，对应于cfg文件中的shortcut操作。</li></ol><p><strong>Backbone中卷积层的数量：</strong></p><p>和Yolov3一样，再来数一下Backbone里面的卷积层数量。</p><p>每个CSPX中包含3+2<em>X个卷积层，因此整个主干网络Backbone中一共包含2+（3+2</em>1）+2+（3+2<em>2）+2+（3+2</em>8）+2+（3+2<em>8）+2+（3+2</em>4）+1=72。</p><ul><li><strong>输入端的改进：</strong></li></ul><p>YOLO v4对输入端进行了改进，主要包括<strong>数据增强Mosaic、cmBN、SAT自对抗训练</strong>，使得在卡不是很多时也能取得不错的结果。</p><p>这里介绍下数据增强Mosaic：</p><p><img src="https://pic1.zhimg.com/80/v2-9ddb5f309a28e99f6c1901ec908923e4_720w.jpg" alt="img">Mosaic数据增强</p><p><strong>CutMix</strong>只使用了两张图片进行拼接，而<strong>Mosaic数据增强</strong>则采用了4张图片，<strong>随机缩放、随机裁剪、随机排布</strong>的方式进行拼接。</p><p>Yolov4的作者采用了<strong>Mosaic数据增强</strong>的方式。</p><p>主要有几个优点：</p><ol><li><strong>丰富数据集：<strong>随机使用</strong>4张图片</strong>，随机缩放，再随机分布进行拼接，大大丰富了检测数据集，特别是随机缩放增加了很多小目标，让网络的鲁棒性更好。</li><li>**减少GPU：**可能会有人说，随机缩放，普通的数据增强也可以做，但作者考虑到很多人可能只有一个GPU，因此Mosaic增强训练时，可以直接计算4张图片的数据，使得Mini-batch大小并不需要很大，一个GPU就可以达到比较好的效果。</li></ol><p>cmBN的方法如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-bc8cfe6198d8c2a0d8a3a646a27a6e0d_720w.jpg" alt="img">cmBN的方法</p><hr><h2 id="YOLO-v5">YOLO v5</h2><p>图12,13展示了YOLO v5的结构：</p><p><img src="https://pic2.zhimg.com/80/v2-2ca7dfc26a64e7ca0e5e8b21c87ed13d_720w.jpg" alt="img">图12：YOLO v5 Structure</p><p><img src="https://pic2.zhimg.com/80/v2-31ca3528d3bb53273f74a23b5b59ab51_720w.jpg" alt="img">图13：YOLO v5 Structure</p><p>检测头的结构基本上是一样的，融合方法也是一样。</p><p><strong>Yolov5的基本组件</strong>：</p><ol><li>**Focus：**基本上就是YOLO v2的passthrough。</li><li>**CBL：**由Conv+Bn+Leaky_relu激活函数三者组成。</li><li>**CSP1_X：**借鉴CSPNet网络结构，由三个卷积层和X个Res unint模块Concate组成。</li><li>**CSP2_X：**不再用Res unint模块，而是改为CBL。</li><li>**SPP：**采用1×1，5×5，9×9，13×13的最大池化的方式，进行多尺度融合，如图13所示。</li></ol><p>提特征的网络变短了，速度更快。YOLO v5的结构没有定下来，作者的代码还在持续更新。</p><h2 id="YOLO-v5的四种结构的深度："><strong>YOLO v5的四种结构的深度：</strong></h2><p>下图展示了YOLO v5的四种结构：</p><p><img src="https://pic3.zhimg.com/80/v2-6c383a7d5fdafda4a18799b1a1e7585e_720w.jpg" alt="img">图14：YOLO四种结构深度</p><p>Yolov5代码中，每个网络结构的两个参数：</p><p><strong>（1）Yolov5s.yaml</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">depth_multiple: 0.33  # model depth multiple</span><br><span class="line">width_multiple: 0.50  # layer channel multiple</span><br></pre></td></tr></table></figure><p><strong>（2）Yolov5m.yaml</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">depth_multiple: 0.67  # model depth multiple</span><br><span class="line">width_multiple: 0.75  # layer channel multiple</span><br></pre></td></tr></table></figure><p><strong>（3）Yolov5l.yaml</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">depth_multiple: 1.0  # model depth multiple</span><br><span class="line">width_multiple: 1.0  # layer channel multiple</span><br></pre></td></tr></table></figure><p><strong>（4）Yolov5x.yaml</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">depth_multiple: 1.33  # model depth multiple</span><br><span class="line">width_multiple: 1.25  # layer channel multiple</span><br></pre></td></tr></table></figure><p>四种结构就是通过上面的两个参数，来进行控制网络的<strong>深度</strong>和<strong>宽度</strong>。其中<strong>depth_multiple</strong>控制网络的<strong>深度</strong>，<strong>width_multiple</strong>控制网络的<strong>宽度</strong>。</p><h3 id="Yolov5网络结构">Yolov5网络结构</h3><p>四种结构的yaml文件中，下方的网络架构代码都是一样的。</p><p>将Backbone部分提取出来，讲解如何控制网络的宽度和深度，yaml文件中的Head部分也是同样的原理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># YOLOv5 backbone</span><br><span class="line">backbone:</span><br><span class="line">  # [from, number, module, args]</span><br><span class="line">  [[-1, 1, Focus, [64, 3]],  # 0-P1/2</span><br><span class="line">   [-1, 1, Conv, [128, 3, 2]],  # 1-P2/4</span><br><span class="line">   [-1, 3, BottleneckCSP, [128]],</span><br><span class="line">   [-1, 1, Conv, [256, 3, 2]],  # 3-P3/8</span><br><span class="line">   [-1, 9, BottleneckCSP, [256]],</span><br><span class="line">   [-1, 1, Conv, [512, 3, 2]],  # 5-P4/16</span><br><span class="line">   [-1, 9, BottleneckCSP, [512]],</span><br><span class="line">   [-1, 1, Conv, [1024, 3, 2]],  # 7-P5/32</span><br><span class="line">   [-1, 1, SPP, [1024, [5, 9, 13]]],</span><br><span class="line">   [-1, 3, BottleneckCSP, [1024, False]],  # 9</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>在对网络结构进行解析时，yolo.py中下方的这一行代码将四种结构的<strong>depth_multiple</strong>，<strong>width_multiple</strong>提取出，赋值给<strong>gd，gw</strong>。后面主要对这<strong>gd，gw</strong>这两个参数进行讲解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anchors, nc, gd, gw = d[&#x27;anchors&#x27;], d[&#x27;nc&#x27;], d[&#x27;depth_multiple&#x27;], d[&#x27;width_multiple&#x27;]</span><br></pre></td></tr></table></figure><p>下面再细致的剖析下，看是如何控制每种结构，深度和宽度的。</p><p><strong>1) 不同网络的深度</strong></p><p>在上图中有2种结构：CSP1和CSP2，其中CSP1结构主要应用于<strong>Backbone</strong>中，CSP2结构主要应用于<strong>Neck</strong>中。</p><p><strong>需要注意的是，四种网络结构中每个CSP结构的深度都是不同的。</strong></p><p>a.以yolov5s为例，第一个CSP1中，使用了<strong>1个残差组件</strong>，因此是<strong>CSP1_1</strong>。而在Yolov5m中，则增加了网络的深度，在第一个CSP1中，使用了<strong>2个残差组件</strong>，因此是<strong>CSP1_2</strong>。</p><p>而Yolov5l中，同样的位置，则使用了<strong>3个残差组件</strong>，Yolov5x中，使用了<strong>4个残差组件</strong>。</p><p>其余的第二个CSP1和第三个CSP1也是同样的原理。</p><p>b.在第二种CSP2结构中也是同样的方式，以第一个CSP2结构为例，Yolov5s组件中使用了<strong>1组</strong>卷积，因此是<strong>CSP2_1</strong>。</p><p>而Yolov5m中使用了<strong>2组</strong>，Yolov5l中使用了<strong>3组</strong>，Yolov5x中使用了<strong>4组。</strong></p><p>其他的四个CSP2结构，也是同理。</p><p>Yolov5中，网络的不断加深，也在不断<strong>增加网络特征提取</strong>和<strong>特征融合</strong>的能力。</p><p><strong>2) 控制深度的代码</strong></p><p>控制四种网络结构的核心代码是<strong><a href="http://yolo.py">yolo.py</a></strong>中下面的代码，存在两个变量，<strong>n和gd</strong>。</p><p>我们再将<strong>n和gd</strong>带入计算，看每种网络的变化结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = max(round(n * gd), 1) if n &gt; 1 else n  # depth gain</span><br></pre></td></tr></table></figure><p><strong>3) 验证控制深度的有效性</strong></p><p>我们选择<strong>最小的yolov5s.yaml</strong>和中间的<strong>yolov5l.yaml</strong>两个网络结构，将**gd(height_multiple)**系数带入，看是否正确。</p><p><img src="https://pic1.zhimg.com/80/v2-2bc10e474354757a4d7947e219f56cc0_720w.jpg" alt="img"></p><p><strong>a. yolov5x.yaml</strong></p><p>其中<strong>height_multiple=0.33</strong>，即<strong>gd=0.33</strong>，而n则由上面红色框中的信息获得。</p><p>以上面网络框图中的第一个CSP1为例，即上面的第一个红色框。n等于第二个数值3。</p><p>而<strong>gd=0.33</strong>，带入（2）中的计算代码，结果n=1。因此第一个CSP1结构内只有1个残差组件，即CSP1_1。</p><p>第二个CSP1结构中，n等于第二个数值9，而<strong>gd=0.33</strong>，带入（2）中计算，结果<strong>n=3</strong>，因此第二个CSP1结构中有3个残差组件，即CSP1_3。</p><p>第三个CSP1结构也是同理，这里不多说。</p><p><strong>b. yolov5l.xml</strong></p><p>其中<strong>height_multiple=1</strong>，即<strong>gd=1</strong></p><p>和上面的计算方式相同，第一个CSP1结构中，n=1，带入代码中，结果n=3，因此为CSP1_3。</p><p>下面第二个CSP1和第三个CSP1结构都是同样的原理。</p><h2 id="YOLO-v5的四种结构的宽度：">YOLO v5的四种结构的宽度：</h2><p><img src="https://pic3.zhimg.com/80/v2-76ec41e464f5ce3ce103136837937112_720w.jpg" alt="img">图15：YOLO四种结构宽度</p><p><strong>1) 不同网络的宽度:</strong></p><p>如上图表格中所示，四种yolov5结构在不同阶段的卷积核的数量都是不一样的，因此也直接影响卷积后特征图的第三维度，即<strong>宽度</strong>。</p><p>a.以Yolo v5s结构为例，第一个Focus结构中，最后卷积操作时，卷积核的数量是32个，因此经过<strong>Focus结构</strong>，特征图的大小变成<strong>304*304*32</strong>。</p><p>而Yolo v5m的<strong>Focus结构</strong>中的卷积操作使用了48个卷积核，因此<strong>Focus结构</strong>后的特征图变成3<strong>04*304*48</strong>。yolov5l，yolov5x也是同样的原理。</p><p>b. 第二个卷积操作时，Yolo v5s使用了64个卷积核，因此得到的特征图是<strong>152*152*64</strong>。而yolov5m使用96个特征图，因此得到的特征图是<strong>152*152*96</strong>。Yolo v5l，Yolo v5x也是同理。</p><p>c. 后面三个卷积下采样操作也是同样的原理。</p><p>四种不同结构的卷积核的数量不同，这也直接影响网络中，比如<strong>CSP1，CSP2等结构</strong>，以及各个普通卷积，卷积操作时的卷积核数量也同步在调整，影响整体网络的计算量。</p><p>当然卷积核的数量越多，特征图的厚度，即<strong>宽度越宽</strong>，网络提取特征的<strong>学习能力也越强</strong>。</p><ol start="2"><li><strong>控制宽度的代码</strong></li></ol><p>在Yolo v5的代码中，控制宽度的核心代码是<strong><a href="http://yolo.py">yolo.py</a></strong>文件里面的这一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c2 = make_divisible(c2 * gw, 8) if c2 != no else c2</span><br></pre></td></tr></table></figure><p>它所调用的子函数<strong>make_divisible</strong>是一个很出名的函数，在各大任务中均会使用，作用是：</p><p>**make_divisible(A,B)：**找到比A大的，能整除B的最小整数。</p><blockquote><p>make_divisible(54,8) = 56</p></blockquote><p><strong>3) 验证控制宽度的有效性</strong></p><p>我们还是选择<strong>最小的Yolo v5s</strong>和<strong>中间的Yolo v5l</strong>两个网络结构，将<strong>width_multiple</strong>系数带入，看是否正确。</p><p><img src="https://pic2.zhimg.com/80/v2-7544dc64d6cfce2fb0dbe69bec73e3e1_720w.jpg" alt="img">图16：backbone</p><p><strong>a. Yolo v5x.yaml</strong></p><p>其中<strong>width_multiple=0.5</strong>，即<strong>gw=0.5</strong>。</p><p>以第一个卷积下采样为例，即Focus结构中下面的卷积操作。</p><p>按照上面Backbone的信息，我们知道Focus中，标准的c2=64，而<strong>gw=0.5</strong>，代入（2）中的计算公式，最后的结果=32。即Yolo v5s的Focus结构中，卷积下采样操作的卷积核数量为<strong>32个。</strong></p><p>再计算后面的第二个卷积下采样操作，标准c2的值=128，<strong>gw=0.5</strong>，代入（2）中公式，最后的结果=64，也是正确的。</p><p><strong>b. Yolo v5l.yaml</strong></p><p>其中<strong>width_multiple=1</strong>，即<strong>gw=1</strong>，而标准的<strong>c2=64</strong>，代入上面（2）的计算公式中，可以得到Yolo v5l的Focus结构中，卷积下采样操作的卷积核的数量为64个，而第二个卷积下采样的卷积核数量是128个。</p><p>另外的三个卷积下采样操作，以及<strong>Yolo v5m，Yolo v5x结构</strong>也是同样的计算方式。</p><p>比如：YOLO V5s默认depth_multiple=0.33， width_multiple=0.50。即BottleneckCSP中Bottleneck的数量为<strong>默认的1/3</strong>，而所有卷积操作的卷积核个数均为<strong>默认的1/2。</strong></p><p><img src="https://pic4.zhimg.com/80/v2-c1422e55da6ba5030371f0111d8d4e8f_720w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-4c47b276ff2f51fb59a056e961666f67_720w.jpg" alt="img">图17：SPP结构</p><p><strong>Focus操作如下图所示：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-560db4a00dd21975f64e7addff498ecc_720w.jpg" alt="img">图18：Focus操作</p><p><strong>Focus</strong>的<strong>slice</strong>操作如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-eeec8b5b35b9ab4f096dfbfb229ea1fa_720w.jpg" alt="img">图19：slice操作</p><p>这个其实就是<strong>Yolo v2</strong>里面的<strong>ReOrg+Conv</strong>操作，也是亚像素卷积的反向操作版本，简单来说就是把数据切分为4份，每份数据都是相当于2倍下采样得到的，然后在channel维度进行拼接，最后进行卷积操作。其最大好处是可以<strong>最大程度的减少信息损失而进行下采样操作</strong>。</p><p><strong>YOLO v5s</strong>默认<strong>3x640x640</strong>的输入，复制四份，然后通过切片操作将这个四个图片切成了四个<strong>3x320x320</strong>的切片，接下来使用concat从深度上连接这四个切片，输出为<strong>12x320x320</strong>，之后再通过卷积核数为32的卷积层，生成<strong>32x320x320</strong>的输出，最后经过batch_borm 和leaky_relu将结果输入到下一个卷积层。</p><p><strong>Focus的代码如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Focus(nn.Module):</span><br><span class="line">    # Focus wh information into c-space</span><br><span class="line">    def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True):  # ch_in, ch_out, kernel, stride, padding, groups</span><br><span class="line">        super(Focus, self).__init__()</span><br><span class="line">        self.conv = Conv(c1 * 4, c2, k, s, p, g, act)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):  # x(b,c,w,h) -&gt; y(b,4c,w/2,h/2)</span><br><span class="line">        return self.conv(torch.cat([x[..., ::2, ::2], x[..., 1::2, ::2], x[..., ::2, 1::2], x[..., 1::2, 1::2]], 1))</span><br></pre></td></tr></table></figure><p>这里解释以下<strong>PANET</strong>结构是什么意思，PAN结构来自论文Path Aggregation Network，可视化结果如图19所示：</p><p><img src="https://pic3.zhimg.com/80/v2-93d93db2c7f60ebf3fa5d894d1b446f2_720w.jpg" alt="img">图20：PAN结构</p><p>可以看到包含了自底向上和自顶向下的连接，值得注意的是这里的红色虚线和绿色虚线：</p><p>FPN的结构把浅层特征传递给顶层要经历<strong>几十甚至上百层</strong>，显然经过这么多层的传递，浅层信息(小目标)丢失比较厉害。这里的<strong>红色虚线</strong>就象征着ResNet的几十甚至上百层。</p><p><strong>自下而上的路径</strong>由<strong>不到10层</strong>组成，<strong>浅层特征</strong>经过FPN的<strong>laterial connection</strong>连接到 <img src="https://www.zhihu.com/equation?tex=P_%7B2%7D" alt="[公式]"> ，再经过<strong>bottom-up path augmentation</strong>连接到顶层，经过的层数不到10层，能较好地保留浅层的信息。这里的<strong>绿色虚线</strong>就象征着自下而上的路径的不到10层。</p><p>YOLO V5借鉴了YOLO V4的<strong>修改版PANET</strong>结构。</p><p><strong>PANET</strong>通常使用自适应特征池将相邻层<strong>加</strong>在一起，以进行掩模预测。但是，当在YOLO v4中使用PANET时，此方法略麻烦，因此，YOLO v4的作者没有使用自适应特征池添加相邻层，而是对其进行<strong>Concat</strong>操作，从而提高了预测的准确性。</p><p><img src="https://pic4.zhimg.com/80/v2-98fce9f04482ad10b4fb0c04281362df_720w.jpg" alt="img">图21：Modified PAN</p><ul><li><strong>输入端的改进：</strong></li></ul><p><strong>1.Mosaic数据增强，和YOLO v4一样。</strong></p><p><strong>2.自适应锚框计算：</strong></p><p>在Yolo算法中，针对不同的数据集，都会有<strong>初始设定长宽的锚框</strong>。</p><p>在网络训练中，网络在初始锚框的基础上输出预测框，进而和<strong>真实框groundtruth</strong>进行比对，计算两者差距，再反向更新，<strong>迭代网络参数</strong>。</p><p>因此初始锚框也是比较重要的一部分，比如Yolov5在Coco数据集上初始设定的锚框：</p><p><img src="https://pic1.zhimg.com/80/v2-f8a55d48eb2003b47629f4e92d7ab5a8_720w.jpg" alt="img">Yolov5在Coco数据集上初始设定的锚框</p><p>在Yolov3、Yolov4中，训练不同的数据集时，计算初始锚框的值是通过单独的程序运行的。</p><p>但Yolov5中将此功能嵌入到代码中，每次训练时，自适应的计算不同训练集中的最佳锚框值。</p><p>当然，如果觉得计算的锚框效果不是很好，也可以在代码中将自动计算锚框功能<strong>关闭</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(&#x27;--noautoanchor&#x27;, action=&#x27;store_true&#x27;, help=&#x27;disable autoanchor check&#x27;)</span><br></pre></td></tr></table></figure><p>设置成<strong>False</strong>，每次训练时，不会自动计算。</p><p><strong>3.自适应图片缩放</strong></p><p>在常用的目标检测算法中，不同的图片长宽都不相同，因此常用的方式是将原始图片统一缩放到一个标准尺寸，再送入检测网络中。</p><p>比如Yolo算法中常用<strong>416*416，608*608</strong>等尺寸，比如对下面<strong>800*600</strong>的图像进行缩放:，如图15所示：</p><p><img src="https://pic3.zhimg.com/80/v2-21213f06cfd4b9025ac0aec29e2e8a82_720w.jpg" alt="img">图22：Yolo算法的缩放填充</p><p>但<strong>Yolov5代码</strong>中对此进行了改进，也是<strong>Yolov5推理速度</strong>能够很快的一个不错的trick。</p><p>作者认为，在项目实际使用时，很多图片的长宽比不同，因此缩放填充后，两端的黑边大小都不同，而如果<strong>填充的比较多</strong>，则存在<strong>信息冗余</strong>，影响<strong>推理速度</strong>。</p><p>因此在Yolov5的代码中datasets.py的letterbox函数中进行了修改，对原始图像<strong>自适应的添加最少的黑边</strong>，如图16所示：</p><p><img src="https://pic4.zhimg.com/80/v2-d9d3685aae6ba2f99e1c7c27a4f1ae53_720w.jpg" alt="img">图22：YOLO v5的自适应填充</p><p>图像高度上两端的黑边变少了，在推理时，计算量也会减少，即目标检测速度会得到提升。</p><p>通过这种简单的改进，推理速度得到了37%的提升，可以说效果很明显。</p><p>Yolov5中填充的是灰色，即（114,114,114），都是一样的效果，且训练时没有采用缩减黑边的方式，还是采用传统填充的方式，即缩放到416*416大小。只是在测试，使用模型推理时，才采用缩减黑边的方式，提高目标检测，推理的速度。</p><p><strong>关于样本：</strong></p><p>yolov5的很大区别就是在于正样本区域的定义。<strong>在yolov3中，每一个</strong> <img src="https://www.zhihu.com/equation?tex=GT" alt="[公式]"> **只有1个对应的anchor，**设定的规则是取 <img src="https://www.zhihu.com/equation?tex=IoU%28anchor%2CGT%29" alt="[公式]"> 最大的anchor。而且某个 <img src="https://www.zhihu.com/equation?tex=GT" alt="[公式]"> 一定不可能在三个预测层的某几层上同时进行匹配。这样就会导致一个问题：正样本的anchor太少了，导致整体收敛比较慢。后面的FCOS等工作研究表明：<strong>增加高质量正样本anchor可以显著加速收敛</strong>。</p><p>YOLO v5和前YOLO系列相比，特点应该是：</p><ul><li><strong>(1) 增加了正样本：方法是邻域的正样本anchor匹配策略。</strong></li><li><strong>(2) 通过灵活的配置参数，可以得到不同复杂度的模型</strong></li><li><strong>(3) 通过一些内置的超参优化策略，提升整体性能</strong></li><li><strong>(4) 和yolov4一样，都用了mosaic增强，提升小物体检测性能</strong></li></ul><hr><p>最后我们对YOLO series总的做个比较，结束这个系列的解读，喜欢的同学点赞关注评论3连：</p><p><img src="https://pic1.zhimg.com/80/v2-ba712736fadbf364cc2fec97dd374f98_720w.jpg" alt="img"></p><p>YOLO v5 series的比较</p><h1>写给小白的Yolo介绍</h1><h2 id="YOLO是什么？">YOLO是什么？</h2><p>YOLO是目标检测模型。</p><p>目标检测是计算机视觉中比较简单的任务，用来在一张图篇中找到<strong>某些特定的物体</strong>，目标检测不仅要求我们识别这些物体的<strong>种类</strong>，同时要求我们标出这些物体的<strong>位置</strong>。</p><p>显然，类别是离散数据，位置是连续数据。</p><p><img src="https://pic1.zhimg.com/80/v2-88ca6ec106e7647a0390ad3d93625444_720w.jpg" alt="img"></p><p>上面的图片中，分别是计算机视觉的三类任务：分类，目标检测，实例分割。</p><p>很显然，整体上这三类任务从易到难，我们要讨论的目标检测位于中间。前面的分类任务是我们做<strong>目标检测的基础</strong>，至于<strong>像素级别</strong>的实例分割，太难了别想了。</p><p>YOLO在2016年被提出，发表在计算机视觉顶会<strong>CVPR</strong>(Computer Vision and Pattern Recognition)上，论文的国内镜像在这里：<a href="https://link.zhihu.com/?target=http%3A//xxx.itp.ac.cn/pdf/1506.02640v5">1</a></p><p>YOLO的全称是you only look once，指<strong>只需要</strong>浏览一次就可以识别出图中的物体的类别和位置。</p><p>因为只需要看一次，YOLO被称为Region-free方法，相比于Region-based方法，YOLO不需要提前找到<strong>可能存在目标的Region</strong>。</p><p>也就是说，一个典型的Region-base方法的流程是这样的：先通过计算机图形学（或者深度学习）的方法，对图片进行分析，找出若干个可能存在物体的区域，将这些区域裁剪下来，放入一个图片分类器中，由分类器分类。</p><p>因为YOLO这样的Region-free方法只需要一次扫描，也被称为<strong>单阶段</strong>（1-stage）模型。Region-based方法方法也被称为<strong>两阶段</strong>（2-stage）方法。</p><hr><h2 id="YOLO之前的世界">YOLO之前的世界</h2><p>YOLO之前的世界，额，其实是R-CNN什么的，也就是我们前面说的Region-based方法，但是感觉还是太高端了。我们从用脚都能想到的目标检测方法开始讲起。</p><p>如果我们现在有一个<strong>分类器：</strong></p><p><img src="https://pic3.zhimg.com/80/v2-21d1a2b0e0381fa30e69eeaa7f24384e_720w.jpg" alt="img"></p><p>这只猫咪好可爱，想撸。</p><p>现在我们的追求升级了，我们不仅仅想处理这种<strong>一张图片中只有一个物体</strong>的图片，我们现在想处理有多个物体的图片。</p><p>我们该什么做呢？</p><p>首先有几点我们要实现想到：<strong>首先</strong>物体的位置是不确定的，你没办法保证物体一定在最中间；<strong>其次</strong>，物体的大小是不确定的，有的物体比较大，也有的物体比较小，注意，这里不是说大象一定更大，猫咪一定更小，毕竟还有近大远小嘛；<strong>然后</strong>，我们还没办法保证物体的种类，假设我们有一个可以识别100中物体的分类器，那么起码图片中出现了这100种物体我们都要识别出来。</p><p>比如说这样：</p><p><img src="https://pic1.zhimg.com/80/v2-e56c54e419838b8e45ad211df5e38058_720w.jpg" alt="img"></p><p>挺难的，是吧？</p><p>最naive的方法是<strong>滑窗法</strong>，就是用滑动窗口去识别一个个物体。</p><p>比如这样：</p><p><img src="https://pic1.zhimg.com/80/v2-b99bfd4ae6466b6a5c9274b40c544d10_720w.jpg" alt="img"></p><p>上图的红色框框就是所谓的滑窗。如果一个物体<strong>正好</strong>出现在一个滑窗中，那么我们就可以把它检测出来了，这个滑窗的位置也就是我们认为<strong>这个物体所在的位置</strong>。</p><p>等下，如果物体没有正好出现在一个滑窗中呢？</p><p>我们管滑窗每次滑动的距离叫做<strong>步长</strong>，如果我们把步长设置的特别小，如果步长仅仅为一个像素点，那<strong>一定可以</strong>保证物体可以<strong>正好</strong>出现在某个窗口中了。</p><p>那如果某个物体特别大，或者特别小呢？</p><p>例如在上图中，每个窗口和汽车差不多大小，但是如果我们要识别一辆卡车，一个窗口可能就不够大了。</p><p>显然，我们可以设计不同大小的窗口，我们可以设计几十中不同大小的窗口，让他们按照最小的步长滑动，把窗口里的所有图片都放入分类器中。</p><p>但是这样太太太浪费时间了。</p><p>到这里R-CNN同学出现了，他说，你这样用滑窗法可能最后得到了几十万个窗口，而我可以提前扫描一下图片，得到2000个左右的Region（其实就是前面的窗口），这样不就节省了很多时间？</p><p><a href="https://link.zhihu.com/?target=http%3A//xxx.itp.ac.cn/pdf/1311.2524">Rich feature hierarchies for accurate object detection and semantic segmentationxxx.itp.ac.cn/pdf/1311.2524</a></p><p>R-CNN同学管这个叫做Region Proposal，并且提出了一个叫做Selective Search的算法。（吐槽一下这个名字起得太大众了）</p><p>但是R-CNN被YOLO打脸了，YOLO说，我更快。</p><hr><h2 id="YOLO原理">YOLO原理</h2><p>在这之前，我们再重申一下我们的任务。我们的目的是在一张图片中找出物体，并给出它的类别和位置。目标检测是基于监督学习的，每张图片的监督信息是它所包含的N个物体，每个物体的信息有<strong>五个</strong>，分别是物体的<strong>中心位置(x,y)<strong>和它的</strong>高(h)<strong>和</strong>宽(w)</strong>，最后是它的类别。</p><p>YOLO 的预测是基于整个图片的，并且它会一次性输出所有检测到的目标信息，包括类别和位置。</p><p>就好像捕鱼一样，R-CNN是先选好哪里可能出现鱼，而YOLO是直接一个大网下去，把所有的鱼都捞出来。</p><p>先假设我们处理的图片是一个<strong>正方形</strong>。</p><p>YOLO的第一步是<strong>分割图片</strong>，它将图片分割为 <img src="https://www.zhihu.com/equation?tex=s%5E2" alt="[公式]"> 个grid，每个grid的大小都是相等的，像这样：</p><p><img src="https://pic1.zhimg.com/80/v2-01c11f4d423a698271159fcc98524894_720w.jpg" alt="img"></p><p>如果我们让每个框只能识别出一个物体，且要求这个物体必须在这个框之内，那YOLO就变成了很蠢的滑窗法了。</p><p>YOLO的聪明之处在于，它只要求这个物体的<strong>中心</strong>落在这个框框之中。</p><p>这意味着，我们不用设计非常非常<strong>大</strong>的框，因为我们只需要让物体的中心在这个框中就可以了，而不是必须要让整个物体都在这个框中。</p><p>具体怎么实现呢？</p><p>我们要让这个 <img src="https://www.zhihu.com/equation?tex=S%5E2" alt="[公式]"> 个框每个都预测出<strong>B个bounding boxs</strong>，这个bounding boxs有5个量，分别是物体的<strong>中心位置(x,y)<strong>和它的</strong>高(h)<strong>和</strong>宽(w)</strong>，以及这次预测的<strong>置信度</strong>。</p><p>每个框框不仅只预测B个bounding boxs，它还要负责预测这个框框中的物体<strong>是什么类别</strong>的，这里的类别用one-hot编码表示。</p><p>注意，虽然一个框框有多个bounding boxes，但是只能识别出一个物体，因此每个框框需要预测物体的类别，<strong>而bounding box不需要</strong>。</p><p>也就是说，如果我们有 <img src="https://www.zhihu.com/equation?tex=S%5E2" alt="[公式]"> 个框框，每个框框的bounding boxes个数为B，分类器可以识别出C种不同的物体，那么所有整个ground truth的长度为：</p><p><img src="https://www.zhihu.com/equation?tex=S+%5Ctimes+S++%5Ctimes+%28B++%5Ctimes+5++%2BC%29" alt="[公式]"></p><p>先看这些bounding boxs显示出来是什么样的：</p><p><img src="https://pic3.zhimg.com/80/v2-019dcd8dae979fa96f48fc23e70e25a2_720w.jpg" alt="img"></p><p>在上面的例子中，图片被分成了49个框，每个框预测2个bounding boxs，因此上面的图中有98个bounding boxs。</p><p>可以看到大致上每个框里确实有两个bounding boxs。</p><p>可以看到这些BOX中有的边框比较粗，有的比较细，这是<strong>置信度</strong>不同的表现，置信度高的比较粗，置信度低的比较细。</p><hr><p>在详细的介绍confidence之前，我们先来说一说关于bounding boxs的细节。</p><p>bounding boxs可以锁定物体的位置，这要求它输出四个关于位置的值，分别是x,y,h和w。我们在处理输入的图片的时候想让图片的大小<strong>任意</strong>，这一点对于卷积神经网络来说不算太难，但是，如果输出的位置坐标是一个<strong>任意的正实数</strong>，模型很可能在<strong>大小不同</strong>的物体上<strong>泛化能力</strong>有很大的差异。</p><p>这时候当然有一个常见的套路，就是对数据进行归一化，让连续数据的值位于0和1之间。</p><p>对于x和y而言，这相对比较容易，毕竟x和y是物体的中心位置，既然物体的中心位置在这个grid之中，那么只要让真实的<strong>x除以grid的宽度</strong>，让真实的<strong>y除以grid的高度</strong>就可以了。</p><p>但是h和w就不能这么做了，因为一个物体很可能远大于grid的大小，预测物体的高和宽很可能大于bounding boxs的高和宽，这样w除以bounding boxs的宽度，h除以bounding boxs的高度依旧<strong>不在0和1之间</strong>。</p><p>解决方法是让<strong>w除以整张图片的宽度</strong>，<strong>h除以整张图片的高度</strong>。</p><p>下面的例子是一个448<em>448的图片，有3</em>3的grid，展示了计算x,y,w,h的真实值（ground truth）的过程：</p><p><img src="https://pic1.zhimg.com/80/v2-8fbe9f9fbcdfeac54f36e4174f579e8c_720w.jpg" alt="img"></p><p>接下来，我们好好说道说道这个confidence。</p><p>confidence的计算公式是：</p><p><img src="https://www.zhihu.com/equation?tex=C%3DP+r%28o+b+j%29+%2A+I+O+U_%7Bt+r+u+t+h%7D%5E%7Bp+r+e+d%7D" alt="[公式]"></p><p>这个IOU的全称是intersection over union，也就是交并比，它反应了两个框框的相似度。</p><p><img src="https://pic2.zhimg.com/80/v2-95ed394b96949c248c7668377d4b3889_720w.jpg" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=I+O+U_%7Bt+r+u+t+h%7D%5E%7Bp+r+e+d%7D" alt="[公式]"> 的意思是预测的bounding box和真实的物体位置的交并比。</p><p><img src="https://www.zhihu.com/equation?tex=P+r%28o+b+j%29+" alt="[公式]"> 是一个grid有物体的概率，在有物体的时候ground truth为1，没有物体的时候ground truth为0.</p><p>这个<img src="https://www.zhihu.com/equation?tex=I+O+U_%7Bt+r+u+t+h%7D%5E%7Bp+r+e+d%7D" alt="[公式]"> 非常有意思，因为它的groun truth不是确定的，这导致虽然 <img src="https://www.zhihu.com/equation?tex=P+r%28o+b+j%29+" alt="[公式]"> 的ground truth是确定的，但是bounding box的confidence的ground truth是不确定的。</p><p>一个不确定的ground truth有什么用呢？</p><p>想象这样的问题：老师问小明1+1等于几。小明说等于2，老师又问你有多大的把握你的回答是对的，小明说有80%</p><p>这里的80%就是confidence。</p><p>confidence主要有两个作用，在后面我会一一介绍。</p><p>现在，我们根据上面大雁的图片计算一下样本的groun truth：</p><p><img src="https://pic1.zhimg.com/80/v2-8fbe9f9fbcdfeac54f36e4174f579e8c_720w.jpg" alt="img"></p><p>首先，这里有9个grid，每个grid有两个bounding box，每个bounding box有5个预测值，假设分类器可以识别出3中物体，那么ground truth的总长度为 <img src="https://www.zhihu.com/equation?tex=S+%5Ctimes+S++%5Ctimes+%28B++%5Ctimes+5++%2BC%29+%3D+3+%5Ctimes+3++%5Ctimes+%282++%5Ctimes+5++%2B3%29+%3D+117" alt="[公式]"></p><p>我们假定大雁的类别的one-hot为100，另外两个是火鸡和特朗普，分别是010和001.</p><p>我们规定每个grid的ground truth的顺序是confidence, x, y, w, h, c1, c2, c3</p><p>那么第一个（左上角）grid的ground truth应该是：0, ?, ?, ?, ?, ?, ?, ?</p><p>实际上除了最中间的grid以外，其他的grid的ground truth都是这样的。</p><p>这里的&quot;?&quot;的意思是，随便是多少都行，我不在乎。在下面我们会看到，我们<strong>不会</strong>对这些值计算损失函数。</p><p>中间的ground truth应该是：</p><p>iou, 0.48, 0.28, 0.50, 0.32, 1, 0, 0</p><p>iou要根据x, y, w, h的预测值现场计算。</p><hr><p>这样看似可以让每个grid找到负责的物体，并把它识别出来了。但是还存在一个不得不考虑的问题，如果物体很大，而框框又很小，一个物体被多个框框识别了怎么办？</p><p>这里，我们要用到一个叫做<strong>非极大值抑制</strong>Non-maximal suppression(NMS)的技术。</p><p>这个NMS还是基于交并比实现的。</p><p><img src="https://pic2.zhimg.com/80/v2-afecf4b1039563a528da44282c14703d_720w.jpg" alt="img"></p><p>例如在上面狗狗的图里，B1,B2,B3,B4这四个框框可能都说狗狗在我的框里，但是最后的输出应该只有一个框，那怎么把其他框删除呢？</p><p>这里就用到了我们之前讲的confidence了，confidence预测<strong>有多大的把握这个物体在我的框里</strong>，我们在同样是检测狗狗的框里，也就是B1,B2,B3,B4中，选择confidence最大的，把其余的都删掉。</p><p>也就是只保留B1.</p><p>但是这里还有一个引人深思的问题，为什么confidence的定义是 <img src="https://www.zhihu.com/equation?tex=C%3DP+r%28o+b+j%29+%2A+I+O+U_%7Bt+r+u+t+h%7D%5E%7Bp+r+e+d%7D" alt="[公式]"> ，直接用 <img src="https://www.zhihu.com/equation?tex=P+r%28o+b+j%29+" alt="[公式]"> 不行吗，直接用 <img src="https://www.zhihu.com/equation?tex=P+r%28o+b+j%29+" alt="[公式]"> 的话就可以把ground truth确定下来，训练的时候就方便多了。</p><p>这里有一个非常非常鸡贼的技巧！</p><p>理论上只用 <img src="https://www.zhihu.com/equation?tex=P+r%28o+b+j%29+" alt="[公式]"> 也可以选出应该负责识别物体的grid，但是可能会<strong>不太精确</strong>。这里我们训练的目标是预测 <img src="https://www.zhihu.com/equation?tex=P+r%28o+b+j%29+%2A+I+O+U_%7Bt+r+u+t+h%7D%5E%7Bp+r+e+d%7D" alt="[公式]"> ，我们的想法是让本来不应该预测物体的grid的confidence尽可能的小，既然 <img src="https://www.zhihu.com/equation?tex=P+r%28o+b+j%29+" alt="[公式]"> 的效果不太理想，那我就让 <img src="https://www.zhihu.com/equation?tex=I+O+U_%7Bt+r+u+t+h%7D%5E%7Bp+r+e+d%7D" alt="[公式]"> <strong>尽可能小</strong>。</p><p>为什么<strong>真正的最中间的grid</strong>的confidence往往会比较大呢？</p><p>因为我们的bounding boxes是用<strong>中点坐标+宽高</strong>表示的，每个grid预测的bounding box都要求其中心在这个grid内，那么如果不是最中间的grid，其他的grid的<strong>IOU自然而言就会比较低</strong>了，因此相应的confidence就降下来了。</p><p>现在，我们知道了哪个是应该保留的bounding boxes了，但是还有一个问题，我们是怎么判断出这几个bounding boxes<strong>识别的是同一个物体</strong>的呢？</p><p>这里用到NMS的技巧，我们首先判断这几个grid的类别是不是相同的，假设上面的B1，B2，B3和B4识别的都是狗狗，那么进入下一步，我们保留B1，然后判断B2，B3和B4要不要删除。</p><p>我们把B1成为<strong>极大bounding box</strong>，计算极大bounding box和其他几个bounding box的IOU，如果超过一个阈值，例如0.5，就认为这<strong>两个bounding box实际上预测的是同一个物体</strong>，就把其中<strong>confidence比较小</strong>的删除。</p><p>最后，我们结合极大bounding box和grid识别的种类，判断图片中有什么物体，它们分别是什么，它们分别在哪。</p><p><img src="https://pic1.zhimg.com/80/v2-9e17c9c77db99a335deae64157bd80b8_720w.jpg" alt="img"></p><p>我们刚才说confidence有两个功能，一个是用来极大值抑制，另一个就是在最后输出结果的时候，将某个bounding box的confidencd和这个bounding box所属的grid的类别概率相乘，然后输出。</p><p>举个例子，比如某个grid中的某个bounding box预测到了一个物体，将这个bounding box送入神经网络（其实是整张图片一起送进去的，我们这样说是为了方便），然后神经网络<strong>对bounding box</strong>说，你这里有一个物体的概率是0.8.然后神经网络又<strong>对grid</strong>说，你这个grid里物体最可能是狗，概率是0.7。</p><p>那最后这里是狗的概率就是 <img src="https://www.zhihu.com/equation?tex=0.8+%5Ctimes+0.7+%3D+0.56" alt="[公式]"> 。</p><p>我们在这里就不细讲yolo的网络结构了，相比之下我认为yolo的<strong>损失函数</strong>的设计更有创见。</p><p>yolo的损失函数是这样的：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+loss++%26%3D++%5Clambda_%7B%5Ctext+%7Bcoord+%7D%7D+%5Csum_%7Bi%3D0%7D%5E%7BS%5E%7B2%7D%7D+%5Csum_%7Bj%3D0%7D%5E%7BB%7D+%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bobj+%7D%7D%5Cleft%5B%5Cleft%28x_%7Bi%7D-%5Chat%7Bx%7D_%7Bi%7D%5Cright%29%5E%7B2%7D%2B%5Cleft%28y_%7Bi%7D-%5Chat%7By%7D_%7Bi%7D%5Cright%29%5E%7B2%7D%5Cright%5D+%5C%5C++%26%2B%5Clambda_%7B%5Ctext+%7Bcoord+%7D%7D+%5Csum_%7Bi%3D0%7D%5E%7BS%5E%7B2%7D%7D+%5Csum_%7Bj%3D0%7D%5E%7BB%7D+%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bobj+%7D%7D%5Cleft%5B%28%5Csqrt%7Bw_%7Bi%7D%7D-%5Csqrt%7B%5Chat%7Bw%7D_%7Bi%7D%7D%29%5E%7B2%7D%2B%28%5Csqrt%7Bh_%7Bi%7D%7D-%5Csqrt%7B%5Chat%7Bh%7D_%7Bi%7D%7D%29%5E%7B2%7D%5Cright%5D+%5C%5C++%26%2B%5Csum_%7Bi%3D0%7D%5E%7BS%5E%7B2%7D%7D+%5Csum_%7Bj%3D0%7D%5E%7BB%7D+%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bobj+%7D%7D%5Cleft%28C_%7Bi%7D-%5Chat%7BC%7D_%7Bi%7D%5Cright%29%5E%7B2%7D+%5C%5C++%26%2B%5Clambda_%7B%5Ctext+%7Bnoobj+%7D%7D+%5Csum_%7Bi%3D0%7D%5E%7BS%5E%7B2%7D%7D+%5Csum_%7Bj%3D0%7D%5E%7BB%7D+%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bnoobj+%7D%7D%5Cleft%28C_%7Bi%7D-%5Chat%7BC%7D_%7Bi%7D%5Cright%29%5E%7B2%7D+%5C%5C+++%26%2B%5Csum_%7Bi%3D0%7D%5E%7BS%5E%7B2%7D%7D+%5Cmathbb%7B1%7D_%7Bi%7D%5E%7B%5Ctext+%7Bobj+%7D%7D+%5Csum_%7Bc+%5Cin+%5Ctext+%7B+classes+%7D%7D%5Cleft%28p_%7Bi%7D%28c%29-%5Chat%7Bp%7D_%7Bi%7D%28c%29%5Cright%29%5E%7B2%7D+%5Cend%7Baligned%7D" alt="[公式]"></p><p>首先， <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bobj+%7D%7D" alt="[公式]"> 代表的是这个grid里有没有物体，如果这个grid没有物体， <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bobj+%7D%7D%3D0" alt="[公式]"> ，反之 <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bobj+%7D%7D%3D1" alt="[公式]"> 。</p><p>与 <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bobj+%7D%7D" alt="[公式]"> 相反的是 <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bnoobj+%7D%7D" alt="[公式]"> ，如果没有物体， <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bnoobj+%7D%7D%3D1" alt="[公式]"> ，反之 <img src="https://www.zhihu.com/equation?tex=%5Cmathbb%7B1%7D_%7Bi+j%7D%5E%7B%5Ctext+%7Bnoobj+%7D%7D%3D0" alt="[公式]"> 。</p><p>说白了就是，当一个grid有物体的时候，损失函数计算第1，2，3，5项，当grid里没有物体的时候计算第4项。</p><p>损失函数一共有5项，我们一项一项的分析。</p><p>首先的是中心坐标的损失函数，用了我们最熟悉的均方误差MSE，这个很好理解。</p><p>然后是高和宽，没有简单的用MSE，而是用平方根的MSE，这是为什么呢？</p><p>第一个原因是更容易优化，但是还有更重要的原因：</p><p>看下面的表格：</p><img src="https://pic4.zhimg.com/80/v2-a0a7833719a274bfce50aed5ed977217_720w.jpg" alt="img" style="zoom:50%;" /><p>首先，我们只考虑var1和var2在0和1之间。当var1和var2都很小的时候，也即是w和h都很小，意味着这个物体很小，那么我们应该尽量放大一些损失函数，让模型在识别小物体的时候准确一点。当var1和var2都很大，意味着这个物体也很大，甚至可能已经布满整张图片了，这时我么可以减小一些损失函数，毕竟很大的物体不需要很高的精度。</p><p>一句话，使用平方根的MSE而不是MSE其实就是像让模型<strong>对小尺度的物体更敏感</strong>。或者说，对大的和小的物体同样敏感。</p><p>接下来的三项都使用了MSE，其实用交叉熵可能会更好，但是这些细节就不追究了。</p><p>其中第4项是用来判断一个bounding box中究竟有没有物体的。</p><p>接下来的问题是 <img src="https://www.zhihu.com/equation?tex=%5Clambda_%7Bcoord%7D" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=%5Clambda_%7Bnoobj%7D" alt="[公式]"> 都应该取怎样的值，为什么这样设计？</p><p>论文中给出的答案是 <img src="https://www.zhihu.com/equation?tex=%5Clambda_%7Bcoord%7D%3D5" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=%5Clambda_%7Bnoobj%7D+%3D+0.5" alt="[公式]"> ，也就是放大第一项和第二项的损失函数，缩小第四项的损失函数。</p><p>这样做的原因是让梯度更稳定，如果grid中不含有物体，它对1，2，3，5项没有影响，如果调节第四项，会让含有物体的grid的confidence发生改变，这可能使其他项的梯度剧烈变化，从而带来模型上的不稳定。</p><p>因此，我们放大第一项和第二项，缩小第四项。</p><p>YOLO的设计虽然精巧，但是还有许多不足的地方，比如一个grid只能识别出一种物体。我们会在YOLO v2和YOLO v3中看到更巧妙的设计。</p><p>此外，YOLO的bounding box的预测准确度是不如R-CNN这样的Region-based方法的，看YOLO v2里作者们怎么报复回来。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测介绍</title>
      <link href="/2022/09/08/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/09/08/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1>目标检测（Object Detection）</h1><h2 id="一、基本概念">一、基本概念</h2><h3 id="1-什么是目标检测">1. 什么是目标检测</h3><p>目标检测（Object Detection）的任务是找出图像中所有感兴趣的目标（物体），确定它们的类别和位置，是计算机视觉领域的核心问题之一。由于各类物体有不同的外观、形状和姿态，加上成像时光照、遮挡等因素的干扰，目标检测一直是计算机视觉领域最具有挑战性的问题。</p><p>计算机视觉中关于图像识别有四大类任务：</p><p>（1）分类-Classification：解决“是什么？”的问题，即给定一张图片或一段视频判断里面包含什么类别的目标。</p><p>（2）定位-Location：解决“在哪里？”的问题，即定位出这个目标的的位置。</p><p>（3）检测-Detection：解决“在哪里？是什么？”的问题，即定位出这个目标的位置并且知道目标物是什么。</p><p>（4）分割-Segmentation：分为实例的分割（Instance-level）和场景分割（Scene-level），解决“每一个像素属于哪个目标物或场景”的问题。<br><img src="https://img-blog.csdnimg.cn/2020112019245715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" style="zoom:67%;" /></p><p>所以，目标检测是一个分类、回归问题的叠加。</p><h3 id="2-目标检测的核心问题">2. 目标检测的核心问题</h3><p>（1）分类问题：即图片（或某个区域）中的图像属于哪个类别。</p><p>（2）定位问题：目标可能出现在图像的任何位置。</p><p>（3）大小问题：目标有各种不同的大小。</p><p>（4）形状问题：目标可能有各种不同的形状。</p><h3 id="3-目标检测算法分类">3. 目标检测算法分类</h3><p>基于深度学习的目标检测算法主要分为两类：Two stage和One stage。</p><h4 id="1）Tow-Stage">1）Tow Stage</h4><p>先进行区域生成，该区域称之为region proposal（简称RP，一个有可能包含待检物体的预选框），再通过卷积神经网络进行样本分类。</p><p>任务流程：特征提取 --&gt; 生成RP --&gt; 分类/定位回归。</p><p>常见tow stage目标检测算法有：R-CNN、SPP-Net、Fast R-CNN、Faster R-CNN和R-FCN等。</p><h4 id="2）One-Stage">2）One Stage</h4><p>不用RP，直接在网络中提取特征来预测物体分类和位置。</p><p>任务流程：特征提取–&gt; 分类/定位回归。</p><p>常见的one stage目标检测算法有：OverFeat、YOLOv1、YOLOv2、YOLOv3、SSD和RetinaNet等。</p><h3 id="4-目标检测应用">4. 目标检测应用</h3><h4 id="1）人脸检测">1）人脸检测</h4><ul><li>智能门控</li><li>员工考勤签到</li><li>智慧超市</li><li>人脸支付</li><li>车站、机场实名认证</li><li>公共安全：逃犯抓捕、走失人员检测</li></ul><h4 id="2）行人检测">2）行人检测</h4><ul><li>智能辅助驾驶</li><li>智能监控</li><li>暴恐检测（根据面相识别暴恐倾向）</li><li>移动侦测、区域入侵检测、安全帽/安全带检测</li></ul><h4 id="3）车辆检测">3）车辆检测</h4><ul><li>自动驾驶</li><li>违章查询、关键通道检测</li><li>广告检测（检测广告中的车辆类型，弹出链接）</li></ul><h4 id="4）遥感检测">4）遥感检测</h4><ul><li>大地遥感，如土地使用、公路、水渠、河流监控</li><li>农作物监控</li><li>军事检测</li></ul><h2 id="二、目标检测原理">二、目标检测原理</h2><p>目标检测分为两大系列——RCNN系列和YOLO系列，RCNN系列是基于区域检测的代表性算法，YOLO是基于区域提取的代表性算法，另外还有著名的SSD是基于前两个系列的改进。</p><h3 id="1-候选区域产生">1. 候选区域产生</h3><p>很多目标检测技术都会涉及候选框（bounding boxes）的生成，物体候选框获取当前主要使用图像分割与区域生长技术。区域生长(合并)主要由于检测图像中存在的物体具有局部区域相似性(颜色、纹理等)。目标识别与图像分割技术的发展进一步推动有效提取图像中信息。</p><h4 id="1）滑动窗口">1）滑动窗口</h4><p>通过滑窗法流程图可以很清晰理解其主要思路：首先对输入图像进行不同窗口大小的滑窗进行从左往右、从上到下的滑动。每次滑动时候对当前窗口执行分类器(分类器是事先训练好的)。如果当前窗口得到较高的分类概率，则认为检测到了物体。对每个不同窗口大小的滑窗都进行检测后，会得到不同窗口检测到的物体标记，这些窗口大小会存在重复较高的部分，最后采用非极大值抑制(Non-Maximum Suppression, NMS)的方法进行筛选。最终，经过NMS筛选后获得检测到的物体。<br>滑窗法简单易于理解，但是不同窗口大小进行图像全局搜索导致效率低下，而且设计窗口大小时候还需要考虑物体的长宽比。所以，对于实时性要求较高的分类器，不推荐使用滑窗法。<br><img src="https://img-blog.csdnimg.cn/20201120192524413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" style="zoom: 67%;" /></p><h4 id="2）选择性搜索">2）选择性搜索</h4><h5 id="①-什么是选择性搜索">① 什么是选择性搜索</h5><p>滑窗法类似穷举进行图像子区域搜索，但是一般情况下图像中大部分子区域是没有物体的。学者们自然而然想到只对图像中最有可能包含物体的区域进行搜索以此来提高计算效率。选择搜索（selective search，简称SS）方法是当下最为熟知的图像bounding boxes提取算法，由Koen E.A于2011年提出。<br>选择搜索算法的主要思想：图像中物体可能存在的区域应该是有某些相似性或者连续性区域的。因此，选择搜索基于上面这一想法采用子区域合并的方法进行提取bounding boxes。首先，对输入图像进行分割算法产生许多小的子区域。其次，根据这些子区域之间相似性(相似性标准主要有颜色、纹理、大小等等)进行区域合并，不断的进行区域迭代合并。每次迭代过程中对这些合并的子区域做bounding boxes(外切矩形)，这些子区域外切矩形就是通常所说的候选框。</p><img src="https://img-blog.csdnimg.cn/20201120192552221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" /><h5 id="②-选择搜索流程">② 选择搜索流程</h5><ul><li>step0：生成区域集R</li><li>step1：计算区域集R里每个相邻区域的相似度S={s1, s2,…}</li><li>step2：找出相似度最高的两个区域，将其合并为新集，添加进R</li><li>step3：从S中移除所有与step2中有关的子集</li><li>step4：计算新集与所有子集的相似度</li><li>step5：跳至step2，直至S为空</li></ul><h5 id="③-选择搜索优点">③ 选择搜索优点</h5><ul><li>计算效率优于滑窗法</li><li>由于采用子区域合并策略，所以可以包含各种大小的疑似物体框</li><li>合并区域相似的指标多样性，提高了检测物体的概率</li></ul><h3 id="2-数据表示">2. 数据表示</h3><p>经过标记后的样本数据如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20201120192610625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>预测输出可以表示为:</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/88db80965ad11a13.png" alt=""></p><h3 id="3-效果评估">3. 效果评估</h3><p>使用IoU（Intersection over Union，交并比）来判断模型的好坏。所谓交并比，是指预测边框、实际边框交集和并集的比率，一般约定0.5为一个可以接收的值。</p><p><img src="https://img-blog.csdnimg.cn/20201120192628252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><h3 id="4-非极大值抑制">4. 非极大值抑制</h3><p>预测结果中，可能多个预测结果间存在重叠部分，需要保留交并比最大的、去掉非最大的预测结果，这就是非极大值抑制（Non-Maximum Suppression，简写作NMS）。如下图所示，对同一个物体预测结果包含三个概率0.8/0.9/0.95，经过非极大值抑制后，仅保留概率最大的预测结果。<br><img src="https://img-blog.csdnimg.cn/20201120192646966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><h2 id="三、目标检测模型">三、目标检测模型</h2><h3 id="1-R-CNN系列">1. R-CNN系列</h3><h4 id="1）R-CNN">1）R-CNN</h4><h5 id="①-定义">① 定义</h5><p>R-CNN(全称Regions with CNN features) ，是R-CNN系列的第一代算法，其实没有过多的使用“深度学习”思想，而是将“深度学习”和传统的“计算机视觉”的知识相结合。比如R-CNN pipeline中的第二步和第四步其实就属于传统的“计算机视觉”技术。使用selective search提取region proposals，使用SVM实现分类。</p><img src="https://img-blog.csdnimg.cn/20201120192703441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" /><h5 id="②-流程">② 流程</h5><ul><li>预训练模型。选择一个预训练 （pre-trained）神经网络（如AlexNet、VGG）。</li><li>重新训练全连接层。使用需要检测的目标重新训练（re-train）最后全连接层（connected layer）。</li><li>提取 proposals并计算CNN 特征。利用选择性搜索（Selective Search）算法提取所有proposals（大约2000幅images），调整（resize/warp）它们成固定大小，以满足 CNN输入要求（因为全连接层的限制），然后将feature map 保存到本地磁盘。</li><li>训练SVM。利用feature map 训练SVM来对目标和背景进行分类（每个类一个二进制SVM）</li><li>边界框回归（Bounding boxes Regression）。训练将输出一些校正因子的线性回归分类器</li></ul><h5 id="③-效果">③ 效果</h5><ul><li>R-CNN在VOC 2007测试集上mAP达到58.5%，打败当时所有的目标检测算法</li></ul><h5 id="④-缺点">④ 缺点</h5><ul><li>重复计算，每个region proposal，都需要经过一个AlexNet特征提取，为所有的RoI（region of interest）提取特征大约花费47秒，占用空间。</li><li>selective search方法生成region proposal，对一帧图像，需要花费2秒。</li><li>三个模块（提取、分类、回归）是分别训练的，并且在训练时候，对于存储空间消耗较大。</li></ul><h4 id="2）Fast-R-CNN">2）Fast R-CNN</h4><h5 id="①-定义-2">① 定义</h5><p>Fast R-CNN是基于R-CNN和SPPnets进行的改进。SPPnets，其创新点在于只进行一次图像特征提取（而不是每个候选区域计算一次），然后根据算法，将候选区域特征图映射到整张图片特征图中。</p><img src="https://img-blog.csdnimg.cn/20201120192732956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" /><h5 id="②-流程-2">② 流程</h5><ul><li>使用selective search生成region proposal，大约2000个左右区域候选框</li><li>(joint training)缩放图片的scale得到图片金字塔，FP得到conv5的特征金字塔</li><li>(joint training)对于每个scale的每个ROI，求取映射关系，在conv5中剪裁出对应的patch。并用一个单层的SSP layer来统一到一样的尺度（对于AlexNet是6*6）</li><li>(joint training) 继续经过两个全连接得到特征，这特征又分别共享到两个新的全连接，连接上两个优化目标。第一个优化目标是分类，使用softmax，第二个优化目标是bbox regression，使用了一个平滑的L1-loss</li><li>测试时需要加上NMS处理：利用窗口得分分别对每一类物体进行非极大值抑制提出重叠建议框，最终得到每个类别中回归修正后的得分最高的窗口</li></ul><h5 id="③-改进">③ 改进</h5><ul><li>和RCNN相比，训练时间从84小时减少为9.5小时，测试时间从47秒减少为0.32秒。在VGG16上，Fast RCNN</li><li>训练速度是RCNN的9倍，测试速度是RCNN的213倍；训练速度是SPP-net的3倍，测试速度是SPP-net的3倍<br>Fast RCNN在PASCAL VOC 2007上准确率相差无几，约在66~67%之间</li><li>加入RoI Pooling，采用一个神经网络对全图提取特征</li><li>在网络中加入了多任务函数边框回归，实现了端到端的训练</li></ul><h5 id="④-缺点-2">④ 缺点</h5><ul><li>依旧采用selective search提取region proposal（耗时2~3秒，特征提取耗时0.32秒）</li><li>无法满足实时应用，没有真正实现端到端训练测试</li><li>利用了GPU，但是region proposal方法是在CPU上实现的</li></ul><h4 id="3）Faster-RCNN">3）Faster RCNN</h4><p>经过R-CNN和Fast-RCNN的积淀，Ross B.Girshick在2016年提出了新的Faster RCNN，在结构上将特征抽取、region proposal提取， bbox regression，分类都整合到了一个网络中，使得综合性能有较大提高，在检测速度方面尤为明显。<br><img src="https://img-blog.csdnimg.cn/20201120192749192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" /></p><h5 id="①-整体流程">① 整体流程</h5><ul><li>Conv Layers。作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础的卷积/激活/池化层提取图像的特征，形成一个特征图，用于后续的RPN层和全连接层。</li><li>Region Proposal Networks（RPN）。RPN网络用于生成候选区域，该层通过softmax判断锚点（anchors）属于前景还是背景，在利用bounding box regression（包围边框回归）获得精确的候选区域。</li><li>RoI Pooling。该层收集输入的特征图和候选区域，综合这些信息提取候选区特征图（proposal feature maps），送入后续全连接层判定目标的类别。</li><li>Classification。利用取候选区特征图计算所属类别，并再次使用边框回归算法获得边框最终的精确位置。</li></ul><h5 id="②-Anchors">② Anchors</h5><p>Anchors（锚点）指由一组矩阵，每个矩阵对应不同的检测尺度大小。如下矩阵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[ -84.  -40.  99.  55.]</span><br><span class="line"> [-176.  -88. 191. 103.]</span><br><span class="line"> [-360. -184. 375. 199.]</span><br><span class="line"> [ -56.  -56.  71.  71.]</span><br><span class="line"> [-120. -120. 135. 135.]</span><br><span class="line"> [-248. -248. 263. 263.]</span><br><span class="line"> [ -36.  -80.  51.  95.]</span><br><span class="line"> [ -80. -168.  95. 183.]</span><br><span class="line"> [-168. -344. 183. 359.]]</span><br></pre></td></tr></table></figure><p>其中每行4个值（x 1 , y 1 , x 2 , y 2 x_1, y_1, x_2, y_2），对应矩形框左上角、右下角相对于中心点的偏移量。9个矩形共有三种形状，即1:1, 1:2, 2:1，即进行多尺度检测。<br><img src="https://img-blog.csdnimg.cn/20201120192806110.png#pic_center" alt="img"></p><p>例如，一张800<em>600的原始图片，经过VGG下采样后(生成特征矩阵)16倍大小，大小变为50</em>38，每个点设置9个anchor，则总数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceil(800 / 16) * ceil(600 / 16) * 9 = 50 * 38 * 9 = 17100</span><br></pre></td></tr></table></figure><h5 id="③-Bounding-box-regression">③ Bounding box regression</h5><p>物体识别完成后，通过一种方式对外围框进行调整，使得和目标物体更加接近。</p><h5 id="④-损失函数">④ 损失函数</h5><p>对一个图像的损失函数，是一个分类损失函数与回归损失函数的叠加：</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/2640e388ff45ed2c.png" alt=""></p><p><img src="https://s3.bmp.ovh/imgs/2021/08/2badf056cfad5b0d.png" alt=""></p><h5 id="⑤-改进">⑤ 改进</h5><ul><li>在VOC2007测试集测试mAP达到73.2%，目标检测速度可达5帧/秒</li><li>提出Region Proposal Network(RPN)，取代selective search，生成待检测区域，时间从2秒缩减到了10毫秒</li><li>真正实现了一个完全的End-To-End的CNN目标检测模型</li><li>共享RPN与Fast RCNN的特征</li></ul><h5 id="⑥-缺点">⑥ 缺点</h5><ul><li>还是无法达到实时检测目标</li><li>获取region proposal， 再对每个proposal分类计算量还是较大</li></ul><h3 id="2-YOLO系列">2. YOLO系列</h3><h4 id="1）YOLOv1（2016）">1）YOLOv1（2016）</h4><h5 id="①-基本思想">① 基本思想</h5><p>YOLO（You Only Look Once ）是继RCNN，fast-RCNN和faster-RCNN之后，Ross Girshick针对DL目标检测速度问题提出的另一种框架，其核心思想是生成RoI+目标检测两阶段（two-stage）算法用一套网络的一阶段（one-stage）算法替代，直接在输出层回归bounding box的位置和所属类别。</p><p>之前的物体检测方法首先需要产生大量可能包含待检测物体的先验框, 然后用分类器判断每个先验框对应的边界框里是否包含待检测物体，以及物体所属类别的概率或者置信度，同时需要后处理修正边界框，最后基于一些准则过滤掉置信度不高和重叠度较高的边界框，进而得到检测结果。这种基于先产生候选区再检测的方法虽然有相对较高的检测准确率，但运行速度较慢。</p><p>YOLO创造性的将物体检测任务直接当作回归问题（regression problem）来处理，将候选区和检测两个阶段合二为一。只需一眼就能知道每张图像中有哪些物体以及物体的位置。下图展示了各物体检测系统的流程图。</p><p><img src="https://img-blog.csdnimg.cn/20201120192837724.png#pic_center" alt="img"></p><p>实际上，YOLO并没有真正去掉候选区，而是采用了预定义候选区的方法，也就是将图片划分为7乘7个网格，每个网格允许预测出2个边框，总共49乘2个bounding box，可以理解为98个候选区域，它们很粗略地覆盖了图片的整个区域。YOLO以降低mAP为代价，大幅提升了时间效率。</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/4bdc7ae880029f3e.png" alt=""></p><p>每个网格单元预测这些框的2个边界框和置信度分数。这些置信度分数反映了该模型对框是否包含目标的可靠程度，以及它预测框的准确程度。置信度定义为：</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/b5c480620f6ffbab.png" alt=""></p><h5 id="②-网络结构">② 网络结构</h5><p>YOLOv1网络有24个卷积层，后面是2个全连接层。我们只使用1 × 1 1 \times 11×1降维层，后面是3 × 3 3 \times 33×3卷积层。如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201120193019288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>为了快速实现快速目标检测，YOLOV1还训练了快速版本。快速YOLO使用具有较少卷积层（9层而不是24层）的神经网络，在这些层中使用较少的滤波器。除了网络规模之外，YOLO和快速YOLO的所有训练和测试参数都是相同的。网络的最终输出是7 <em>7</em> 30(1470)的预测张量。</p><h5 id="③-训练过程与细节">③ 训练过程与细节</h5><p>（1）预训练。采用前20个卷积层、平均池化层、全连接层进行了大约一周的预训练；</p><p>（2）输入。输入数据为224<em>224和448</em>448大小的图像；</p><p>（3）采用相对坐标。通过图像宽度和高度来规范边界框的宽度和高度，使它们落在0和1之间；边界框x xx和y yy坐标参数化为特定网格单元位置的偏移量，边界也在0和1之间；</p><p>（4）损失函数<br><img src="https://img-blog.csdnimg.cn/2020112019303663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p><img src="https://s3.bmp.ovh/imgs/2021/08/79afbbff8e1fa170.png" alt=""></p><p>（5）学习率。第一个迭代周期，慢慢地将学习率从1 0 − 3 10^{-3}10 −3 提高到1 0 − 2 10^{-2}10 −2 ；然后继续以1 0 − 2 10^{-2}10 −2 的学习率训练75个迭代周期，用1 0 − 3 10^{-3}10 −3 的学习率训练30个迭代周期，最后用1 0 − 4 10^{-4}10 −4 的学习率训练30个迭代周期。</p><p>（6）避免过拟合策略。使用dropout和数据增强来避免过拟合。</p><h5 id="④-优点与缺点">④ 优点与缺点</h5><p>（1）优点</p><ul><li>YOLO检测物体速度非常快，其增强版GPU中能跑45fps（frame per second），简化版155fps</li><li>YOLO在训练和测试时都能看到一整张图的信息（而不像其它算法看到局部图片信息），因此YOLO在检测物体是能很好利用上下文信息，从而不容易在背景上预测出错误的物体信息</li><li>YOLO可以学到物体泛化特征</li></ul><p>（2）缺点</p><ul><li>精度低于其它state-of-the-art的物体检测系统</li><li>容易产生定位错误</li><li>对小物体检测效果不好，尤其是密集的小物体，因为一个栅格只能检测2个物体</li><li>由于损失函数的问题，定位误差是影响检测效果的主要原因，尤其是大小物体处理上还有待加强</li></ul><h4 id="2）YOLOv2（2016）">2）YOLOv2（2016）</h4><p>Ross Girshick吸收fast-RCNN和SSD算法，设计了YOLOv2（论文原名《YOLO9000: Better, Faster, Stronger 》），在精度上利用一些列训练技巧，在速度上应用了新的网络模型DarkNet19，在分类任务上采用联合训练方法，结合wordtree等方法，使YOLOv2的检测种类扩充到了上千种，作者在论文中称可以检测超过9000个目标类别，所以也称YOLO9000. YOLOv2模型可以以不同的尺寸运行，从而在速度和准确性之间提供了一个简单的折衷，在67FPS时，YOLOv2在VOC 2007上获得了76.8 mAP。在40FPS时，YOLOv2获得了78.6 mAP，比使用ResNet的Faster R-CNN和SSD等先进方法表现更出色，同时仍然运行速度显著更快。</p><h5 id="①-改进策略">① 改进策略</h5><p>YOLOv2对YOLOv1采取了很多改进措施，以提高模型mAP，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20201120193054397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>**（1）Batch Normalization（批量正则化）。**YOLOv2中在每个卷积层后加Batch Normalization(BN)层，去掉dropout. BN层可以起到一定的正则化效果，能提升模型收敛速度，防止模型过拟合。YOLOv2通过使用BN层使得mAP提高了2%。</p><p>**（2）High Resolution Classifier（高分辨率分类器）。**原来的YOLO网络在预训练的时候采用的是224<em>224的输入（这是因为一般预训练的分类模型都是在ImageNet数据集上进行的），然后在detection的时候采用448</em>448的输入，这会导致从分类模型切换到检测模型的时候，模型还要适应图像分辨率的改变。而YOLOv2则将预训练分成两步：先用224<em>224的输入从头开始训练网络，大概160个epoch（表示将所有训练数据循环跑160次），然后再将输入调整到448</em>448，再训练10个epoch。注意这两步都是在ImageNet数据集上操作。最后再在检测的数据集上fine-tuning，也就是detection的时候用448<em>448的图像作为输入就可以顺利过渡了。作者的实验表明这样可以提高几乎4%的mAP。</em></p><p><strong>（3）Convolutional With Anchor Boxes（带Anchor Boxes的卷积）。</strong> YOLOv1利用全连接层直接对边界框进行预测，导致丢失较多空间信息，定位不准。YOLOv2去掉了YOLOv1中的全连接层，使用Anchor Boxes预测边界框，同时为了得到更高分辨率的特征图，YOLOv2还去掉了一个池化层。由于图片中的物体都倾向于出现在图片的中心位置，若特征图恰好有一个中心位置，利用这个中心位置预测中心点落入该位置的物体，对这些物体的检测会更容易。所以总希望得到的特征图的宽高都为奇数。YOLOv2通过缩减网络，使用416<em>416的输入，模型下采样的总步长为32，最后得到13</em>13的特征图，然后对13<em>13的特征图的每个cell预测5个anchor boxes，对每个anchor box预测边界框的位置信息、置信度和一套分类概率值。使用anchor boxes之后，YOLOv2可以预测13</em>13*5=845个边界框，模型的召回率由原来的81%提升到88%，mAP由原来的69.5%降低到69.2%.召回率提升了7%，准确率下降了0.3%。</p><p><strong>（4）Dimension Clusters（维度聚类）</strong>。在Faster R-CNN和SSD中，先验框都是手动设定的，带有一定的主观性。YOLOv2采用k-means聚类算法对训练集中的边界框做了聚类分析，选用boxes之间的IOU值作为聚类指标。综合考虑模型复杂度和召回率，最终选择5个聚类中心，得到5个先验框，发现其中中扁长的框较少，而瘦高的框更多，更符合行人特征。通过对比实验，发现用聚类分析得到的先验框比手动选择的先验框有更高的平均IOU值，这使得模型更容易训练学习。<br><img src="https://img-blog.csdnimg.cn/20201120193112629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>VOC和COCO的聚类边界框尺寸。我们对边界框的维度进行k-means聚类，以获得我们模型的良好先验。左图显示了我们通过对k的各种选择得到的平均IOU。我们发现k=5给出了一个很好的召回率与模型复杂度的权衡。右图显示了VOC和COCO的相对中心。这两种先验都赞成更薄更高的边界框，而COCO比VOC在尺寸上有更大的变化。<br><strong>（5）New Network（新的网络）</strong>。 YOLOv2采用Darknet-19，其网络结构如下图所示，包括19个卷积层和5个max pooling层，主要采用3<em>3卷积和1</em>1卷积，这里1*1卷积可以压缩特征图通道数以降低模型计算量和参数，每个卷积层后使用BN层以加快模型收敛同时防止过拟合。最终采用global avg pool 做预测。采用YOLOv2，模型的mAP值没有显著提升，但计算量减少了。<br><img src="https://img-blog.csdnimg.cn/202011201932079.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p><strong>（6）直接定位预测（Direct location Prediction）</strong>。 Faster R-CNN使用anchor boxes预测边界框相对先验框的偏移量，由于没有对偏移量进行约束，每个位置预测的边界框可以落在图片任何位置，会导致模型不稳定，加长训练时间。YOLOv2沿用YOLOv1的方法，根据所在网格单元的位置来预测坐标,则Ground Truth的值介于0到1之间。网络中将得到的网络预测结果再输入sigmoid函数中，让输出结果介于0到1之间。设一个网格相对于图片左上角的偏移量是Cx,Cy。先验框的宽度和高度分别是Pw和Ph，<br>，则预测的边界框相对于特征图的中心坐标 (b_x，b_y)和宽高bw,bh的计算公式如下图所示。</p><img src="https://img-blog.csdnimg.cn/20201120193221389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" /><p>其中，σ为sigmoid函数；tx，ty是<strong>预测</strong>的坐标偏移值（中心点坐标）；tw，th是尺度缩放，分别经过sigmoid，输出0-1之间的偏移量，与cx，cy相加后得到bounding box中心点的位置。</p><p><strong>（7）细粒度特征（Fine-Grained Features）</strong>。 YOLOv2借鉴SSD使用多尺度的特征图做检测，提出pass through层将高分辨率的特征图与低分辨率的特征图联系在一起，从而实现多尺度检测。YOLOv2提取Darknet-19最后一个max pool层的输入，得到26<em>26</em>512的特征图。经过1<em>1</em>64的卷积以降低特征图的维度，得到26<em>26</em>64的特征图，然后经过pass through层的处理变成13<em>13</em>256的特征图（抽取原特征图每个2<em>2的局部区域组成新的channel，即原特征图大小降低4倍，channel增加4倍），再与13</em>13<em>1024大小的特征图连接，变成13</em>13*1280的特征图，最后在这些特征图上做预测。使用Fine-Grained Features，YOLOv2的性能提升了1%。<br><strong>（8）多尺度训练（Multi-Scale Training）</strong>。 YOLOv2中使用的Darknet-19网络结构中只有卷积层和池化层，所以其对输入图片的大小没有限制。YOLOv2采用多尺度输入的方式训练，在训练过程中每隔10个batches,重新随机选择输入图片的尺寸，由于Darknet-19下采样总步长为32，输入图片的尺寸一般选择32的倍数{320,352,…,608}（最小的选项是320×320，最大的是608×608。我们调整网络的尺寸并继续训练）。采用Multi-Scale Training, 可以适应不同大小的图片输入，当采用低分辨率的图片输入时，mAP值略有下降，但速度更快，当采用高分辨率的图片输入时，能得到较高mAP值，但速度有所下降。</p><p><img src="https://img-blog.csdnimg.cn/20201120193236251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>YOLOv2比先前的检测方法更快，更准确。它也可以以不同的分辨率运行，以便在速度和准确性之间进行简单折衷</p><h5 id="②-训练过程">② 训练过程</h5><ul><li>第一阶段：现在ImageNet分类数据集上训练Darknet-19,此时模型输入为224**224，共训练160轮*</li><li>第二阶段：将网络输入调整为448*448，继续在ImageNet分类数据集上训练细调模型，共10轮，此时分类模型top-1准确率为76.5%，而top-5准确度为93.3%</li><li>第三阶段：修改Darknet-19分类模型为检测模型，并在检测数据集上继续细调网络</li></ul><h5 id="③-优点与缺点">③ 优点与缺点</h5><p>（1）优点</p><ul><li>YOLOv2使用了一个新的分类器作为特征提取部分，较多使用了3<em>3卷积核，在每次池化后操作后把通道数翻倍。网络使用了全局平均池化，把1</em>1卷积核置于3*3卷积核之间，用来压缩特征。也用了batch normalization稳定模型训练</li><li>最终得出的基础模型就是Darknet-19，包含19个卷积层，5个最大池化层，运算次数55.8亿次，top-1图片分类准确率72.9%，top-5准确率91.2%</li><li>YOLOv2比VGG16更快，精度略低于VGG16</li></ul><p>（2）缺点</p><ul><li>YOLOv2检测准确率不够，比SSD稍差</li><li>不擅长检测小物体</li><li>对近距离物体准确率较低</li></ul><h4 id="3）YOLOv3（2018）">3）YOLOv3（2018）</h4><p>YOLOv3总结了自己在YOLOv2的基础上做的一些尝试性改进，有的尝试取得了成功，而有的尝试并没有提升模型性能。其中有两个值得一提的亮点，一个是使用残差模型，进一步加深了网络结构；另一个是使用FPN架构实现多尺度检测。</p><h5 id="①-改进">① 改进</h5><ul><li>新网络结构：DarkNet-53；</li><li>用逻辑回归替代softmax作为分类器；</li><li>融合FPN（特征金字塔网络），实现多尺度检测。</li></ul><h5 id="②-多尺度预测">② 多尺度预测</h5><p>YOLOv3在基本特征提取器上添加几个卷积层，其中最后一个卷积层预测了一个三维张量——边界框，目标和类别预测。 在COCO实验中，为每个尺度预测3个框，所以对于4个边界框偏移量，1个目标预测和80个类别预测，张量的大小为N×N×[3 *（4 + 1 + 80）]。接下来，从前面的2个层中取得特征图，并将其上采样2倍。</p><p>YOLOv3还从网络中的较前的层中获取特征图，并使用按元素相加的方式将其与上采样特征图进行合并。这种方法使得能够从上采样的特征图中获得更有意义的语义信息，同时可以从更前的层中获取更细粒度的信息。然后，再添加几个卷积层来处理这个组合的特征图，并最终预测出一个类似的张量，虽然其尺寸是之前的两倍。</p><p>最后，再次使用相同的设计来预测最终尺寸的边界框。因此，第三个尺寸的预测将既能从所有先前的计算，又能从网络前面的层中的细粒度的特征中获益。</p><h5 id="③-网络结构">③ 网络结构</h5><p>YOLOv3在之前Darknet-19的基础上引入了残差块，并进一步加深了网络，改进后的网络有53个卷积层，取名为Darknet-53，网络结构如下图所示（以256*256的输入为例）：</p><p><img src="https://img-blog.csdnimg.cn/20201120193258860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>从YOLOv1到YOLOv2再到YOLO9000、YOLOv3, YOLO经历三代变革，在保持速度优势的同时，不断改进网络结构，同时汲取其它优秀的目标检测算法的各种trick，先后引入anchor box机制、引入FPN实现多尺度检测等。</p><p><img src="https://img-blog.csdnimg.cn/2020112019331279.png#pic_center" alt="img"></p><p>不同backbone的各种网络在准确度，billions of operations，billion floating point operations per second和FPS上的比较<br>每个网络都使用相同的设置进行训练，并在256×256的图像上进行单精度测试。 运行时间是在Titan X上用256×256图像进行测量的。因此，Darknet-53可与最先进的分类器相媲美，但浮点运算更少，速度更快。 Darknet-53比ResNet-101更好，且速度快1.5倍。 Darknet-53与ResNet-152具有相似的性能，但速度快2倍。</p><p>Darknet-53也实现了最高的每秒浮点运算测量。 这意味着网络结构可以更好地利用GPU，使它的评测更加高效，更快。 这主要是因为ResNet的层数太多，效率不高。</p><h5 id="④-效果">④ 效果</h5><p>（1）兼顾速度与准确率。在COCO数据机上，mAP指标与SSD模型相当，但速度提高了3倍；mAP指标比RetinaNet模型差些，但速度要高3.8倍。</p><p><img src="https://img-blog.csdnimg.cn/20201120193326411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20201120193333780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>当然，YOLOv3也有些失败的尝试，并未起到有效作用，请自行查阅原始论文。</p><h2 id="三、视频关键帧处理">三、视频关键帧处理</h2><p>例如，需要从一台晚会中抹去某个违法明星的视频，如果视频每秒25帧，采用逐帧扫描，每处理一帧需要2秒，则需要的处理时间为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间 = 4 * 3600 * 25 * 2</span><br></pre></td></tr></table></figure><p>共需要200个小时才能处理完成。所以就需要借助关键帧来提高处理速度，降低目标检测复杂度。</p><h3 id="1-什么是关键帧">1. 什么是关键帧</h3><p>关键帧（I-Frame）：</p><ul><li>关键帧是包含该段视频中主要信息的帧</li><li>关键帧在压缩成AVI, MP4, MOV等格式时，该帧会完全保留</li><li>视频解码时只需要本帧数据，不需要从前一帧、后一帧获取数据</li></ul><p>前向差别帧（P-Frame）</p><ul><li>当前帧与前一个I-Frame或前一个P-Frame之间的差别，可以理解为与前一帧的数据偏移值</li><li>P-Frame没有完整数据画面，只有与前一帧的差别信息，解码时需要从前一帧获取数据</li></ul><p>双向差别帧（B-Frame）</p><ul><li>记录本帧与前一帧、后一帧的差别</li><li>解码时需要获取前一帧、后一帧的数据</li><li>压缩后的视频体积小，但编解码计算较慢</li></ul><h3 id="2-如何提取关键帧">2. 如何提取关键帧</h3><p>可以使用FFMPEG工具提取视频中的关键帧。</p><p><img src="https://img-blog.csdnimg.cn/20201120193423149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>也可以使用FFMPEG工具进行视频截取。</p><p><img src="https://img-blog.csdnimg.cn/20201120193436718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3llZ2VsaQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><h2 id="四、目标检测数据集">四、目标检测数据集</h2><h3 id="1-PASCAL-VOC">1. PASCAL VOC</h3><p>VOC数据集是目标检测经常用的一个数据集，自2005年起每年举办一次比赛，最开始只有4类，到2007年扩充为20个类，共有两个常用的版本：2007和2012。学术界常用5k的train/val 2007和16k的train/val 2012作为训练集，test 2007作为测试集，用10k的train/val 2007+test 2007和16k的train/val 2012作为训练集，test2012作为测试集，分别汇报结果。</p><h3 id="2-MS-COCO">2. MS COCO</h3><p>COCO数据集是微软团队发布的一个可以用来图像recognition+segmentation+captioning 数据集，该数据集收集了大量包含常见物体的日常场景图片，并提供像素级的实例标注以更精确地评估检测和分割算法的效果，致力于推动场景理解的研究进展。依托这一数据集，每年举办一次比赛，现已涵盖检测、分割、关键点识别、注释等机器视觉的中心任务，是继ImageNet Challenge以来最有影响力的学术竞赛之一。</p><p>相比ImageNet，COCO更加偏好目标与其场景共同出现的图片，即non-iconic images。这样的图片能够反映视觉上的语义，更符合图像理解的任务要求。而相对的iconic images则更适合浅语义的图像分类等任务。</p><p>COCO的检测任务共含有80个类，在2014年发布的数据规模分train/val/test分别为80k/40k/40k，学术界较为通用的划分是使用train和35k的val子集作为训练集（trainval35k），使用剩余的val作为测试集（minival），同时向官方的evaluation server提交结果（test-dev）。除此之外，COCO官方也保留一部分test数据作为比赛的评测集。</p><h3 id="3-Google-Open-Image">3. Google Open Image</h3><p>Open Image是谷歌团队发布的数据集。最新发布的Open Images V4包含190万图像、600个种类，1540万个bounding-box标注，是当前最大的带物体位置标注信息的数据集。这些边界框大部分都是由专业注释人员手动绘制的，确保了它们的准确性和一致性。另外，这些图像是非常多样化的，并且通常包含有多个对象的复杂场景（平均每个图像 8 个）。</p><h3 id="4-ImageNet">4. ImageNet</h3><p>ImageNet是一个计算机视觉系统识别项目， 是目前世界上图像识别最大的数据库。ImageNet是美国斯坦福的计算机科学家，模拟人类的识别系统建立的。能够从图片识别物体。ImageNet数据集文档详细，有专门的团队维护，使用非常方便，在计算机视觉领域研究论文中应用非常广，几乎成为了目前深度学习图像领域算法性能检验的“标准”数据集。ImageNet数据集有1400多万幅图片，涵盖2万多个类别；其中有超过百万的图片有明确的类别标注和图像中物体位置的标注。</p><h2 id="五、常用图像标注工具">五、常用图像标注工具</h2><h3 id="1-LabelImg">1. LabelImg</h3><p>1）LabelImg 是一款开源的图像标注工具，标签可用于分类和目标检测，它是用 Python 编写的，并使用Qt作为其图形界面，简单好用。注释以 PASCAL VOC 格式保存为 XML 文件，这是 ImageNet 使用的格式。 此外，它还支持 COCO 数据集格式。</p><p>2）安装方法：</p><p>前置条件：安装Python3以上版本，安装pyqt5<br>第一步：下载安装包<br>第二步：使用Pycharm打开项目，运行labelImg.py文件；或直接运行labelImg.py文件</p><p>3）常见错误处理：</p><p>① 报错：ModuleNotFoundError: No module named ‘libs.resources’</p><ul><li>处理方式：<ul><li>将python下scripts添加到环境变量path中</li><li>在labelImg目录下执行命令：pyrcc5 -o <a href="http://resources.py">resources.py</a> resources.qrc</li><li>将生成的resources.py拷贝到labelImg/libs/下</li><li>执行labelImg.py程序</li></ul></li></ul><h3 id="2-Labelme">2. Labelme</h3><p>labelme 是一款开源的图像/视频标注工具，标签可用于目标检测、分割和分类。灵感是来自于 MIT 开源的一款标注工具 Labelme。Labelme具有的特点是：</p><ul><li>支持图像的标注的组件有：矩形框，多边形，圆，线，点（rectangle, polygons, circle, lines, points）</li><li>支持视频标注</li><li>GUI 自定义</li><li>支持导出 VOC 格式用于 semantic/instance segmentation</li><li>支出导出 COCO 格式用于 instance segmentation</li></ul><h3 id="3-Labelbox">3. Labelbox</h3><p>Labelbox 是一家为机器学习应用程序创建、管理和维护数据集的服务提供商，其中包含一款部分免费的数据标签工具，包含图像分类和分割，文本，音频和视频注释的接口，其中图像视频标注具有的功能如下：</p><ul><li>可用于标注的组件有：矩形框，多边形，线，点，画笔，超像素等（bounding box, polygons, lines, points，brush, subpixels）</li><li>标签可用于分类，分割，目标检测等</li><li>以 JSON / CSV / WKT / COCO / Pascal VOC 等格式导出数据</li><li>支持 Tiled Imagery (Maps)</li><li>支持视频标注 （快要更新）</li></ul><h3 id="4-RectLabel">4. RectLabel</h3><p>RectLabel 是一款在线免费图像标注工具，标签可用于目标检测、分割和分类。具有的功能或特点：</p><ul><li>可用的组件：矩形框，多边形，三次贝塞尔曲线，直线和点，画笔，超像素</li><li>可只标记整张图像而不绘制</li><li>可使用画笔和超像素</li><li>导出为YOLO，KITTI，COCO JSON和CSV格式</li><li>以PASCAL VOC XML格式读写</li><li>使用Core ML模型自动标记图像</li><li>将视频转换为图像帧</li></ul><h3 id="5-CVAT">5. CVAT</h3><p>CVAT 是一款开源的基于网络的交互式视频/图像标注工具，是对加州视频标注工具（Video Annotation Tool） 项目的重新设计和实现。OpenCV团队正在使用该工具来标注不同属性的数百万个对象，许多 UI 和 UX 的决策都基于专业数据标注团队的反馈。具有的功能</p><ul><li>关键帧之间的边界框插值</li><li>自动标注（使用TensorFlow OD API 和 Intel OpenVINO IR格式的深度学习模型</li></ul><h3 id="6-VIA">6. VIA</h3><p>VGG Image Annotator（VIA）是一款简单独立的手动注释软件，适用于图像，音频和视频。 VIA 在 Web 浏览器中运行，不需要任何安装或设置。 页面可在大多数现代Web浏览器中作为离线应用程序运行。</p><ul><li>支持标注的区域组件有：矩形，圆形，椭圆形，多边形，点和折线</li></ul><h2 id="附录：术语表">附录：术语表</h2><table><thead><tr><th>英文全写</th><th>英文简写</th><th>中文名称</th></tr></thead><tbody><tr><td>one stage</td><td></td><td>一阶段检测</td></tr><tr><td>two stage</td><td></td><td>两阶段检测</td></tr><tr><td>region proposal</td><td>RP</td><td>候选区域（一个有可能包含待检物体的预选框）</td></tr><tr><td>bounding boxes</td><td>bb</td><td>候选框</td></tr><tr><td>Non-Maximum Suppression</td><td>NMS</td><td>非极大值抑制</td></tr><tr><td>selective search</td><td>SS</td><td>选择搜索</td></tr><tr><td>Regions with CNN features</td><td>R-CNN</td><td></td></tr><tr><td>region of interest</td><td>RoI</td><td>感兴趣区域（候选区域）</td></tr><tr><td>You Only Look Once</td><td>YOLO</td><td></td></tr><tr><td>frame per second</td><td>fps</td><td>帧每秒</td></tr><tr><td>High Resolution Classifier</td><td></td><td>高分辨率分类器</td></tr><tr><td>Batch Normalization</td><td>BN</td><td>批量正则化</td></tr><tr><td>Mean Average Precision</td><td>mAP</td><td>平均精度均值</td></tr><tr><td>Intersection over Union</td><td>IOU</td><td>交并比（“预测的边框” 和 “真实的边框” 的交集和并集的比值）</td></tr><tr><td>Fine-Grained Features</td><td></td><td>细粒度特征</td></tr><tr><td>Feature Pyramid Network</td><td>FPN</td><td>特征金字塔网络</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN的进化</title>
      <link href="/2022/09/08/CNN%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
      <url>/2022/09/08/CNN%E7%9A%84%E8%BF%9B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1>10.31报告</h1><p>参考自：<a href="https://blog.csdn.net/wjinjie/article/details/105930512">R-CNN系列算法精讲：R-CNN —》Fast R-CNN —》Faster R-CNN 进阶之路</a></p><p>​<a href="https://blog.csdn.net/weixin_37763870/article/details/103098532?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163555705116780366567006%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163555705116780366567006&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-103098532.first_rank_v2_pc_rank_v29&amp;utm_term=CNN&amp;spm=1018.2226.3001.4187">深度学习——CNN(卷积神经网络)</a></p><p>​<a href="https://www.zhihu.com/question/66954030/answer/715416325">如何理解<em>CNN</em>中的<em>感受野</em>（receptive-field）？</a></p><p>​</p><h2 id="一、进击的网络-CNN-DNN">一、进击的网络(CNN/DNN)</h2><h3 id="1-1-DNN与CNN区别（卷积神经网络）">1.1 DNN与CNN区别（卷积神经网络）</h3><img src="https://img-blog.csdnimg.cn/20191116145026770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2Mzg3MA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" /><p><em>上图为DNN深度神经网络图</em></p><p>DNN（(Deep Neural Networks，<em>DNN</em>）内部的神经网络层可以分为三类，<strong>输入层，隐藏层和输出层</strong>，一般来说第一层是输出层，最后一层是输出层，而中间的层数都是隐藏层。</p><img src="https://img-blog.csdnimg.cn/2019111615080290.png" alt="img" style="zoom:67%;" /><p><em>上图为CNN神经网络</em></p><p>卷积神经网络（convolutional neural network, CNN），是一种专门用来处理<strong>具有类似网格结构的数据的神经网络</strong>。<strong>卷积网络</strong>是指那些至少在网络的一层中使用卷积运算来替代一般的矩阵乘法运算的神经网络。</p><p><strong>总结：</strong></p><p>（1）DNN是一种最简单的神经网络。各个神经元分别属于不同的层，每个神经元和前一层的所有神经元相连接，信号从输入层向输出层单向传播。</p><p>（2）CNN是一种通过<strong>卷积计算</strong>的前馈神经网络，其是受生物学上的感受野机制提出的，具有平移不变性，使用卷积核，最大的应用了局部信息，保留了平面结构信息。</p><p>（3）DNN以<strong>向量形式</strong>输入，未考虑平面的结构信息，而在图像领域和自然语言处理领域，平面信息很重要，因此CNN比DNN处理结果更好。由于DNN、CNN的输入、输出长度固定，而自然语言处理中的语句长度通常不固定，所以DNN、CNN处理这种问题效率较低，且无法处理时序相关的序列问题.为了解决这些问题，出现了循环神经网络RNN。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CNN给我的感觉就像滚雪球，不过这个雪球是反着滚的，把一个大的雪人（图片）通过均匀在道路（神经网络）上滚。</span><br><span class="line">越滚越越远（网络越来越深）。最后滚成一个类别之类的东西也。</span><br></pre></td></tr></table></figure><img src="http://a1.qpic.cn/psc?/V12XQ1QV3cpyPD/05RlWl8gsTOH*Z17MtCBzCd93QTLQdc5OrCRkV5gdbcxL4CXWlM00VUAU7lP9vw8zTe6gw.5kn7uoZtXqssJMA!!/b&ek=1&kp=1&pt=0&bo=SQJSAUkCUgEDACU!&tl=1&vuin=1005741898&tm=1636009200&sce=50-1-1&rf=4-0" style="zoom:67%;" /><h3 id="1-2-CNN的五种结构组成">1.2 CNN的五种结构组成</h3><h4 id="1-2-1-输入层">1.2.1 输入层</h4><p>​在处理图像的CNN中，输入层一般代表了<strong>一张图片的像素矩阵</strong>。可以用<strong>三维矩阵代表一张图片</strong>。三维矩阵的长和宽代表了图像的大小，而三维矩阵的深度代表了图像的色彩通道。比如<strong>黑白图片的深度为1，而在RGB色彩模式下，图像的深度为3。</strong>  类似这样一张64×64的jpg文件，本质上是3×64×64，三维矩阵。</p><h4 id="1-2-2-卷积层-Convolution-Layer">1.2.2 卷积层(Convolution Layer)</h4><p>​**卷积层是CNN最重要的部分。**它与传统全连接层不同，卷积层中每一个节点的输入只是上一层神经网络的一小块。卷积层被称为过滤器(filter)或者内核(kernel)，Tensorflow的官方文档中称这个部分为过滤器(filter)。<br>【注意】在一个卷积层中，过滤器(filter)所处理的节点矩阵的长和宽都是由人工指定的，这个节点矩阵的尺寸也被称为过滤器尺寸。常用的尺寸有3x3或5x5，而过滤层处理的矩阵深度和当前处理的神经层网络节点矩阵的深度一致。</p><p><em>下图为卷积层过滤器(filter)结构示意图</em></p><img src="https://img-blog.csdnimg.cn/20191116153724532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2Mzg3MA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" /><p><em>下图为卷积过程</em></p><img src="https://img-blog.csdnimg.cn/20191116154816709.gif" alt="img" style="zoom:50%;" /><p><em>详细过程如下,Input矩阵是像素点矩阵，Kernel矩阵是过滤器(filter)</em></p><img src="https://img-blog.csdnimg.cn/2019111615502886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2Mzg3MA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><h4 id="1-2-3-池化层-Pooling-Layer">1.2.3 池化层(Pooling Layer)</h4><p>​池化层不会改变三维矩阵的深度，但是它<strong>可以缩小矩阵的大小</strong>。通过池化层，可以进一步缩小最后全连接层中节点的个数，从而达到减少整个神经网络参数的目的。使用池化层既可以加快计算速度也可以防止过拟合。池化层filter的计算不是节点的加权和，而是<strong>采用最大值或者平均值计算</strong>。使用最大值操作的池化层被称之为最大池化层（max pooling）（最大池化层是使用的最多的磁化层结构）。使用平均值操作的池化层被称之为平均池化层（mean pooling）。</p><p>下图分别表示不重叠的4个2x2区域的最大池化层（max pooling）、平均池化层（mean pooling）。</p><img src="https://img-blog.csdnimg.cn/20191116160351379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2Mzg3MA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20191116160420689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc2Mzg3MA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%;" /><h4 id="1-2-4-全连接层-（fully-connected-layers，FC">1.2.4 全连接层**（fully connected layers，FC)**</h4><p>​在经过多轮卷积层和池化层的处理之后，在CNN的最后一般会由1到2个全连接层来给出最后的分类结果。经过几轮卷积层和池化层的处理之后，可以认为图像中的信息已经被抽象成了<strong>信息含量更高</strong>的特征。我们可以将卷积层和池化层看成自动图像特征提取的过程。在提取完成之后，仍然需要使用全连接层来完成分类任务。</p><p>​全连接层（fully connected layers，FC）在整个卷积神经网络中起到“<strong>分类器</strong>”的作用。如果说卷积层、池化层和激活函数层等操作是将原始数据映射到隐层特征空间的话，全连接层则起到将学到的“分布式特征表示”映射到样本标记空间的作用。在实际使用中，全连接层可由卷积操作实现：对前层是全连接的全连接层可以转化为卷积核为1x1的卷积；而前层是卷积层的全连接层可以转化为卷积核为hxw的全局卷积，h和w分别为前层卷积结果的高和宽。</p><p>​<strong>全连接层的作用主要就是实现分类（Classification）</strong>。</p><p>​全连接的核心操作就是<strong>矩阵向量乘积</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20191114142650540.png" alt="img"></p><p>​本质就是由一个特征空间线性变换到另一个特征空间。目标空间的任一维——也就是隐层的一个 cell——都认为会受到源空间的每一维的影响。不考虑严谨，可以说，目标向量是源向量的加权和。</p><p>​在 CNN 中，全连接常出现在最后几层，用于对前面设计的特征做加权和。比如 mnist，前面的卷积和池化相当于做特征工程，后面的全连接相当于做特征加权。（卷积相当于全连接的有意弱化，按照局部视野的启发，把局部之外的弱影响直接抹为零影响；还做了一点强制，不同的局部所使用的参数居然一致。弱化使参数变少，节省计算量，又专攻局部不贪多求全；强制进一步减少参数。少即是多） 在 RNN 中，全连接用来把 embedding 空间拉到隐层空间，把隐层空间转回 label 空间等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">理解1：</span><br><span class="line">   卷积取的是局部特征，全连接就是把以前的局部特征重新通过权值矩阵组装成完整的图。</span><br><span class="line">因为用到了所有的局部特征，所以叫全连接。</span><br><span class="line">理解2：</span><br><span class="line">   从卷积网络谈起，卷积网络在形式上有一点点像咱们正在召开的“人民代表大会制度”。卷积核的个数相当于候选人，图像中不同的特征会激活不同的“候选人”（卷积核）。</span><br><span class="line">池化层（仅指最大池化）起着类似于“合票”的作用，不同特征在对不同的“候选人”有着各自的喜好。</span><br><span class="line">   全连接相当于是“代表普选”。所有被各个区域选出的代表，对最终结果进行“投票”，全连接保证了receiptive field 是整个图像，既图像中各个部分（所谓所有代表），都有对最终结果影响的权利。</span><br><span class="line">理解3：</span><br><span class="line">   假设你是一只小蚂蚁，你的任务是找小面包。你的视野还比较窄，只能看到很小一片区域。当你找到一片小面包之后，你不知道你找到的是不是全部的小面包，所以你们全部的蚂蚁开了个会，把所有的小面包都拿出来分享了。全连接层就是这个蚂蚁大会~</span><br></pre></td></tr></table></figure><h4 id="1-2-5-Softmax层-归一化指数函数">1.2.5 Softmax层(<strong>归一化指数函数</strong>)</h4><p>​通过Softmax层，可以得到当前样例属于不同种类的概率分布问题。</p><p>​它是二分类函数sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。下图展示了softmax的计算方法：</p><img src="https://img-blog.csdnimg.cn/20181128162309759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X3BldGVy,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><p>​二分类就用sigmoid转化到 0~1 。</p><h4 id="1-2-5-感受野（receptive-field，RF）">1.2.5 感受野（receptive field，RF）</h4><img src="https://s3.bmp.ovh/imgs/2021/11/ceb3b327dc1dc066.png" style="zoom: 33%;" /><p>感受野指的是一个特定的CNN特征（特征图上的某个点）在输入空间所受影响的区域。一个感受野可以用<strong>中心位置</strong>(center location)和<strong>大小</strong>(size)来表征。然而，对于一个CNN特征来说，感受野中的每个像素值（pixel）并不是同等重要。一个像素点越接近感受野中心，它对输出特征的计算所起作用越大。这意味着某一个特征不仅仅是受限在输入图片中某个特定的区域（感受野），并且呈指数级聚焦在区域的中心。这个重要的发现会在下一篇文章中讲。现在，我们关注如何计算一个特定感受野的中心位置和大小。</p><p>在CNN中，感受野应该是一个很重要的东西，但是往往被大家忽略，在我看到的文献中，图像分割模型<a href="https://link.zhihu.com/?target=http%3A//liangchiehchen.com/projects/DeepLab.html">DeepLab</a>就提到了感受野大小的问题，但是那里并没有给出计算公式，如果采用上面的公式就可以快速得到结果。对于图像分割，感受野大小对分割效果是有很大影响的，所以DeepLab采用了扩展卷积（Atrous Convolution， Dilated Convolution）来增加感受野大小。对于空洞卷积来说，你可以将其转化为普通卷积（卷积核大小增加）来计算特征图的感受野。另外，上面的公式同样适用于池化层，因为其在结构上与卷积层是类似的。</p><p>图1为给出了某些感受野实例。其中输入特征图大小为 <img src="https://www.zhihu.com/equation?tex=5%5Ctimes5" alt="[公式]"> ，采用的卷积参数如下：卷积核大小 <img src="https://www.zhihu.com/equation?tex=k%3D3%5Ctimes3" alt="[公式]"> ，padding大小 <img src="https://www.zhihu.com/equation?tex=p%3D1%5Ctimes1" alt="[公式]"> ，步长 <img src="https://www.zhihu.com/equation?tex=s%3D2%5Ctimes2" alt="[公式]"> 。经过一次卷积之后，得到大小为 <img src="https://www.zhihu.com/equation?tex=3%5Ctimes3" alt="[公式]"> 的输出特征图（绿色）。在这个特征图上继续采用相同的卷积，得到一个 <img src="https://www.zhihu.com/equation?tex=2%5Ctimes2" alt="[公式]"> 的特征图（橙色）。输出特征图的大小可以通过如下公式计算（参考<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1603.07285.pdf">A guide to convolution arithmetic for deep learning</a>）：</p><p><img src="https://pic3.zhimg.com/v2-f03d34ea70e2f16e18d0ab486ebb6972_b.jpg" alt="img"></p><p>为了简化讲解，这里假定CNN架构是对称的，并且输入图片是方形的。因此所有的卷积层的所有参数在两个维度上都是相同的。如果CNN架构或者输入图片是非对称的，你可以为各个维度单独计算特征图的属性。</p><img src="https://pic2.zhimg.com/v2-bf2e71cf68c1f1af5921087c3f928781_b.jpg" alt="img" style="zoom: 50%;" /><p>图1 CNN特征图的两种可视化方法</p><p>图1的左栏给出了CNN特征图可视化最常用的方式。在这个可视化中，我们可以看到每个特征图所包含的特征数，但是很难知道每个特征的感受野的中心位置和大小，对于深度CNN，我们没有办法追踪到感受野信息。右栏给出的是固定大小的CNN可视化，所有的特征图固定大小并保持与输入特征图大小一致，这可以解决前面的问题。每个特征被标记在其感受野所在的中心（从而定位出感受野中心位置）。由于一个特征图中所有的特征都有相同大小的感受野，我们可以简单地在每个特征周围画出一个边界框，从而获得感受野的大小。我们也没有必要将这个边界框向下映射到输入层，因为特征图已经与输入层具有相同的大小。图2给出了另外一个实例，其中输入特征图更大，为 <img src="https://www.zhihu.com/equation?tex=7%5Ctimes7" alt="[公式]"> ，与前面例子采用相同的卷积。图的左栏和右栏分别给出了固定大小CNN特征图的3D和2D可视化。可以看出感受野大小增加迅速，以至于第二个特征层的中心特征的感受野已经覆盖了整个输入特征图。这在深度CNN中是一个很重要的设计理念以提升性能。</p><img src="https://pic2.zhimg.com/v2-fd7a5f22dec54f61f9a327127e2f7411_b.jpg" alt="img" style="zoom: 50%;" /><h2 id="感受野计算公式">感受野计算公式</h2><p>为了计算CNN每一层的感受野，除了要知道特征图每个维度的特征数 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]">，还需要记录每一层的其他信息，这包括当前层的感受野大小 <img src="https://www.zhihu.com/equation?tex=r" alt="[公式]"> ，两个相邻特征的距离（跳跃的距离，如前面可视化所示） <img src="https://www.zhihu.com/equation?tex=j" alt="[公式]"> ，和左上角特征（第一个特征）的中心坐标 <img src="https://www.zhihu.com/equation?tex=start" alt="[公式]"> 。注意感受野（其实是特征图第一个特征的感受野）的中心坐标就等于这个特征的中心坐标，就如前面可视化中所示。当采用的卷积其核大小为 <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]"> ，padding大小为 <img src="https://www.zhihu.com/equation?tex=p" alt="[公式]"> ，步长为 <img src="https://www.zhihu.com/equation?tex=s" alt="[公式]"> ，输出特征图的感受野可以按照如下公式计算：</p><p><img src="https://pic2.zhimg.com/v2-0b6fb2be042ca40f03619dca8c2bc4a1_b.jpg" alt="img"></p><ul><li>第一个式子根据输入特征图大小以及卷积参数计算输出特征图大小，前面已经说过。</li><li>第二个式子计算输出特征图的特征间的间隔 <img src="https://www.zhihu.com/equation?tex=j" alt="[公式]"> ，其等于上一层的间隔值乘以卷积的步长，所以间隔值将是按照步长呈指数级增长。</li><li>第三个式子计算输出特征图的感受野大小，其等于前一层感受野大小加上 <img src="https://www.zhihu.com/equation?tex=%28k-1%29%2Aj_%7Bin%7D" alt="[公式]"> ，所以感受野是呈指数级增加，并且还有一个因子 <img src="https://www.zhihu.com/equation?tex=k-1" alt="[公式]"> 。</li><li>第四个式子计算输出特征图的第一个特征感受野的中心坐标，其等于第一层的中心坐标加上 <img src="https://www.zhihu.com/equation?tex=%28k-1%29%2F2%2Aj_%7Bin%7D" alt="[公式]"> <em>，再减去</em> <img src="https://www.zhihu.com/equation?tex=p%2Aj_%7Bin%7D" alt="[公式]"> ，注意两项都要乘以前一层的间隔距离以得到实际距离。</li></ul><p>对于第一层，一般是输入图片，其各项值为： <img src="https://www.zhihu.com/equation?tex=n%3Dimage%5C_size%2C+r%3D1%2C+j+%3D1%2C+start%3D0.5" alt="[公式]"> 。图3给出了一个如何计算感受野的实例，图中的坐标系统中，输入层的第一个特征中心位置记为 <img src="https://www.zhihu.com/equation?tex=0.5" alt="[公式]"> 。通过利用上面公式迭代地进行计算，你可以计算出CNN中所有特征图的感受野信息。</p><img src="https://pic2.zhimg.com/v2-ab018634d2a790d6fa268b3837176f79_b.jpg" alt="img" style="zoom:50%;" /><h3 id="1-3-其他参数">1.3.其他参数</h3><h4 id="1-3-1-Dropout">1.3.1 Dropout</h4><p>dropout 是指在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。</p><p>主要要来减少过拟合。</p><p>该论文从神经网络的难题出发，一步一步引出dropout为何有效的解释。大规模的神经网络有两个缺点：</p><ul><li>费时</li><li>容易过拟合</li></ul><p>​       这两个缺点真是抱在深度学习大腿上的两个大包袱，一左一右，相得益彰，额不，臭气相投。过拟合是很多机器学习的通病，过拟合了，得到的模型基本就废了。而为了解决过拟合问题，一般会采用ensemble方法，即训练多个模型做组合，此时，费时就成为一个大问题，不仅训练起来费时，测试起来多个模型也很费时。总之，几乎形成了一个死锁。</p><p>​Dropout的出现很好的可以解决这个问题，每次做完dropout，相当于从原始的网络中找到一个更瘦的网络，如下图所示：</p><img src="https://img-blog.csdnimg.cn/20200827215802248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnpoYW5neWFueGlhbmc=,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:67%;" /><p>​因而，对于一个有N个节点的神经网络，有了dropout后，就可以看做是2n个模型的集合了，但此时要训练的参数数目却是不变的，这就解脱了费时的问题。</p><h4 id="1-3-2-激活函数">1.3.2 激活函数</h4><p>​激活函数用来增加非线性因素的，提高模型拟合能力。如果不存在激活函数，神经网络的每一层的输入都是对前面输入的线性变化，就算把网络加到很深也无法去拟合任意函数的。</p><p>详情请见：<a href="https://cjh0220.github.io/posts/f9cbfb7b/">激活函数</a></p><h4 id="1-3-3-损失函数">1.3.3 损失函数</h4><p>​<strong>损失函数</strong>loss function）是用来<strong>估量模型的预测值f(x)与真实值Y的不一致程度</strong>，它是一个非负实值函数,通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。</p><p>详情请见：<a href="https://cjh0220.github.io/posts/be2e8163/">损失函数</a></p><h4 id="1-3-4-padding">1.3.4 padding</h4><p>在卷积操作之前填充这幅图像。</p><p>在这个案例中，你可以沿着图像边缘再填充一层像素。如果你这样操作了，那么6×6的图像就被你填充成了一个8×8的图像。如果你用3×3的图像对这个8×8的图像卷积，你得到的输出就不是4×4的，而是6×6的图像，你就得到了一个尺寸和原始图像6×6的图像。习惯上，你可以用0去填充，如果是填充的数量，在这个案例中，，因为我们在周围都填充了一个像素点，输出也就变成了，所以就变成了，和输入的图像一样大。这个涂绿的像素点（左边矩阵）影响了输出中的这些格子（右边矩阵）。这样一来，角落或图像边缘的信息发挥的作用较小的这一缺点就被削弱了。</p><img src="https://img-blog.csdnimg.cn/20200103135441708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI3OTEwMQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" /><p>刚才已经展示过用一个像素点来填充边缘，如果你想的话，也可以填充两个像素点，也就是说在这里填充一层。实际上你还可以填充更多像素。我这里画的这种情况，填充后p = 2。</p><img src="https://img-blog.csdnimg.cn/20200103135750151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI3OTEwMQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><h5 id="Valid卷积："><strong>Valid</strong>卷积：</h5><p><strong>Valid</strong>卷积意味着不填充。</p><h5 id="Same卷积"><strong>Same</strong>卷积</h5><p><strong>Same</strong>卷积意味你填充后，你的输出大小和输入大小是一样的。</p><img src="http://a1.qpic.cn/psc?/V12XQ1QV3cpyPD/05RlWl8gsTOH*Z17MtCBzC9POCBaedtEP4n0sXSodmjuTUd.4kJp52CqMMSezAYjcbPQawoeVkSzqVcLLBVfRQ!!/b&ek=1&kp=1&pt=0&bo=NgOyATYDsgEDACU!&tl=1&vuin=1005741898&tm=1636005600&sce=50-1-1&rf=4-0" style="zoom:50%;" /><p>为了指定卷积操作中的padding，你可以指定p的值。也可以使用Valid卷积，也就是p = 0。也可使用Same卷积填充像素，使你的输出和输入大小相同。</p><h2 id="二、目标检测的敲门砖（R-CNN）">二、目标检测的敲门砖（R-CNN）</h2><h3 id="2-1-历史背景">2.1 历史背景</h3><img src="https://img-blog.csdnimg.cn/20200516094233191.PNG#pic_center" alt="img" style="zoom: 67%;" /><p>​我们常说的R-CNN系列，一共包含三个版本：<strong>R-CNN</strong>、<strong>Fast R-CNN</strong>、<strong>Faster R-CNN</strong>。从命名上看，R是Region的缩写，CNN指我们常说的卷积神经网络。那么R-CNN其实就是使用推荐区域的卷积神经网络。由Fast、Faster很容易知道，版本的更迭解决的是一个实时性的问题。</p><p>​R-CNN算法最早在2013年被提出，它的出现打开了运用深度学习进行目标检测的大门，从此之后，目标检测的精准度与实时性被不断刷新。R-CNN系列算法自提出之际，就非常引人注目，以至于在之后的很多经典算法中，如SSD、YOLO系列、Mask R-CNN中都能看到它的影子。</p><p>​学习R-CNN系列算法不仅能够让我们了解到基础的目标检测算法的思路，而且能够让学习者更加轻松地掌握SSD、YOLO系列、Mask R-CNN等算法。因为相比一些one-stage 的目标检测算法，Faster R-CNN作为two-stage的算法理解起来并不算简单。正是如此，当我们掌握了R-CNN系列算法后，再去学习经典的one-stage算法，就会变得异常简单。</p><p>​R-CNN、Fast R-CNN采用的还是传统的SS算法生成推荐区域，计算非常耗时，达不到实时检测的效果。直到Faster R-CNN才使用RPN代替了原来的SS算法，才使得目标检测的时间大大缩短，达到实时性的效果。因此，本篇博客先会对R-CNN、Fast R-CNN进行一个简明扼要地讲解，大家只需了解算法的思路和演进过程即可；之后，会着重讲解R-CNN 系列的灵魂之作——Faster R-CNN，而这部分才是大家需要着重了解的。</p><p>​2013年11月，Ross Girshick等人最早提出了R-CNN算法，打开了利用深度学习进行目标检测的大门。在当时来说，R-CNN算法的目标检测水平超群，比传统的目标检测方法有了很大提升。实验表明，R-CNN算法在PASCAL VOC数据集取得了很好的成绩，这种算法的平均精确度比之前在VOC2012数据集上的最好测试效果还要高30%。并且，由该算法提出的论文《Rich feature hierarchies for accurate object detection and semantic segmentation》获得了世界计算机视觉顶会CVPR2014的最佳论文奖。</p><h3 id="2-2-R-CNN">2.2 R-CNN</h3><img src="https://img-blog.csdnimg.cn/20200515153150772.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaW5qaWU=,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom: 67%;" /><p>如上图所示，<strong>R-CNN目标检测算法</strong>流程主要分四个步骤：</p><ol><li>采用SS(<a href="https://cjh0220.github.io/posts/undefined/">Selective Search</a>)方法，使一张图片生成1000~2000个候选区域(region proposals)。</li><li>对每一个候选区域，都使用深度神经网络（AlexNet）提取特征，得到1*4096的特征向量。</li><li>将每一个特征向量送入每一类的<a href="https://cjh0220.github.io/posts/2c7c9a1c/"><strong>SVM分类器</strong></a>，判断是否属于该类。</li><li>对已分类的推荐框进行<strong>线性回归</strong>，对这些框进行精细地调整，得到更加准确的边界框坐标。</li></ol><p>R-CNN算法的检测效果很好，但是检测速度很慢，因此总体效率不高。其主要原因在于：</p><ul><li><strong>提取特征操作非常冗余</strong>。检测时，需要将每个推荐区域都送入训练好的模型（AlexNet）进行前向传播，因此每张图片大约要进行1000~2000次前向传播。</li><li><strong>训练速度慢，过程繁琐</strong>。要单独分别训练三个不同的模型：CNN用来提取图像特征、SVM分类器用来预测类别、回归器精细修正建议框的位置。分开训练，耗时耗力。</li><li>使用Selective Search算法生成推荐区域，这个过程大约耗时2s，也是它不能达到实时性检测的一个重要原因。</li></ul><h3 id="2-3-Fast-R-CNN">2.3 Fast-R-CNN</h3><p>Fast R-CNN紧随R-CNN其后。Fast R-CNN更快更好，得益于以下几点:</p><ul><li>在提出区域之前先对图像进行特征提取，这样整个图像上只运行一个CNN，而不是2000个CNN的2000多个重叠区域</li><li>将支持向量机替换为softmax层，从而扩展用于预测的神经网络，而不是创建新的模型</li></ul><p>从直觉上看，移除2000个conv层，而只使用一次Convolution，并在其上创建方框是很有意义的。</p><h3 id="2-4-Faster-R-CNN">2.4 Faster R-CNN</h3><p>Fast R-CNN的缺点之一是缓慢的选择搜索算法，而Faster R-CNN引入了一种叫做网络和区域候选网络(RPN)的东西。</p><h4 id="RPN工作原理：">RPN工作原理：</h4><p>在初始CNN的最后一层，一个3x3滑动窗口在feature map上移动，并将其映射到一个较低的维度(例如256-d)。对于每个滑动窗口位置，它基于k个固定比例锚框(默认边界框)生成多个可能的区域。</p><p>每个推荐区域包含以下内容：</p><ul><li>该区域的“客观性”得分</li><li>4个表示区域边界框的坐标</li></ul><p>换句话说，我们查看上一个区域中的每个位置，并考虑k个围绕它的不同框:一个高框，一个宽框，一个大框，等等。对于每个方框，我们输出它是否包含对象，以及方框的坐标是什么。这是为什么看着像个一个滑动窗口位置:</p><p>2k分数表示每个k边界框在“对象”上的softmax概率。注意，尽管RPN输出边界框坐标，但它并不试图分类任何潜在的对象:它的唯一工作仍然是提出对象区域。如果锚框的“客观性”得分高于某个阈值，则该框的坐标将作为区域建议向前传递。</p><p>一旦我们有了我们的区域提案，我们就直接把它们输入到本质上是fast R-CNN。我们添加了一个池化层，一些完全连接层，最后一个softmax分类层和边界框回归器。在某种意义上，Faster R-CNN = RPN + Fast R-CNN.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 卷积神经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>残差神经网络</title>
      <link href="/2022/09/08/%E6%AE%8B%E5%B7%AE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/09/08/%E6%AE%8B%E5%B7%AE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>链接：</p><p><a href="https://zhuanlan.zhihu.com/p/91385516">一文读懂残差网络</a></p><h2 id="残差网络的由来"><strong>残差网络的由来</strong></h2><p>残差操作这一思想起源于论文《Deep Residual Learning for Image Recognition》，目前的引用量已达3万多。这篇文章发现，如果存在某个<img src="https://www.zhihu.com/equation?tex=K" alt="[公式]">层的网络<img src="https://www.zhihu.com/equation?tex=f" alt="[公式]">是当前最优的网络，那么可以构造一个更深的网络，其最后几层仅是该网络<img src="https://www.zhihu.com/equation?tex=f" alt="[公式]">第<img src="https://www.zhihu.com/equation?tex=K" alt="[公式]">层输出的恒等映射(Identity Mapping)，就可以取得与<img src="https://www.zhihu.com/equation?tex=f" alt="[公式]">一致的结果；也许<img src="https://www.zhihu.com/equation?tex=K" alt="[公式]">还不是所谓“最佳层数”，那么更深的网络就可以取得更好的结果。总而言之，与浅层网络相比，更深的网络的表现不应该更差。但是如下图所示，56层的神经网络表现明显要比20层的差。证明更深的网络在训练过程中的难度更大，因此作者提出了残差网络的思想。</p><p><img src="https://pic2.zhimg.com/80/v2-a16f6011fbae00e134f3d8cdb623e5f5_720w.jpg" alt="img">网络层数加深导致的训练问题</p><h2 id="残差网络的定义">残差网络的定义</h2><p>残差网络依旧让非线形层满足 <img src="https://www.zhihu.com/equation?tex=H%5Cleft%28x%2C+w_%7Bh%7D%5Cright%29" alt="[公式]"> ，然后从输入直接引入一个短连接到非线形层的输出上，使得整个映射变为</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7By%7D%3DH%5Cleft%28x%2C+w_%7Bh%7D%5Cright%29%2Bx" alt="[公式]"></p><p>这就是残差网路的核心公式，换句话说，残差是网络搭建的一种操作，任何使用了这种操作的网络都可以称之为残差网络。</p><p>一个具体的残差模块的定义如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-39dabdf70ac19c0c92b86d53375d8c06_720w.jpg" alt="img">残差模块（由于先敲公式后引得图，容易混淆，图中的F(x)就是上文所说的H(x,w)，下面也一样替换）</p><h2 id="残差网络的优势">残差网络的优势</h2><p>残差模块为什么有效，有很多的解释，这里提供两个方面的理解，一方面是残差网络更好的拟合分类函数以获得更高的分类精度，另一方面是残差网络如何解决网络在层数加深时优化训练上的难题。</p><p><strong>1.残差网络拟合函数的优越性</strong></p><p>首先从万能近似定理（Universal Approximation Theorem）入手。这个定理表明，一个前馈神经网络（feedforward neural network）如果具有线性输出层，同时至少存在一层具有任何一种“挤压”性质的激活函数（例如logistic sigmoid激活函数）的隐藏层，那么只要给予这个网络足够数量的隐藏单元，它就可以以任意的精度来近似任何从一个有限维空间到另一个有限维空间的波莱尔可测函数(Borel Measurable Function)。</p><p>万能近似定理意味着我们在构建网络来学习什么函数的时候，我们知道一定存在一个多层感知机（Multilayer Perceptron Model，MLP）能够表示这个函数。然而，我们不能保证训练算法能够学得这个函数。因为即使多层感知机能够表示该函数，学习也可能会失败，可能的原因有两种。</p><p>（1）用于训练的优化算法可能找不到用于期望函数的参数值。</p><p>（2）训练算法可能由于过拟合而选择了错误的函数。</p><p>第二种过拟合情况不在我们的讨论范围之内，因此我们聚焦在前一种情况，为何残差网络相比简单的多层网络能更好的拟合分类函数，即找到期望函数的参数值。</p><p>对于普通的不带短连接的神经网络来说，存在这样一个命题。</p><p>命题1:假设 <img src="https://www.zhihu.com/equation?tex=f_%7B%5Cmathcal%7BN%7D%7D%3A+%5Cmathbb%7BR%7D%5E%7Bd%7D+%5Crightarrow+%5Cmathbb%7BR%7D" alt="[公式]"> 为普通的带激活函数的全连接网络 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 。 <img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7BP%7D%3D%5C%7B%5Cmathrm%7Bx%7D+%5Cin+%5Cleft.%5Cmathbb%7BR%7D%5E%7Bd%7D+%7C+f_%7B%5Cmathcal%7BN%7D%7D%28x%29%3E0%5Cright%5C%7D" alt="[公式]"> 为 <img src="https://www.zhihu.com/equation?tex=f_N" alt="[公式]"> 的正等值面，假如 <img src="https://www.zhihu.com/equation?tex=N" alt="[公式]"> 的每个层的激活函数都至多只有<img src="https://www.zhihu.com/equation?tex=d" alt="[公式]"> 个神经元，那么</p><p><img src="https://www.zhihu.com/equation?tex=%5Clambda%28P%29%3D0+%5Ctext+%7B+or+%7D+%5Clambda%28P%29%3D%2B%5Cinfty" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="[公式]"> 为勒贝格测度。换句话说，这样狭窄的全连接网络表示的函数要么没有边界约束，要么恒为0。因此，即使层数无限加深，整个网络的表现力也受网络的宽度限制而无法近似一个带边界的区域。而对于残差网络来讲，拟合函数的能力则完全不受网路宽度的影响，上述命题1对于残差网络并不适用。</p><p>下面从一个简单的二维例子来说明这一点，这样可以进行方便的可视化。我们随机生成一组测试点 <img src="https://www.zhihu.com/equation?tex=%5Cleft%28z_%7Bi%7D%2C+y_%7Bi%7D%5Cright%29_%7Bi%3D1+%5Cldots+n%7D+%5Cin+%5Cmathbb%7BR%7D%5E%7B2%7D+%5Ctimes%5C%7B-1%2C1%5C%7D" alt="[公式]"> ，满足</p><p><img src="https://www.zhihu.com/equation?tex=y_%7Bi%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bc%7D%7B1%2C+%5Ctext+%7B+if+%7D%5Cleft%5C%7Cz_%7Bi%7D%5Cright%5C%7C_%7B2%7D+%5Cleq+1%7D+%5C%5C+%7B-1%2C+i+f+%5Cleq+2%5Cleft%5C%7Cz_%7Bi%7D%5Cright%5C%7C_%7B2%7D+%5Cleq+3%7D%5Cend%7Barray%7D%5Cright." alt="[公式]"></p><p>我们手动构造一个清晰的分类边界使得整个任务更容易一点，损失函数采用逻辑回归损失<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7Bn%7D+%5Csum+%5Clog+%5Cleft%281%2Be%5E%7B-y_%7Bi%7D+%5Chat%7By_%7B%5Cmathrm%7Bt%7D%7D%7D%7D%5Cright%29" alt="[公式]"> ，其中 <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D_%7B%5Ciota%7D%3Df_%7B%5Cmathcal%7BN%7D%7D%5Cleft%28z_%7Bi%7D%5Cright%29" alt="[公式]"> 为网络对于样本 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 的实际输出。经过训练后，分析网络不同深度下得到的训练边界，如图3.5可以发现宽度比输入维度小的残差网络的训练边界明显更加接近真实边界，也不受命题1的限制。</p><p><img src="https://pic3.zhimg.com/80/v2-8160e22f45869596f18a1692df9d7ef2_720w.jpg" alt="img">图3.5 不同网络结构拟合函数边界的结果。左上角为函数的真实边界。第一行是简单的全连接网络，每层的神经元个数为2；第二行为带短连接的网络，每层神经元个数为1。从左到右的网络层数依次递增，分别为1-5层。</p><p>事实上对于高维函数，这一特点依然适用。因此，当函数的输入维度非常高时，这一做法就变的非常有意义。尽管在高维空间这一特点很难被可视化，但是<strong>这个理论给了一个很合理的启发，就是原则上，带短连接的网络的拟合高维函数的能力比普通连接的网络更强</strong>。这部分我们讨论了残差网络有能力拟合更高维的函数，但是在实际的训练过程中仍然可能存在各种各样的问题使得学习到最优的参数非常困难，因此下一小节讨论残差在训练过程中的优越性。</p><p><strong>2.残差网络训练过程的优越性</strong></p><p>这个部分我们讨论为什么残差能够缓解深层网络的训练问题，以及探讨可能的短连接方式和我们最终选择的残差的理由。正如本章第三部分讨论的一样，整个残差卷积神经网络是由以上的残差卷积子模块堆积而成。如上一小节所定义的，假设第 <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 层的残差卷积字子模块的映射为</p><p><img src="https://www.zhihu.com/equation?tex=F%5Cleft%28x_%7Bl%7D%2C+w_%7Bf%7D%5Cright%29%3Dx_%7Bl%7D%2BH%5Cleft%28x_%7Bl%7D%2C+w_%7Bl%7D%5Cright%29" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=x_l" alt="[公式]"> 是第 <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 层的输入， <img src="https://www.zhihu.com/equation?tex=w_%7Bl%7D%3D%5Cleft%5C%7Bw_%7Bl%2C+k%7D+%7C+1+%5Cleq+k+%5Cleq+K%5Cright%5C%7D" alt="[公式]"> 是第 <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 层的参数， <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> 是残差单元层数。</p><p>那么第 <img src="https://www.zhihu.com/equation?tex=l%2B1" alt="[公式]"> 层的输入为</p><p><img src="https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D%3DF%5Cleft%28x_%7Bl%7D%2C+w_%7Bf%7D%5Cright%29" alt="[公式]"></p><p>因此得到</p><p><img src="https://www.zhihu.com/equation?tex=x_%7Bl%2B1%7D%3Dx_%7Bl%7D%2BH%5Cleft%28x_%7Bl%7D%2C+w_%7Bl%7D%5Cright%29" alt="[公式]"></p><p>循环带入这个式子 <img src="https://www.zhihu.com/equation?tex=x_%7Bl%2B2%7D%3Dx_%7Bl%2B1%7D%2BH%5Cleft%28x_%7Bl%2B1%7D%2C+w_%7Bl%2B1%7D%5Cright%29%3Dx_%7Bl%7D%2BH%5Cleft%28x_%7Bl%7D%2C+w_%7Bl%7D%5Cright%29%2BH%5Cleft%28x_%7Bl%2B1%7D%2C+w_%7Bl%2B1%7D%5Cright%29" alt="[公式]"> ，我们可以得到</p><p><img src="https://www.zhihu.com/equation?tex=x_%7BL%7D%3Dx_%7Bl%7D%2B%5Csum_%7Bi%3Dl%7D%5E%7BL-1%7D+F%5Cleft%28x_%7Bi%7D%2C+w_%7Bi%7D%5Cright%29" alt="[公式]"> （1）</p><p>对于任何深度的L来讲，上述式子（1）显示了一些良好的特性。</p><p>（1）第<img src="https://www.zhihu.com/equation?tex=L" alt="[公式]">层的特征<img src="https://www.zhihu.com/equation?tex=x_L" alt="[公式]">可以分为两个部分，第一部分是浅层的网络表示<img src="https://www.zhihu.com/equation?tex=x_l" alt="[公式]">加上一个残差函数映射 <img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3Dl%7D%5E%7BL%3D1%7D+F%5Cleft%28x_%7Bi%7D%2C+w_%7Bi%7D%5Cright%29" alt="[公式]"> ，表明模型在任意单元内都是一个残差的形式。</p><p>（2）对于任意深度 <img src="https://www.zhihu.com/equation?tex=L" alt="[公式]"> 的特征 <img src="https://www.zhihu.com/equation?tex=x_L" alt="[公式]"> 来讲，它是前面所有残差模块的和，这与简单的不加短连接的网络完全相反。原因是，不加短连接的网络在第 <img src="https://www.zhihu.com/equation?tex=L" alt="[公式]"> 层的特征 <img src="https://www.zhihu.com/equation?tex=x_L" alt="[公式]"> 是一系列的向量乘的结果，即 <img src="https://www.zhihu.com/equation?tex=%5CPi_%7Bi%3D0%7D%5E%7BL-1%7D+W_%7Bi%7D+x_%7B0%7D" alt="[公式]"> (在忽略batch normalization和激活函数的情况下)。</p><p>同样，上述式子显示有非常好的反向传播特性，假设损失为 <img src="https://www.zhihu.com/equation?tex=%5Cvarepsilon" alt="[公式]"> ，根据链式求导法则，我们可以得到</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+%5Cvarepsilon%7D%7B%5Cpartial+x_%7Bl%7D%7D%3D%5Cfrac%7B%5Cpartial+%5Cvarepsilon%7D%7B%5Cpartial+x_%7BL%7D%7D+%5Cfrac%7B%5Cpartial+x_%7BL%7D%7D%7B%5Cpartial+x_%7Bl%7D%7D%3D%5Cfrac%7B%5Cpartial+%5Cvarepsilon%7D%7B%5Cpartial+x_%7BL%7D%7D%5Cleft%281%2B%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial+x_%7Bl%7D%7D+%5Csum_%7Bi%3Dl%7D%5E%7BL-1%7D+F%5Cleft%28x_%7Bi%7D%2C+w_%7Bi%7D%5Cright%29%5Cright%29" alt="[公式]"> （2）</p><p>显示梯度<img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+%5Cvarepsilon%7D%7B%5Cpartial+x_%7BL%7D%7D" alt="[公式]">由两个部分组成，一部分 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+x_%7Bl%7D%7D%7B%5Cpartial+x_%7BL%7D%7D" alt="[公式]"> 是不用经过任何权重加权的信息流，另一部分是通过加权层的 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+%5Cvarepsilon%7D%7B%5Cpartial+x_%7BL%7D%7D%5Cleft%28%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial+x_%7Bl%7D%7D+%5Csum_%7Bi%3Dl%7D%5E%7BL-1%7D+F%5Cleft%28x_%7Bi%7D%2C+w_%7Bi%7D%5Cright%29%5Cright%29" alt="[公式]"> ，两部分连接的线形特性保证了信息可以直接反向传播到浅层。同时式子还说明对于小的batch而言，梯度 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+%5Cvarepsilon%7D%7B%5Cpartial+x_%7Bl%7D%7D" alt="[公式]"> 不太可能会消失，因为通常 对于小的batch来讲不会总是为1，那么这表示即使权重非常小，梯度也不会为0，不存在梯度消失的问题。</p><p>总之，式子（1）和（2）表明信号无论是在前向传播还是反向传播的过程中，都是可以直接通过的。</p><h2 id="残差模块的实现例子">残差模块的实现例子</h2><p>大家可以对照图看具体的实现：</p><p><img src="https://pic3.zhimg.com/80/v2-39dabdf70ac19c0c92b86d53375d8c06_720w.jpg" alt="img"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import torch.nn as nn</span><br><span class="line">import torch</span><br><span class="line">from torch.nn.init import kaiming_normal, constant</span><br><span class="line"></span><br><span class="line">class BasicConvResBlock(nn.Module):</span><br><span class="line"></span><br><span class="line">    def __init__(self, input_dim=128, n_filters=256, kernel_size=3, padding=1, stride=1, shortcut=False, downsample=None):</span><br><span class="line">        super(BasicConvResBlock, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.shortcut = shortcut</span><br><span class="line"></span><br><span class="line">        self.conv1 = nn.Conv1d(input_dim, n_filters, kernel_size=kernel_size, padding=padding, stride=stride)</span><br><span class="line">        self.bn1 = nn.BatchNorm1d(n_filters)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.conv2 = nn.Conv1d(n_filters, n_filters, kernel_size=kernel_size, padding=padding, stride=stride)</span><br><span class="line">        self.bn2 = nn.BatchNorm1d(n_filters)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        residual = x</span><br><span class="line"></span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line"></span><br><span class="line">        if self.shortcut:</span><br><span class="line">            out += residual</span><br><span class="line"></span><br><span class="line">        out = self.relu(out)</span><br><span class="line"></span><br><span class="line">        return out</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 残差网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XGboost算法</title>
      <link href="/2022/09/08/XGboost%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/XGboost%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>XGBoost</h1><h2 id="1-什么是XGBoost">1. 什么是XGBoost</h2><p><strong>XGBoost</strong>是陈天奇等人开发的一个开源机器学习项目，高效地实现了GBDT算法并进行了算法和工程上的许多改进，被广泛应用在Kaggle竞赛及其他许多机器学习竞赛中并取得了不错的成绩。</p><p>说到XGBoost，不得不提GBDT(Gradient Boosting Decision Tree)。因为XGBoost本质上还是一个GBDT，但是力争把速度和效率发挥到极致，所以叫X (Extreme) GBoosted。包括前面说过，两者都是boosting方法。</p><h3 id="1-1-XGBoost树的定义">1.1 XGBoost树的定义</h3><p>先来举个<strong>例子</strong>，我们要预测一家人对电子游戏的喜好程度，考虑到年轻和年老相比，年轻更可能喜欢电子游戏，以及男性和女性相比，男性更喜欢电子游戏，故先根据年龄大小区分小孩和大人，然后再通过性别区分开是男是女，逐一给各人在电子游戏喜好程度上打分，如下图所示。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qdWx5ZWR1LWltZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vcXVlc2Jhc2U2NDE1MzQzODU3NzIzMjUxNjgwMC5wbmc" alt=""></p><p>就这样，训练出了2棵树tree1和tree2，类似之前gbdt的原理，两棵树的结论累加起来便是最终的结论，所以小孩的预测分数就是两棵树中小孩所落到的结点的分数相加：2 + 0.9 = 2.9。爷爷的预测分数同理：-1 + （-0.9）= -1.9。具体如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qdWx5ZWR1LWltZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vcXVlc2Jhc2U2NDE1MzQzODU3ODczOTE5ODQzMy5wbmc" alt=""></p><p>恩，你可能要拍案而起了，惊呼，这不是跟上文介绍的GBDT乃异曲同工么？</p><p>事实上，如果不考虑工程实现、解决问题上的一些差异，XGBoost与GBDT比较大的不同就是目标函数的定义。XGBoost的目标函数如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qdWx5ZWR1LWltZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vcXVlc2Jhc2U2NDE1MzQzODU4MDEzOTE1OTU5My5wbmc" alt=""></p><p>其中：</p><ul><li><p>红色箭头所指向的L 即为损失函数（比如平方损失函数：</p></li><li><p>红色方框所框起来的是正则项（包括L1正则、L2正则）</p></li><li><p>红色圆圈所圈起来的为常数项</p></li><li><p>对于f(x)，XGBoost利用泰勒展开三项，做一个近似。f(x)表示的是其中一颗回归树。</p></li></ul><p>XGBoost的核心算法思想不难，基本就是：</p><ul><li>不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数f(x)，去拟合上次预测的残差。</li><li>当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数</li><li>最后只需要将每棵树对应的分数加起来就是该样本的预测值。</li></ul><p>显然，我们的目标是要使得树群的预测值尽量接近真实值，而且有尽量大的泛化能力。类似之前GBDT的套路，XGBoost也是需要将多棵树的得分累加得到最终的预测得分（每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qdWx5ZWR1LWltZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vcXVlc2Jhc2U2NDE1MzQzODY1NzI2MTgzMzQ5My5wbmc" alt=""></p><p>那接下来，我们如何选择每一轮加入什么 f 呢？答案是非常直接的，选取一个 f 来使得我们的目标函数尽量最大地降低。这里 f 可以使用泰勒展开公式近似。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qdWx5ZWR1LWltZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vcXVlc2Jhc2U2NDE1MzQzODY1ODY3NTMwMTIwLnBuZw" alt=""></p><p>实质是把样本分配到叶子结点会对应一个obj，优化过程就是obj优化。也就是分裂节点到叶子不同的组合，不同的组合对应不同obj，所有的优化围绕这个思想展开。到目前为止我们讨论了目标函数中的第一个部分：训练误差。接下来我们讨论目标函数的第二个部分：正则项，即如何定义树的复杂度。</p><h3 id="1-2-正则项：树的复杂度">1.2 正则项：树的复杂度</h3><p>XGBoost对树的复杂度包含了两个部分：</p><ul><li>一个是树里面叶子节点的个数T</li><li>一个是树上叶子节点的得分w的L2模平方（对w进行L2正则化，相当于针对每个叶结点的得分增加L2平滑，目的是为了避免过拟合）</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qdWx5ZWR1LWltZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vcXVlc2Jhc2U2NDE1MzQzODY3NDE5OTQ3MTQ4My5wbmc" alt=""></p><p>我们再来看一下XGBoost的目标函数（损失函数揭示训练误差 + 正则化定义复杂度）：</p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/4ade7a318e325195.png" alt=""></p><p>正则化公式也就是目标函数的后半部分，对于上式而言， 整个累加模型的输出，正则化项∑kΩ(ft)是则表示树的复杂度的函数，值越小复杂度越低，泛化能力越强。</p><h3 id="1-3-树该怎么长">1.3 树该怎么长</h3><p>很有意思的一个事是，我们从头到尾了解了xgboost如何优化、如何计算，但树到底长啥样，我们却一直没看到。很显然，一棵树的生成是由一个节点一分为二，然后不断分裂最终形成为整棵树。那么树怎么分裂的就成为了接下来我们要探讨的关键。对于一个叶子节点如何进行分裂，XGBoost作者在其原始论文中给出了一种分裂节点的方法：枚举所有不同树结构的贪心法</p><p>不断地枚举不同树的结构，然后利用打分函数来寻找出一个最优结构的树，接着加入到模型中，不断重复这样的操作。这个寻找的过程使用的就是<strong>贪心算法</strong>。选择一个feature分裂，计算loss function最小值，然后再选一个feature分裂，又得到一个loss function最小值，你枚举完，找一个效果最好的，把树给分裂，就得到了小树苗。</p><p>总而言之，XGBoost使用了和CART回归树一样的想法，利用贪婪算法，遍历所有特征的所有特征划分点，不同的是使用的目标函数不一样。具体做法就是分裂后的目标函数值比单子叶子节点的目标函数的增益，同时为了限制树生长过深，还加了个阈值，只有当增益大于该阈值才进行分裂。从而继续分裂，形成一棵树，再形成一棵树，每次在上一次的预测基础上取最优进一步分裂/建树。</p><h3 id="1-4如何停止树的循环生成">1.4如何停止树的循环生成</h3><p>凡是这种循环迭代的方式必定有停止条件，什么时候停止呢？简言之，设置树的最大深度、当样本权重和小于设定阈值时停止生长以防止过拟合。具体而言，则</p><ul><li><p>当引入的分裂带来的增益小于设定阀值的时候，我们可以忽略掉这个分裂，所以并不是每一次分裂loss function整体都会增加的，有点预剪枝的意思，阈值参数为（即正则项里叶子节点数T的系数）；</p></li><li><p>当树达到最大深度时则停止建立决策树，设置一个超参数max_depth，避免树太深导致学习局部样本，从而过拟合；</p></li><li><p>样本权重和小于设定阈值时则停止建树。什么意思呢，即涉及到一个超参数-最小的样本权重和min_child_weight，和GBM的 min_child_leaf 参数类似，但不完全一样。大意就是一个叶子节点样本太少了，也终止同样是防止过拟合；</p></li></ul><h2 id="2-XGBoost与GBDT有什么不同">2.XGBoost与GBDT有什么不同</h2><p>除了算法上与传统的GBDT有一些不同外，XGBoost还在工程实现上做了大量的优化。总的来说，两者之间的区别和联系可以总结成以下几个方面。</p><ul><li>GBDT是机器学习算法，XGBoost是该算法的工程实现。</li><li>在使用CART作为基分类器时，XGBoost显式地加入了正则项来控制模 型的复杂度，有利于防止过拟合，从而提高模型的泛化能力。</li><li>GBDT在模型训练时只使用了代价函数的一阶导数信息，XGBoost对代 价函数进行二阶泰勒展开，可以同时使用一阶和二阶导数。</li><li>传统的GBDT采用CART作为基分类器，XGBoost支持多种类型的基分类 器，比如线性分类器。</li><li>传统的GBDT在每轮迭代时使用全部的数据，XGBoost则采用了与随机 森林相似的策略，支持对数据进行采样。</li><li>传统的GBDT没有设计对缺失值进行处理，XGBoost能够自动学习出缺 失值的处理策略。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XGbooost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GBDT算法</title>
      <link href="/2022/09/08/GBDT%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/GBDT%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>GBDT算法 （梯度提升决策树）</h1><h2 id="1-GBDT算法的过程">1.GBDT算法的过程</h2><h3 id="1-1Boosting思想">1.1Boosting思想</h3><p>Boosting方法训练基分类器时采用<strong>串行</strong>的方式，各个基分类器之间有依赖。它的基本思路是将**基分类器层层叠加，每一层在训练的时候，对前一层基分类器分错的样本，给予更高的权重。**测试时，根据各层分类器的结果的加权得到最终结果。</p><p>Bagging与Boosting的串行训练方式不同，Bagging方法在训练过程中，各基分类器之间无强依赖，可以进行并行训练。</p><p>GBDT(Gradient Boosting Decision Tree)，全名叫梯度提升决策树，使用的是Boosting的思想。</p><h3 id="1-2GBDT原理">1.2GBDT原理</h3><p>GBDT的原理很简单，就是所有弱分类器的结果相加等于预测值，然后下一个弱分类器去拟合误差函数对预测值的残差(这个残差就是预测值与真实值之间的误差)。当然了，它里面的弱分类器的表现形式就是各棵树。</p><p>举一个非常简单的例子，比如我今年30岁了，但计算机或者模型GBDT并不知道我今年多少岁，那GBDT咋办呢？</p><ul><li>它会在第一个弱分类器（或第一棵树中）随便用一个年龄比如20岁来拟合，然后发现误差有10岁；</li><li>接下来在第二棵树中，用6岁去拟合剩下的损失，发现差距还有4岁；</li><li>接着在第三棵树中用3岁拟合剩下的差距，发现差距只有1岁了；</li><li>最后在第四课树中用1岁拟合剩下的残差，完美。</li><li>最终，四棵树的结论加起来，就是真实年龄30岁（实际工程中，gbdt是计算负梯度，用负梯度近似残差）。</li></ul><p><strong>为何gbdt可以用用负梯度近似残差呢？</strong></p><p>回归任务下，GBDT 在每一轮的迭代时对每个样本都会有一个预测值，此时的损失函数为均方差损失函数，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mrow><mo fence="true">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><msup><mi>y</mi><mi>i</mi></msup><mo fence="true">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msup><mi>y</mi><mi>i</mi></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">l\left( y_{i},y^{i}\right) =\dfrac{1}{2}\left( y_{i}-y^{i}\right) ^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2247em;vertical-align:-0.35em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0787em;"><span style="top:-3.3276em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>那此时的负梯度是这样计算的</p><p><img src="https://camo.githubusercontent.com/c09291f07c59de9cde4eb4010af4268eb8c0f80f4995d178c4d338553802362d/68747470733a2f2f6a756c796564752d696d672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f717565736261736536343135353231343936323431363637303937332e676966" alt=""></p><p>所以，当损失函数选用均方损失函数是时，每一次拟合的值就是（真实值 - 当前模型预测的值），即残差。此时的变量是y^{i}，即“当前预测模型的值，也就是对它求负梯度。</p><p><strong>训练过程</strong></p><p>简单起见，假定训练集只有4个人：A,B,C,D，他们的年龄分别是14,16,24,26。其中A、B分别是高一和高三学生；C,D分别是应届毕业生和工作两年的员工。如果是用一棵传统的回归决策树来训练，会得到如下图所示结果：</p><p><img src="https://camo.githubusercontent.com/953440eddbcf317f67227aaa04818347d653dc12b80fe339d88a93b35854440e/68747470733a2f2f6a756c796564752d696d672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f717565736261736536343135333433383536383139313330333935382e706e67" alt=""></p><p>现在我们使用GBDT来做这件事，由于数据太少，我们限定叶子节点做多有两个，即每棵树都只有一个分枝，并且限定只学两棵树。我们会得到如下图所示结果：</p><p><img src="https://camo.githubusercontent.com/d2687e29c0958e01420a6cabac90b3678a94dcc7e15713cd41229624b3b74d69/68747470733a2f2f6a756c796564752d696d672e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f717565736261736536343135333433383537303532393235363839352e706e67" alt=""></p><p>在第一棵树分枝和图1一样，由于A,B年龄较为相近，C,D年龄较为相近，他们被分为左右两拨，每拨用平均年龄作为预测值。</p><ul><li>此时计算残差（残差的意思就是：A的实际值 - A的预测值 = A的残差），所以A的残差就是实际值14 - 预测值15 = 残差值-1。</li><li>注意，A的预测值是指前面所有树累加的和，这里前面只有一棵树所以直接是15，如果还有树则需要都累加起来作为A的预测值。</li></ul><p>然后拿它们的残差-1、1、-1、1代替A B C D的原值，到第二棵树去学习，第二棵树只有两个值1和-1，直接分成两个节点，即A和C分在左边，B和D分在右边，经过计算（比如A，实际值-1 - 预测值-1 = 残差0，比如C，实际值-1 - 预测值-1 = 0），此时所有人的残差都是0。残差值都为0，相当于第二棵树的预测值和它们的实际值相等，则只需把第二棵树的结论累加到第一棵树上就能得到真实年龄了，即每个人都得到了真实的预测值。</p><p>换句话说，现在A,B,C,D的预测值都和真实年龄一致了。Perfect！</p><ul><li>A: 14岁高一学生，购物较少，经常问学长问题，预测年龄A = 15 – 1 = 14</li><li>B: 16岁高三学生，购物较少，经常被学弟问问题，预测年龄B = 15 + 1 = 16</li><li>C: 24岁应届毕业生，购物较多，经常问师兄问题，预测年龄C = 25 – 1 = 24</li><li>D: 26岁工作两年员工，购物较多，经常被师弟问问题，预测年龄D = 25 + 1 = 26</li></ul><p>所以，GBDT需要将多棵树的得分累加得到最终的预测得分，且每一次迭代，都在现有树的基础上，增加一棵树去拟合前面树的预测结果与真实值之间的残差。</p><h2 id="2-梯度提升和梯度下降的区别和联系是什么？">2.梯度提升和梯度下降的区别和联系是什么？</h2><p>下表是梯度提升算法和梯度下降算法的对比情况。可以发现，两者都是在每 一轮迭代中，利用损失函数相对于模型的负梯度方向的信息来对当前模型进行更 新，只不过在梯度下降中，模型是以参数化形式表示，从而模型的更新等价于参 数的更新。而在梯度提升中，模型并不需要进行参数化表示，而是直接定义在函 数空间中，从而大大扩展了可以使用的模型种类。</p><p><img src="https://camo.githubusercontent.com/17b8382a7346470c9f203f29843ccfc99c1016eb4c963ffbe4d0bc6dd1b2b457/687474703a2f2f7778332e73696e61696d672e636e2f6d773639302f3030363330446566677931673474647768717a73646a3330727030616664686f2e6a7067" alt=""></p><h2 id="3-GBDT的优点和局限性有哪些？">3.<strong>GBDT</strong>的优点和局限性有哪些？</h2><h3 id="3-1-优点">3.1 优点</h3><ol><li>预测阶段的计算速度快，树与树之间可并行化计算。</li><li>在分布稠密的数据集上，泛化能力和表达能力都很好，这使得GBDT在Kaggle的众多竞赛中，经常名列榜首。</li><li>采用决策树作为弱分类器使得GBDT模型具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系。</li></ol><h3 id="3-2-局限性">3.2 局限性</h3><ol><li>GBDT在高维稀疏的数据集上，表现不如支持向量机或者神经网络。</li><li>GBDT在处理文本分类特征问题上，相对其他模型的优势不如它在处理数值特征时明显。</li><li>训练过程需要串行训练，只能在决策树内部采用一些局部并行的手段提高训练速度。</li></ol><h2 id="4-RF-随机森林-与GBDT之间的区别与联系">4. RF(随机森林)与GBDT之间的区别与联系</h2><p><strong>相同点</strong>：</p><ul><li>都是由多棵树组成，最终的结果都是由多棵树一起决定。</li><li>RF和GBDT在使用CART树时，可以是分类树或者回归树。</li></ul><p><strong>不同点</strong>：</p><ul><li>组成随机森林的树可以并行生成，而GBDT是串行生成</li><li>随机森林的结果是多数表决表决的，而GBDT则是多棵树累加之和</li><li>随机森林对异常值不敏感，而GBDT对异常值比较敏感</li><li>随机森林是减少模型的方差，而GBDT是减少模型的偏差</li><li>随机森林不需要进行特征归一化。而GBDT则需要进行特征归一化</li></ul><p>原文转自：<a href="https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine%20Learning/3.2%20GBDT/3.2%20GBDT.md">https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine Learning/3.2 GBDT/3.2 GBDT.md</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GBDT算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVM支持向量机算法</title>
      <link href="/2022/09/08/SVM%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/SVM%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>1.SVM</h1><p>支持向量机（support vector machines，SVM）是一种<strong>二分类模型</strong>，它将实例的特征向量映射为空间中的一些点，SVM 的目的就是想要画出一条线，以 “最好地” 区分这两类点，以至如果以后有了新的点，这条线也能做出很好的分类。SVM 适合中小型数据样本、非线性、高维的分类问题。</p><p>SVM 最早是由 Vladimir N. Vapnik 和 Alexey Ya. Chervonenkis 在1963年提出，目前的版本（soft margin）是由 Corinna Cortes 和 Vapnik 在1993年提出，并在1995年发表。深度学习（2012）出现之前，SVM 被认为机器学习中近十几年来最成功，表现最好的算法。</p><h2 id="1-1-SVM-基本概念">1.1 SVM 基本概念</h2><p>将实例的特征向量（以二维为例）映射为空间中的一些点，如下图的实心点和空心点，它们属于不同的两类。SVM 的目的就是想要画出一条线，以“最好地”区分这两类点，以至如果以后有了新的点，这条线也能做出很好的分类。</p><p><img src="https://img-blog.csdnimg.cn/2019030209095227.png" alt="img"></p><p><strong>Q1：能够画出多少条线对样本点进行区分？</strong><br>答：线是有无数条可以画的，区别就在于效果好不好，每条线都可以叫做一个划分超平面。比如上面的绿线就不好，蓝线还凑合，红线看起来就比较好。我们所希望找到的这条效果最好的线就是具有 “最大间隔的划分超平面”。</p><p><strong>Q2：为什么要叫作“超平面”呢？</strong><br>答：因为样本的特征很可能是高维的，此时样本空间的划分就不是一条线了。</p><p><strong>Q3：画线的标准是什么？/ 什么才叫这条线的效果好？/ 哪里好？</strong><br>答：SVM 将会寻找可以区分两个类别并且能使间隔（margin）最大的划分超平面。比较好的划分超平面，样本局部扰动时对它的影响最小、产生的分类结果最鲁棒、对未见示例的泛化能力最强。</p><p><strong>Q4：间隔（margin）是什么？</strong><br>答：对于任意一个超平面，其两侧数据点都距离它有一个最小距离（垂直距离），这两个最小距离的和就是间隔。比如下图中两条虚线构成的带状区域就是 margin，虚线是由距离中央实线最近的两个点所确定出来的（也就是由支持向量决定）。但此时 margin 比较小，如果用第二种方式画，margin 明显变大也更接近我们的目标。</p><img src="https://img-blog.csdnimg.cn/20190302091934374.png" alt="img" style="zoom:50%;" /><p><strong>Q5：为什么要让 margin 尽量大？</strong><br>答：因为大 margin 犯错的几率比较小，也就是更鲁棒啦。</p><p><strong>Q6：支持向量是什么？</strong><br>答：从上图可以看出，虚线上的点到划分超平面的距离都是一样的，实际上只有这几个点共同确定了超平面的位置，因此被称作 “支持向量（support vectors）”，“支持向量机” 也是由此来的。</p><h2 id="1-2-hard-margin-SVM">1.2 hard-margin SVM</h2><img src="https://img-blog.csdnimg.cn/20200916085324603.png" alt="img" style="zoom: 67%;" /><p>划分超平面可以定义为一个线性方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mi>T</mi></msup><mi>X</mi><mo>+</mo><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">w^{T} X+b=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mrow><mo fence="true">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">;</mo><msub><mi>w</mi><mn>2</mn></msub><mo separator="true">;</mo><mo>…</mo><mo separator="true">;</mo><msub><mi>w</mi><mi>d</mi></msub><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">w=\left\{w_{1} ; w_{2} ; \ldots ; w_{d}\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>是一个法向量，决定了超平面的方向，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span> 是特征值的个数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>为训练样本</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>为位移项，决定了超平面与原点之间的距离</li></ul><p>只要确定了法向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 和位移 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，就可以唯一地确定一个划分超平面。划分超平面和它两侧的边际超平面上任意一点的距离为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{||w||}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mord mtight">∣∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><p>利用一些数学推导，公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>∗</mo><mrow><mo fence="true">(</mo><msub><mi>w</mi><mn>0</mn></msub><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y_{i} *\left(w_{0}+w_{1} x_{1}+w_{2} x_{2}\right) \geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，∀i可变为有限制的凸优化问题(convex quadratic optimization)</p><p>利用 Karush-Kuhn-Tucker (KKT)条件和拉格朗日公式，可以推出 MMH 可以被表示为以下“决定边界 (decision boundary)”</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mrow><mo fence="true">(</mo><msup><mi>X</mi><mi>T</mi></msup><mo fence="true">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>l</mi></munderover><msub><mi>y</mi><mi>i</mi></msub><msub><mi>α</mi><mi>i</mi></msub><msub><mi>X</mi><mi>i</mi></msub><msup><mi>X</mi><mi>T</mi></msup><mo>+</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">d\left(X^{T}\right)=\sum_{i=1}^{l} y_{i} \alpha_{i} X_{i} X^{T}+b_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2413em;vertical-align:-0.35em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1138em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>此方程就代表了边际最大化的划分超平面。</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>是支持向量点的个数，因为大部分的点并不是支持向量点，只有个别在边际超平面上的点才是支持向量点。那么我们就只对属于支持向量点的进行求和；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为支持向量点的特征值；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是支持向量点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的类别标记（class label)，比如+1还是-1；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">X^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span> 是要测试的实例，想知道它应该属于哪一类，把它带入该方程</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都是单一数值型参数，由以上提到的最优算法得出，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是拉格朗日乘数。</li></ul><p>每当有新的测试样本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，将它带入该方程，看看该方程的值是正还是负，根据符号进行归类。</p><h2 id="1-3-SVM-应用实例">1.3 SVM 应用实例</h2><p>看一下 SVM 如何求出一个划分超平面。</p><p>我们已经知道了两个支持向量点（1,1）和（2,3），设置权重为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>2</mn><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w = (a , 2a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>，那么将这两个支持向量点坐标分别带入公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mi>T</mi></msup><mi>x</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w^Tx + b = ± 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">±</span><span class="mord">1</span></span></span></span>中，可以得到:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>+</mo><mn>2</mn><mi>a</mi><mo>+</mo><msub><mi>w</mi><mn>0</mn></msub><mo>=</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mspace width="1em"/><mi>u</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a+2 a+w_{0}=-1, \quad using point (1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mi>a</mi><mo>+</mo><mn>6</mn><mi>a</mi><mo>+</mo><msub><mi>w</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mspace width="1em"/><mi>u</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2 a+6 a+w_{0}=1, \quad using point (2,3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">p</span><span class="mord mathnormal">o</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></p><img src="https://s3.bmp.ovh/imgs/2021/09/c51c221f7e95459b.png" style="zoom:67%;" /><p>由于 SVM 算法本身的实现非常复杂，所以不研究如何实现 SVM，而是采用 sklearn 库来学习 SVM 的应用问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sklearn 库中导入 svm 模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义三个点和标签</span></span><br><span class="line">X = [[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 定义分类器，clf 意为 classifier，是分类器的传统命名</span></span><br><span class="line">clf = svm.SVC(kernel = <span class="string">&#x27;linear&#x27;</span>)  <span class="comment"># .SVC（）就是 SVM 的方程，参数 kernel 为线性核函数</span></span><br><span class="line"><span class="comment"># 训练分类器</span></span><br><span class="line">clf.fit(X, y)  <span class="comment"># 调用分类器的 fit 函数建立模型（即计算出划分超平面，且所有相关属性都保存在了分类器 cls 里）</span></span><br><span class="line"><span class="comment"># 打印分类器 clf 的一系列参数</span></span><br><span class="line"><span class="built_in">print</span>(clf)</span><br><span class="line"><span class="comment"># 支持向量</span></span><br><span class="line"><span class="built_in">print</span>(clf.support_vectors_)</span><br><span class="line"><span class="comment"># 属于支持向量的点的 index </span></span><br><span class="line"><span class="built_in">print</span>(clf.support_)</span><br><span class="line"><span class="comment"># 在每一个类中有多少个点属于支持向量</span></span><br><span class="line"><span class="built_in">print</span>(clf.n_support_) </span><br><span class="line"><span class="comment"># 预测一个新的点</span></span><br><span class="line"><span class="built_in">print</span>(clf.predict([[<span class="number">2</span>,<span class="number">0</span>]]))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印分类器 clf 的一系列参数</span></span><br><span class="line">SVC(C=<span class="number">1.0</span>, cache_size=<span class="number">200</span>, class_weight=<span class="literal">None</span>, coef0=<span class="number">0.0</span>,</span><br><span class="line">  decision_function_shape=<span class="string">&#x27;ovr&#x27;</span>, degree=<span class="number">3</span>, gamma=<span class="string">&#x27;auto_deprecated&#x27;</span>,</span><br><span class="line">  kernel=<span class="string">&#x27;linear&#x27;</span>, max_iter=-<span class="number">1</span>, probability=<span class="literal">False</span>, random_state=<span class="literal">None</span>,</span><br><span class="line">  shrinking=<span class="literal">True</span>, tol=<span class="number">0.001</span>, verbose=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 支持向量</span></span><br><span class="line">[[<span class="number">1.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">2.</span> <span class="number">3.</span>]]</span><br><span class="line"><span class="comment"># 属于支持向量的点的 index</span></span><br><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 在每一个类中有多少个点属于支持向量</span></span><br><span class="line">[<span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 预测一个新的点</span></span><br><span class="line">[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(__doc__)</span><br><span class="line"><span class="comment"># 导入相关的包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl  <span class="comment"># 绘图功能</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 40 个点</span></span><br><span class="line">np.random.seed(<span class="number">0</span>) <span class="comment"># 让每次运行程序生成的随机样本点不变</span></span><br><span class="line"><span class="comment"># 生成训练实例并保证是线性可分的</span></span><br><span class="line"><span class="comment"># np._r表示将矩阵在行方向上进行相连</span></span><br><span class="line"><span class="comment"># random.randn(a,b)表示生成 a 行 b 列的矩阵，且随机数服从标准正态分布</span></span><br><span class="line"><span class="comment"># array(20,2) - [2,2] 相当于给每一行的两个数都减去 2</span></span><br><span class="line">X = np.r_[np.random.randn(<span class="number">20</span>, <span class="number">2</span>) - [<span class="number">2</span>, <span class="number">2</span>], np.random.randn(<span class="number">20</span>, <span class="number">2</span>) + [<span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="comment"># 两个类别 每类有 20 个点，Y 为 40 行 1 列的列向量</span></span><br><span class="line">Y = [<span class="number">0</span>] * <span class="number">20</span> + [<span class="number">1</span>] * <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 svm 模型</span></span><br><span class="line">clf = svm.SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">clf.fit(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得划分超平面</span></span><br><span class="line"><span class="comment"># 划分超平面原方程：w0x0 + w1x1 + b = 0</span></span><br><span class="line"><span class="comment"># 将其转化为点斜式方程，并把 x0 看作 x，x1 看作 y，b 看作 w2</span></span><br><span class="line"><span class="comment"># 点斜式：y = -(w0/w1)x - (w2/w1)</span></span><br><span class="line">w = clf.coef_[<span class="number">0</span>]  <span class="comment"># w 是一个二维数据，coef 就是 w = [w0,w1]</span></span><br><span class="line">a = -w[<span class="number">0</span>] / w[<span class="number">1</span>]  <span class="comment"># 斜率</span></span><br><span class="line">xx = np.linspace(-<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 从 -5 到 5 产生一些连续的值（随机的）</span></span><br><span class="line"><span class="comment"># .intercept[0] 获得 bias，即 b 的值，b / w[1] 是截距</span></span><br><span class="line">yy = a * xx - (clf.intercept_[<span class="number">0</span>]) / w[<span class="number">1</span>]  <span class="comment"># 带入 x 的值，获得直线方程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出和划分超平面平行且经过支持向量的两条线（斜率相同，截距不同）</span></span><br><span class="line">b = clf.support_vectors_[<span class="number">0</span>] <span class="comment"># 取出第一个支持向量点</span></span><br><span class="line">yy_down = a * xx + (b[<span class="number">1</span>] - a * b[<span class="number">0</span>]) </span><br><span class="line">b = clf.support_vectors_[-<span class="number">1</span>] <span class="comment"># 取出最后一个支持向量点</span></span><br><span class="line">yy_up = a * xx + (b[<span class="number">1</span>] - a * b[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看相关的参数值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w: &quot;</span>, w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a: &quot;</span>, a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;support_vectors_: &quot;</span>, clf.support_vectors_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;clf.coef_: &quot;</span>, clf.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 scikit-learin 中，coef_ 保存了线性模型中划分超平面的参数向量。形式为(n_classes, n_features)。若 n_classes &gt; 1，则为多分类问题，(1，n_features) 为二分类问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制划分超平面，边际平面和样本点</span></span><br><span class="line">pl.plot(xx, yy, <span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_down, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">pl.plot(xx, yy_up, <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line"><span class="comment"># 圈出支持向量</span></span><br><span class="line">pl.scatter(clf.support_vectors_[:, <span class="number">0</span>], clf.support_vectors_[:, <span class="number">1</span>],</span><br><span class="line">           s=<span class="number">80</span>, facecolors=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">pl.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=Y, cmap=pl.cm.Paired)</span><br><span class="line"></span><br><span class="line">pl.axis(<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">pl.show()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Automatically created module for IPython interactive environment</span><br><span class="line">w:  [0.90230696 0.64821811]</span><br><span class="line">a:  -1.391980476255765</span><br><span class="line">support_vectors_:  [[-1.02126202  0.2408932 ]</span><br><span class="line"> [-0.46722079 -0.53064123]</span><br><span class="line"> [ 0.95144703  0.57998206]]</span><br><span class="line">clf.coef_:  [[0.90230696 0.64821811]]</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190302195149698.png" alt="img"></p><h1>2.核方法</h1><h2 id="2-1使用核方法的动机">2.1使用核方法的动机</h2><p>在线性 SVM 中转化为最优化问题时求解的公式计算都是以内积(dot product)形式出现的，其中 ϕ ( X ) \phi(X)ϕ(X) 是把训练集中的向量点转化到高维的非线性映射函数，因为内积的算法复杂度非常大，所以我们利用核函数来取代计算非线性映射函数的内积。</p><p>以下核函数和非线性映射函数的内积等同，但核函数 K 的运算量要远少于求内积。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mrow><mo fence="true">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><mi>ϕ</mi><mrow><mo fence="true">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow><mo>⋅</mo><mi>ϕ</mi><mrow><mo fence="true">(</mo><msub><mi>X</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">K\left(X_{i}, X_{j}\right)=\phi\left(X_{i}\right) \cdot \phi\left(X_{j}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">ϕ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><h2 id="2-2常用的核函数（kernel-functions）">2.2常用的核函数（kernel functions）</h2><p>h 度多项式核函数(polynomial kernel of degree h)：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mrow><mo fence="true">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><msup><mrow><mo fence="true">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">K\left(X_{i}, X_{j}\right)=\left(X_{i}, X_{j}+1\right)^{h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2751em;vertical-align:-0.2861em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.989em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>高斯径向基核函数(Gaussian radial basis function kernel)：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mrow><mo fence="true">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><msup><mrow><mo fence="true">∥</mo><msub><mi>X</mi><mi>i</mi></msub><mo>−</mo><msub><mi>X</mi><mi>j</mi></msub><mo fence="true">∥</mo></mrow><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">K\left(X_{i}, X_{j}\right)=e^{-\left\|X_{i}-X_{j}\right\|^{2} / 2 \sigma^{2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0369em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0369em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="minner mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">∥</span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:-0.0785em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">∥</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mtight">/2</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>S 型核函数(Sigmoid function kernel)：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>K</mi><mrow><mo fence="true">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>X</mi><mi>j</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><mi>tanh</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mi>k</mi><msub><mi>X</mi><mi>i</mi></msub><mo>⋅</mo><msub><mi>X</mi><mi>j</mi></msub><mo>−</mo><mi>δ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">K\left(X_{i}, X_{j}\right)=\tanh \left(k X_{i} \cdot X_{j}-\delta\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">tanh</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p><strong>如何选择使用哪个 kernel ？</strong></p><ol><li>根据先验知识，比如图像分类，通常使用 RBF（高斯径向基核函数），文字不使用 RBF。</li><li>尝试不同的 kernel，根据结果准确度而定尝试不同的 kernel，根据结果准确度而定。</li></ol><h2 id="2-3核函数举例">2.3核函数举例</h2><p>假设定义两个向量：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x = ( x_1 , x _2 , x_ 3 ) x = (x_1, x_2, x_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>定义方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x)=\left(x_{1} x_{1}, x_{1} x_{2}, x_{1} x_{3}, x_{2} x_{1}, x_{2} x_{2}, x_{2} x_{3}, x_{3} x_{1}, x_{3} x_{2}, x_{3} x_{3}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>核函数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo>&lt;</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>&gt;</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">K(x,y)=(&lt;x,y&gt;) ^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p>假设：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mtext>，</mtext><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x=(1,2,3)，y=(4,5,6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span><br><strong>不用核函数，直接求内积：</strong></p><p><img src="https://s3.bmp.ovh/imgs/2021/09/5002651334e8d2a5.png" alt=""></p><p><strong>使用核函数：</strong></p><p><em>K</em>(<em>x</em>,<em>y</em>)=(4+10+18)2=322=1024</p><p>同样的结果，使用 kernel 方法计算容易很多。而这只是 9 维的情况，如果维度更高，那么直接求内积的方法运算复杂度会非常大。</p><p><strong>所以使用 kernel 的意义在于：</strong></p><ol><li>将向量的维度 从低维映射到高维</li><li>降低运算复杂度</li></ol><h1>3.相关概念补充</h1><h2 id="3-1性可区分和线性不可区分">3.1性可区分和线性不可区分</h2><p>能够用一条直线对样本点进行分类的属于线性可区分（linear separable），否则为线性不可区分（linear inseparable)。</p><p>以下三个例子，都是线性不可区分的，即无法用一条直线将两类样本点区分开。</p><p><img src="https://img-blog.csdnimg.cn/20190302092521390.jpg" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190302092550442.jpg" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190302092924879.png" alt="img"></p><p>而刚才的例子就是线性可区分的。</p><p><img src="https://img-blog.csdnimg.cn/20190302093034118.png" alt="img"></p><p><strong>在线性不可分的情况下，数据集在空间中对应的向量无法被一个超平面区分开，如何处理？</strong></p><p><strong>两个步骤来解决：</strong></p><ul><li>利用一个非线性的映射把原数据集中的向量点转化到一个更高维度的空间中（比如下图将二维空间中的点映射到三维空间）</li><li>在这个高维度的空间中找一个线性的超平面来根据线性可分的情况处理</li></ul><p><img src="https://img-blog.csdnimg.cn/20190303080800401.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzQ3ODY5,size_16,color_FFFFFF,t_70" alt="img"></p><p>比如想要将红点和蓝点变成线性可分的，那么就将映射 y = x 变成映射 y = x^2<br>，这样就线性可分了。</p><p><img src="https://img-blog.csdnimg.cn/20190303081111808.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190303081101648.png" alt="img"></p><p><strong>如何利用非线性映射将原始数据转化到高维空间中去？</strong></p><p>例子：<br>有一个 3 维输入向量：X = ( x 1 , x 2 , x 3 ) X=(x_1,x_2,x_3)</p><p>将其转化到 6 维空间 Z 中去：</p><p><em>ϕ</em>1(<em>X</em>)=<em>x</em>1，<em>ϕ</em>2(<em>X</em>)=<em>x</em>2，<em>ϕ</em>3(<em>X</em>)=<em>x</em>3，<em>ϕ</em>4(<em>X</em>)=(<em>x</em>1)2，<em>ϕ</em>5(<em>X</em>)=<em>x</em>1<em>x</em>2，<em>a<strong>n</strong>d</em> <em>ϕ</em>6(<em>X</em>)=<em>x</em>1<em>x</em>3</p><p>新的决策超平面：d ( Z ) = WZ + b，其中 W 和 Z 是向量，这个超平面是线性的。</p><p>解出 W 和 b 之后，并且带入回原方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>d</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>w</mi><mn>3</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><msub><mi>w</mi><mn>4</mn></msub><msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msub><mi>w</mi><mn>5</mn></msub><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>w</mi><mn>6</mn></msub><msub><mi>x</mi><mn>1</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><mi>b</mi><mo>=</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>z</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msub><mi>z</mi><mn>2</mn></msub><mo>+</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><msub><mi>w</mi><mn>3</mn></msub><msub><mi>z</mi><mn>3</mn></msub><mo>+</mo><msub><mi>w</mi><mn>4</mn></msub><msub><mi>z</mi><mn>4</mn></msub><mo>+</mo><msub><mi>w</mi><mn>5</mn></msub><msub><mi>z</mi><mn>5</mn></msub><mo>+</mo><msub><mi>w</mi><mn>6</mn></msub><msub><mi>z</mi><mn>6</mn></msub><mo>+</mo><mi>b</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}&amp;d(Z)=w_{1} x_{1}+w_{2} x_{2}+w_{3} x_{3}+w_{4}\left(x_{1}\right)^{2}+w_{5} x_{1} x_{2}+w_{6} x_{1} x_{3}+b=w_{1} z_{1}+w_{2} z_{2}+ \\&amp;w_{3} z_{3}+w_{4} z_{4}+w_{5} z_{5}+w_{6} z_{6}+b\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.114em;vertical-align:-1.307em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.807em;"><span style="top:-3.807em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span><span style="top:-2.307em;"><span class="pstrut" style="height:2.954em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.307em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.807em;"><span style="top:-3.853em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span></span></span><span style="top:-2.353em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.307em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>思考问题：</strong></p><ul><li>如何选择合理的非线性转化把数据转到高维空间中？</li><li>如何解决计算内积时算法复杂度非常高的问题？</li></ul><h2 id="3-2-SVM-可扩展到多分类问题">3.2 SVM 可扩展到多分类问题</h2><p>SVM 扩展可解决多个类别分类问题：<br>对于每个类，有一个当前类和其他类的二类分类器（one-vs-rest）<br>将多分类问题转化为 n 个二分类问题，n 就是类别个数。</p><h2 id="3-3-SVM-算法特性">3.3 SVM 算法特性</h2><p>训练好的模型的算法复杂度是由支持向量的个数决定的，而不是由数据的维度决定的。所以 SVM 不太容易产生 overfitting。<br>SVM 训练出来的模型完全依赖于支持向量，即使训练集里面所有非支持向量的点都被去除，重复训练过程，结果仍然会得到完全一样的模型。<br>一个 SVM 如果训练得出的支持向量个数比较少，那么SVM 训练出的模型比较容易被泛化。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 支持向量机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMOTE过采样算法</title>
      <link href="/2022/09/08/SMOTE%E8%BF%87%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%E3%80%81/"/>
      <url>/2022/09/08/SMOTE%E8%BF%87%E9%87%87%E6%A0%B7%E7%AE%97%E6%B3%95%E3%80%81/</url>
      
        <content type="html"><![CDATA[<h1>一、问题背景：类别不平衡</h1><h2 id="从模型的训练过程来看"><strong>从模型的训练过程来看</strong></h2><p>​从训练模型的角度来说，如果某类的样本数量很少，那么这个类别所提供的“信息”就太少。<br>​        使用经验风险（模型在训练集上的平均损失）最小化作为模型的学习准则。设损失函数为0-1 loss（这是一种典型的均等代价的损失函数），那么优化目标就等价于错误率最小化（也就是accuracy最大化）。考虑极端情况：1000个训练样本中，正类样本999个，负类样本1个。训练过程中在某次迭代结束后，模型把所有的样本都分为正类，虽然分错了这个负类，但是所带来的损失实在微不足道，accuracy已经是99.9%，于是满足停机条件或者达到最大迭代次数之后自然没必要再优化下去，ok，到此为止，训练结束！<br>​        于是这个模型没有学习到如何去判别出少数类。</p><h2 id="从模型的预测过程来看"><strong>从模型的预测过程来看</strong></h2><p>​考虑二项Logistic回归模型。输入一个样本 x ，模型输出的是其属于正类的概率 y’ 。当 y’&gt;0.5时，模型判定该样本属于正类，否则就是属于反类。<br>​为什么是0.5呢？可以认为模型是出于最大后验概率决策的角度考虑的，选择了0.5意味着当模型估计的样本属于正类的后验概率要大于样本属于负类的后验概率时就将样本判为正类。但实际上，这个后验概率的估计值是否准确呢？<br>​从几率（odds）的角度考虑：几率表达的是样本属于正类的可能性与属于负类的可能性的比值。模型对于样本的预测几率为 y’/(1-y’) 。<br>​模型在做出决策时，当然希望能够遵循真实样本总体的正负类样本分布：设 θ 等于正类样本数除以全部样本数，那么样本的真实几率为 θ/(1−θ) 。当观测几率大于真实几率时，也就是 y’&gt;θ 时，那么就判定这个样本属于正类。<br>​        虽然我们无法获悉真实样本总体，但之于训练集，存在这样一个假设：训练集是真实样本总体的无偏采样。正是因为这个假设，所以认为训练集的观测几率 θ/(1−θ) 就代表了真实几率 θ/(1−θ) 。<br>​        所以，在这个假设下，当一个样本的预测几率大于观测几率时，就应该将样本判断为正类。</p><h1>二、解决方法</h1><p>目前主要有三种办法：</p><ol><li><strong>调整 θ值</strong>（也叫再缩放、再平衡、阈值移动、是代价敏感学习的基础）</li></ol><p>根据训练集的正负样本比例，调整 θ 值。</p><p>这样做的依据是上面所述的对训练集的假设。但在给定任务中，这个假设是否成立，还有待讨论。</p><ol start="2"><li><strong>过采样</strong></li></ol><p>对训练集里面样本数量较少的类别（少数类）进行过采样，合成新的样本来缓解类不平衡。</p><p>下面将介绍一种经典的过采样算法：<strong>SMOTE</strong>。</p><ol start="3"><li><strong>欠采样</strong></li></ol><p>对训练集里面样本数量较多的类别（多数类）进行欠采样，抛弃一些样本来缓解类不平衡。</p><h1>三、SMOTE过采样算法</h1><p>SMOTE全称是Synthetic Minority Oversampling Technique即<strong>合成少数类过采样技术</strong>，它是基于随机过采样算法的一种改进方案，由于随机过采样采取简单复制样本的策略来增加少数类样本，这样容易产生模型过拟合的问题，即使得模型学习到的信息过于特别(Specific)而不够泛化(General)，SMOTE算法的基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中，算法流程如下。</p><p>1、对于少数类中每一个样本x，以欧氏距离为标准计算它到少数类样本集中所有样本的距离，得到其k近邻。</p><p>2、根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本x，从其k近邻中随机选择若干个样本，假设选择的近邻为xn。</p><p>3、对于每一个随机选出的近邻xn，分别与原样本按照如下的公式构建新的样本</p><pre><code>xnew=x+rand(0,1)∗|x−xn|</code></pre><img src="https://img-blog.csdn.net/20180128200143864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2V5Q29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom: 50%;" /><p><strong>smote算法的伪代码如下：</strong></p><img src="https://img-blog.csdn.net/20180128200323892?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2V5Q29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" style="zoom:67%;" /><p>因此，smote算法的思想是<strong>合成新的少数类样本</strong>，合成的策略是对每个少数类样本a，从它的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。</p><p><strong>下面具体介绍如何合成新的样本</strong></p><p>​设训练集的一个少数类的样本数为 T ，那么SMOTE算法将为这个少数类合成 NT 个新样本。这里要求 N 必须是正整数，如果给定的 N&lt;1 那么算法将“认为”少数类的样本数 T=NT ，并将强制 N=1 。 考虑该少数类的一个样本 ii ，其特征向量为 xi,i∈{1,…,T}：</p><p>1.首先从该少数类的全部 T 个样本中找到样本 xi 的 k个近邻（例如用欧氏距离），记为 xi(near),near∈{1,…,k}；</p><p>2.然后从这 k 个近邻中随机选择一个样本 xi(nn) ，再生成一个0 到 1 之间的随机数 ζ1 ，从而合成一个新样本 xi1 ：<br>xi1=xi+ζ1⋅(xi(nn)−xi)</p><p>3.将步骤2重复进行 N 次，从而可以合成 NN 个新样本：xinew,new∈1,…,N。</p><p>那么，对全部的 T 个少数类样本进行上述操作，便可为该少数类合成 NT个新样本。</p><p>如果样本的特征维数是 2维，那么每个样本都可以用二维平面上的一个点来表示。SMOTE算法所合成出的一个新样本 xi1 相当于是表示样本 xi的点和表示样本 xi(nn) 的点之间所连线段上的一个点。所以说该算法是基于“插值”来合成新样本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#SMOTE算法及其python实现</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestNeighbors</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Smote</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,samples,N=<span class="number">10</span>,k=<span class="number">5</span></span>):</span><br><span class="line">        self.n_samples,self.n_attrs=samples.shape</span><br><span class="line">        self.N=N</span><br><span class="line">        self.k=k</span><br><span class="line">        self.samples=samples</span><br><span class="line">        self.newindex=<span class="number">0</span></span><br><span class="line">       <span class="comment"># self.synthetic=np.zeros((self.n_samples*N,self.n_attrs))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">over_sampling</span>(<span class="params">self</span>):</span><br><span class="line">        N=<span class="built_in">int</span>(self.N/<span class="number">100</span>)</span><br><span class="line">        self.synthetic = np.zeros((self.n_samples * N, self.n_attrs))</span><br><span class="line">        neighbors=NearestNeighbors(n_neighbors=self.k).fit(self.samples)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;neighbors&#x27;</span>,neighbors</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.samples)):</span><br><span class="line">            nnarray=neighbors.kneighbors(self.samples[i].reshape(<span class="number">1</span>,-<span class="number">1</span>),return_distance=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">#print nnarray</span></span><br><span class="line">            self._populate(N,i,nnarray)</span><br><span class="line">        <span class="keyword">return</span> self.synthetic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for each minority class samples,choose N of the k nearest neighbors and generate N synthetic samples.</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_populate</span>(<span class="params">self,N,i,nnarray</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            nn=random.randint(<span class="number">0</span>,self.k-<span class="number">1</span>)</span><br><span class="line">            dif=self.samples[nnarray[nn]]-self.samples[i]</span><br><span class="line">            gap=random.random()</span><br><span class="line">            self.synthetic[self.newindex]=self.samples[i]+gap*dif</span><br><span class="line">            self.newindex+=<span class="number">1</span></span><br><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">s=Smote(a,N=<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span> s.over_sampling()</span><br></pre></td></tr></table></figure><h1>SMOTE算法的缺陷</h1><p>​该算法主要存在两方面的问题:一是在近邻选择时,存在一定的盲目性。从上面的算法流程可以看出,在算法执行过程中,需要确定K值,即选择多少个近邻样本,这需要用户自行解决。从K值的定义可以看出,K值的下限是M值(M值为从K个近邻中随机挑选出的近邻样本的个数,且有M&lt; K),M的大小可以根据负类样本数量、正类样本数量和数据集最后需要达到的平衡率决定。但K值的上限没有办法确定,只能根据具体的数据集去反复测试。因此如何确定K值,才能使算法达到最优这是未知的。<br>​       另外,该算法无法克服非平衡数据集的数据分布问题,容易产生分布边缘化问题。由于负类样本的分布决定了其可选择的近邻,如果一个负类样本处在负类样本集的分布边缘,则由此负类样本和相邻样本产生的“人造”样本也会处在这个边缘,且会越来越边缘化,从而模糊了正类样本和负类样本的边界,而且使边界变得越来越模糊。这种边界模糊性,虽然使数据集的平衡性得到了改善,但加大了分类算法进行分类的难度．</p><h1>推荐阅读：</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650718717&amp;idx=1&amp;sn=85038d7c906c135120a8e1a2f7e565ad&amp;scene=0#wechat_redirect">解决真实世界问题：如何在不平衡类上使用机器学习?</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650724464&amp;idx=1&amp;sn=1f34358862bacfb4c7ea17c864d8c44d&amp;chksm=871b1c0eb06c95180e717d8316b0380602f638a764530b4b9e35ac812c7c33799d3357d46f00&amp;scene=0&amp;key=0f5e635eeb6bf20a076ad60d7f11c6ef5c5c1c8f02873bc8b458381b629a1e2ae76174d0d4ba34331c71d095e3b3b92aa7fff5e1e11badeaf6c87ff90fd264f3dc6b1eb074eaccb2ac46e8f2d440cefd&amp;ascene=0&amp;uin=MTU1NTY3MTA0Mg==&amp;devicetype=iMac%20MacBookPro12,1%20OSX%20OSX%2010.11.6%20build%2815G1217%29&amp;version=12010310&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=csWk%2bJXfpl7rA8r527fLqF%2bF3EZEeBKpFRjI%2bWMXoPf2PEtPt/LMrscLX4GBl7gg">从重采样到数据合成：如何处理机器学习中的不平衡分类问题？</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类算法简述</title>
      <link href="/2022/09/08/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0/"/>
      <url>/2022/09/08/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1>一、K-Means(K均值)聚类</h1><p>算法步骤：<br>(1) 首先我们选择一些类/组，并随机初始化它们各自的中心点。中心点是与每个数据点向量长度相同的位置。这需要我们提前预知类的数量(即中心点的数量)。<br>(2) 计算每个数据点到中心点的距离，数据点距离哪个中心点最近就划分到哪一类中。<br>(3) 计算每一类中中心点作为新的中心点。<br>(4) 重复以上步骤，直到每一类中心在每次迭代后变化不大为止。也可以多次随机初始化中心点，然后选择运行结果最好的一个。<br>下图演示了K-Means进行分类的过程：</p><p><img src="https://img-blog.csdn.net/20180228115245278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2F0aGVyaW5lX2hzcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><ul><li>优点<ul><li>速度快，计算简便</li></ul></li><li>缺点<ul><li>我们必须提前知道数据有多少类/组。</li></ul></li></ul><p>K-Medians是K-Means的一种变体，是用数据集的<strong>中位数</strong>而不是<strong>均值</strong>来计算数据的中心点。<br>K-Medians的优势是使用中位数来计算中心点不受异常值的影响；缺点是计算中位数时需要对数据集中的数据进行排序，速度相对于K-Means较慢。</p><h2 id="二、均值漂移聚类">二、均值漂移聚类</h2><p>均值漂移聚类是基于滑动窗口的算法，来找到数据点的密集区域。这是一个基于<strong>质心</strong>的算法，通过将中心点的候选点更新为滑动窗口内点的均值来完成，来定位每个组/类的中心点。然后对这些候选窗口进行相似窗口进行去除，最终形成中心点集及相应的分组。</p><p>具体步骤：</p><ol><li>确定滑动窗口半径r，以随机选取的中心点C半径为r的圆形滑动窗口开始滑动。均值漂移类似一种爬山算法，在每一次迭代中向密度更高的区域移动，直到收敛。</li><li>每一次滑动到新的区域，计算滑动窗口内的均值来作为中心点，滑动窗口内的点的数量为窗口内的密度。在每一次移动中，窗口会想密度更高的区域移动。</li><li>移动窗口，计算窗口内的中心点以及窗口内的密度，知道没有方向在窗口内可以容纳更多的点，即一直移动到圆内密度不再增加为止。</li><li>步骤一到三会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数据点所在的滑动窗口进行聚类。</li></ol><p>下图演示了均值漂移聚类的计算步骤：</p><p><img src="https://img-blog.csdn.net/2018022816141991?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2F0aGVyaW5lX2hzcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>下面显示了所有滑动窗口从头到尾的整个过程。每个黑点代表滑动窗口的质心，每个灰点代表一个数据点。</p><p><img src="https://img-blog.csdn.net/201802281615434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2F0aGVyaW5lX2hzcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><ul><li>优点：<ul><li>不同于K-Means算法，均值漂移聚类算法不需要我们知道有多少类/组。</li><li>基于密度的算法相比于K-Means受均值影响较小。</li></ul></li><li>缺点：<ul><li>窗口半径r的选择可能是不重要的。</li></ul></li></ul><h1>三、基于密度的聚类方法(DBSCAN)</h1><p>与均值漂移聚类类似，DBSCAN也是基于密度的聚类算法。<br>具体步骤：</p><ol><li>首先确定半径r和minPoints. 从一个没有被访问过的任意数据点开始，以这个点为中心，r为半径的圆内包含的点的数量是否大于或等于minPoints，如果大于或等于minPoints则改点被标记为central point,反之则会被标记为noise point。</li><li>重复1的步骤，如果一个noise point存在于某个central point为半径的圆内，则这个点被标记为边缘点，反之仍为noise point。重复步骤1，知道所有的点都被访问过。<ul><li>优点：不需要知道簇的数量</li><li>缺点：需要确定距离r和minPoints</li></ul></li></ol><h1>四、用高斯混合模型（GMM）的最大期望（EM）聚类</h1><p>K-Means的缺点在于对聚类中心均值的简单使用。下面的图中的两个圆如果使用K-Means则不能作出正确的类的判断。同样的，如果数据集中的点类似下图中曲线的情况也是不能正确分类的。</p><p><img src="https://img-blog.csdn.net/20180228114540606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2F0aGVyaW5lX2hzcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>使用高斯混合模型（GMM）做聚类首先假设数据点是呈高斯分布的，相对应K-Means假设数据点是圆形的，高斯分布（椭圆形）给出了更多的可能性。我们有两个参数来描述簇的形状：均值和标准差。所以这些簇可以采取任何形状的椭圆形，因为在x，y方向上都有标准差。因此，每个高斯分布被分配给单个簇。<br>所以要做聚类首先应该找到数据集的均值和标准差，我们将采用一个叫做最大期望(EM)的优化算法。下图演示了使用GMMs进行最大期望的聚类过程。</p><p><img src="https://img-blog.csdn.net/20180301110131231?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2F0aGVyaW5lX2hzcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>具体步骤：</p><ol><li>选择簇的数量（与K-Means类似）并随机初始化每个簇的高斯分布参数（均值和方差）。也可以先观察数据给出一个相对精确的均值和方差。</li><li>给定每个簇的高斯分布，计算每个数据点属于每个簇的概率。一个点越靠近高斯分布的中心就越可能属于该簇。</li><li>基于这些概率我们计算高斯分布参数使得数据点的概率最大化，可以使用数据点概率的加权来计算这些新的参数，权重就是数据点属于该簇的概率。</li><li>重复迭代2和3直到在迭代中的变化不大。<br>GMMs的优点：（1）GMMs使用均值和标准差，簇可以呈现出椭圆形而不是仅仅限制于圆形。K-Means是GMMs的一个特殊情况，是方差在所有维度上都接近于0时簇就会呈现出圆形。<br>（2）GMMs是使用概率，所有一个数据点可以属于多个簇。例如数据点X可以有百分之20的概率属于A簇，百分之80的概率属于B簇。也就是说GMMs可以支持混合资格。</li></ol><h1>五、凝聚层次聚类</h1><p>层次聚类算法分为两类：自上而下和自下而上。凝聚层级聚类(HAC)是自下而上的一种聚类算法。HAC首先将每个数据点视为一个单一的簇，然后计算所有簇之间的距离来合并簇，知道所有的簇聚合成为一个簇为止。<br>下图为凝聚层级聚类的一个实例：</p><p><img src="https://img-blog.csdn.net/20180301171047257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2F0aGVyaW5lX2hzcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>具体步骤：</p><ol><li><p>首先我们将每个数据点视为一个单一的簇，然后选择一个测量两个簇之间距离的度量标准。例如我们使用average linkage作为标准，它将两个簇之间的距离定义为第一个簇中的数据点与第二个簇中的数据点之间的平均距离。</p></li><li><p>在每次迭代中，我们将两个具有最小average linkage的簇合并成为一个簇。</p></li><li><p>重复步骤2知道所有的数据点合并成一个簇，然后选择我们需要多少个簇。</p><p>层次聚类优点：</p><p>（1）不需要知道有多少个簇<br>（2）对于距离度量标准的选择并不敏感<br>缺点：效率低</p></li></ol><h1>六、图团体检测(Graph Community Detection)</h1><p>当我们的数据可以被表示为网络或图是，可以使用图团体检测方法完成聚类。在这个算法中图团体（graph community）通常被定义为一种顶点(vertice)的子集，其中的顶点相对于网络的其他部分要连接的更加紧密。下图展示了一个简单的图，展示了最近浏览过的8个网站，根据他们的维基百科页面中的链接进行了连接。</p><p><img src="https://img-blog.csdn.net/20180301163648779?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvS2F0aGVyaW5lX2hzcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>模块性可以使用以下公式进行计算：</p><p><img src="http://a1.qpic.cn/psc?/V12XQ1QV3cpyPD/05RlWl8gsTOH*Z17MtCBzC0JD4R6wvdcv*86N9UpOdENV5t9cnIhnAJ2lLVYLDABvz6Y3HHcaaX6R6VltxA0tA!!/b&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=qwPTAKsD0wADACU!&amp;tl=1&amp;vuin=1005741898&amp;tm=1635408000&amp;sce=50-1-1&amp;rf=4-0" alt=""></p><p>组合学告诉我们对于一个仅有8个顶点的网络，就存在4140种不同的聚类方式，16个顶点的网络的聚类方式将超过100亿种。32个顶点的网络的可能聚类方式更是将超过10^21种。因此，我们必须寻找一种启发式的方法使其不需要尝试每一种可能性。这种方法叫做Fast-Greedy Modularity-Maximization(快速贪婪模块性最大化)的算法，这种算法在一定程度上类似于上面描述的集聚层次聚类算法。只是这种算法不根据距离来融合团体，而是根据模块性的改变来对团体进行融合。<br>具体步骤：</p><ol><li>首先初始分配每个顶点到其自己的团体，然后计算整个网络的模块性 M。</li><li>第 1 步要求每个团体对（community pair）至少被一条单边链接，如果有两个团体融合到了一起，该算法就计算由此造成的模块性改变 ΔM。</li><li>第 2 步是取 ΔM 出现了最大增长的团体对，然后融合。然后为这个聚类计算新的模块性 M，并记录下来。</li><li>重复第 1 步和 第 2 步——每一次都融合团体对，这样最后得到 ΔM 的最大增益，然后记录新的聚类模式及其相应的模块性分数 M。</li><li>重复第 1 步和 第 2 步——每一次都融合团体对，这样最后得到 ΔM 的最大增益，然后记录新的聚类模式及其相应的模块性分数 M。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 聚类算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Batch-Size解析</title>
      <link href="/2022/09/08/Batch-Size%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/09/08/Batch-Size%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1>1.Batch Size 是什么？</h1><p>Batch Size指的是<strong>一次训练所选取的样本数</strong>，</p><p>Batch Size的大小影响<strong>模型的优化程度和速度</strong>。</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/00c6619fe888483e.png" alt=""></p><h1>2.Batch Size 对训练效果的影响</h1><ul><li>当Batch Size太小时，比如Batch Size=1。一次迭代只需对一个样本进行计算，因此单次迭代速度很快，可用于在线学习。在实际过程中，由于单个样本的随机性，<strong>一方面，训练会剧烈波动；一方面， 这种波动可能使训练到达更好的局部最小值。</strong></li><li>当Batch Size增大时，GPU的利用率会提高，对于相同的数据量处理的速度会更快一些。与此同时，Batch Size越大，其确定的下降方向越准，网络训练（收敛）的更快。</li><li>当Batch Size太大时，比如每次迭代更新使用<strong>所有的训练样本</strong>。那么迭代速度就会非常慢，甚至会出现训练不动的情况。</li></ul><h1>3.合理增大Batch Size 的好处</h1><p>在合理范围内增大Batch Size 的好处在以下几个方面：</p><ul><li>一次训练多组数据，内存利用率提高；GPU并行计算效率提高；</li><li>相比于小批量，对于相同的数据量，处理速度更快；</li><li>在一定范围内，一般来说，Batch Size 越大，其确定的梯度下降方向越准，引起的训练震荡就越小。</li></ul><h1>4. Batch Size太大的坏处</h1><p>如果盲目增大Batch Size，对训练会有一定的坏处：</p><ul><li>一次喂入的数据量太大，内存容量可能撑不住，或者显卡显存不足。</li><li>增大到一定程度后，其确定的梯度下降方向基本不再变化了。</li><li>容易陷入局部最小值，且很难再跳出。</li></ul><h1>原文博客</h1><p><a href="https://ai-wx.blog.csdn.net/article/details/118946126">Batch size问题总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深学调参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化算法</title>
      <link href="/2022/09/08/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/08/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>SGD、BGD、MBGD</h1><p>现在所说的SGD一般都指MBGD(小批量梯度下降法Mini-batch Gradient Descent)。</p><p>三种梯度下降的方法用于更新参数，也就是当前参数等于上一时刻参数减去学习率乘以梯度。</p><img src="https://ftp.bmp.ovh/imgs/2021/07/492f6351931a562b.png" style="zoom: 67%;" />三种方法的不同体现在计算梯度上 假设损失函数为二次函数，那么参数θ的更新公式为<img src="https://ftp.bmp.ovh/imgs/2021/07/7fe288e86ec0010c.png" style="zoom: 67%;" /><h2 id="SGD（随机梯度下降法Stochastic-Gradient-Descent）">SGD（随机梯度下降法Stochastic Gradient Descent）</h2><p>SGD：mini-batch gradient descent（随机梯度下降）<br>SGD就是每一次迭代每次只用<strong>一个样本</strong>计算mini-batch的梯度，然后对参数进行更新，是最常见的优化方法了。</p><p>&lt;img src=“<a href="https://ftp.bmp.ovh/imgs/2021/07/742b1819c08ba909.png">https://ftp.bmp.ovh/imgs/2021/07/742b1819c08ba909.png</a>” style=“zoom: 67%;” /</p><p>优点是速度快，缺点是可能陷入局部最优，搜索起来比较盲目，并不是每次都朝着最优的方向（因为单个样本可能噪音比较多），走的路径比较曲折（震荡）。</p><img src="https://img-blog.csdnimg.cn/20190625080633780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RwZW5nd2FuZw==,size_16,color_FFFFFF,t_70" style="zoom:67%;" /><p><img src="https://s3.bmp.ovh/imgs/2021/11/d225c73325ad2cd0.png" alt=""></p><h2 id="BGD-批梯度下降算法-Batch-Gradient-Descent）">BGD (批梯度下降算法 Batch Gradient Descent）</h2><p>计算梯度时候使用<strong>所有的数据</strong>来计算，取平均值（最原始的梯度下降算法）。</p><p>BGD算法，每走一步（更新模型参数），为了计算original-loss上的梯度，就需要遍历整个数据集，在一般深度学习任务中，这是很不现实的。</p><p>好处在于收敛次数少，坏处就是每次迭代需要用到所有数据，占用内存大耗时大。<img src="https://ftp.bmp.ovh/imgs/2021/07/8ea7df3d437d0423.png" style="zoom:67%;" /></p><img src="https://img-blog.csdnimg.cn/20190625080220317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RwZW5nd2FuZw==,size_16,color_FFFFFF,t_70" style="zoom:67%;" /><h2 id="MBGD-小批量梯度下降法Mini-batch-Gradient-Descent">MBGD (小批量梯度下降法Mini-batch Gradient Descent)</h2><p>SGD和BGD是两个极端， 而MBGD是两种方法的折中，每次选择<strong>一批数据</strong>(不是全部，也不是单个)来求梯度。<br>该方法也容易陷入局部最优。</p><p><strong>现在所说的SGD基本都是MBGD。</strong></p><p><img src="https://private.codecogs.com/gif.latex?g_%7Bt%7D%3D%20%5Ctriangledown%20_%7B%5Ctheta_%7Bt-1%7D%7DJ%28%5Ctheta_%7Bt-1%7D%29" alt="g_{t}= \triangledown {\theta{t-1}}J(\theta_{t-1})"></p><p>​        <img src="https://private.codecogs.com/gif.latex?%5Ctriangle%20%5Ctheta%20_t%20%3D%20-%5Ceta%20%5Cast%20g_t" alt="\triangle \theta _t = -\eta \ast g_t"></p><p>​       <img src="https://private.codecogs.com/gif.latex?%5Ctheta%20_t%20%3D%20%5Ctheta%20_%7Bt-1%7D+%5Ctriangle%20%5Ctheta%20_t" alt="\theta _t = \theta _{t-1}+\triangle \theta _t"></p><p>其中<img src="https://private.codecogs.com/gif.latex?%5Ctheta%20_t" alt="\theta _t">是模型参数，<img src="https://private.codecogs.com/gif.latex?J%28%5Ctheta%20_%7Bt-1%7D%29" alt="J(\theta _{t-1})">是模型目标函数，<img src="https://private.codecogs.com/gif.latex?g_t" alt="g_t">是目标函数的梯度，<img src="https://private.codecogs.com/gif.latex?%5Ceta" alt="\eta">是学习率。</p><p>SGD完全依赖于当前batch的梯度，所以η可理解为允许当前batch的梯度多大程度影响参数更新。</p><p>缺点：（正因为有这些缺点才让这么多大神发展出了后续的各种算法）</p><ul><li>选择合适的learning rate比较困难。</li><li>对所有的参数更新使用同样的learning rate。对于稀疏数据或者特征，有时我们可能想更新快一些对于不经常出现的特征，对于常出现的特征更新慢一些，这时候SGD就不太能满足要求了。</li><li>SGD容易收敛到局部最优，在某些情况下可能被困在鞍点。【但是在合适的初始化和学习率设置下，鞍点的影响其实没这么大】</li><li>“之字形”的出现，即在陡谷（一种在一个方向的弯曲程度远大于其他方向的表面弯曲情况）处震荡。如下图所示</li></ul><p><img src="https://img-blog.csdn.net/20181015224812323?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hbm1hbnhpYW93dWd1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h1>NAG（牛顿动量 Nesterov accelerated gradient）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Nesterov是Momentum的变种。</span><br><span class="line">2.与Momentum唯一区别就是，计算梯度的不同，Nesterov先用当前的速度v更新一遍参数，在用更新的临时参数计算梯度。</span><br><span class="line">3.相当于添加了矫正因子的Momentum。</span><br><span class="line">4.在GD下，Nesterov将误差收敛从O（1/k），改进到O(1/k^2)</span><br><span class="line">5.然而在SGD下，Nesterov并没有任何改进</span><br></pre></td></tr></table></figure><p>在小球向下滚动的过程中，我们希望小球能够提前知道在哪些地方坡面会上升，这样在遇到上升坡面之前，小球就开始减速。这方法就是Nesterov Momentum，其在凸优化中有较强的理论保证收敛。并且，在实践中Nesterov Momentum也比单纯的 Momentum 的效果好：</p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/e589016396e64320.png" alt="img"></p><p>其核心思想是：注意到 momentum 方法，如果只看 γ * v 项，那么当前的 θ经过 momentum 的作用会变成 θ-γ * v。因此可以把 θ-γ * v这个位置看做是当前优化的一个”展望”位置。所以，可以在 θ-γ * v求导, 而不是原始的θ。</p><p><img src="https://img-blog.csdn.net/20170805212728775?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDA4OTQ0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>我们使用<img src="https://private.codecogs.com/gif.latex?%5Cmu%20%5Cast%20m_%7Bt-1%7D" alt="img">来移动，通过计算<img src="https://private.codecogs.com/gif.latex?%5Ctheta_%7Bt-1%7D+%5Cmu%20%5Cast%20m_%7Bt-1%7D" alt="img">，我们能够得到一个下次参数位置的近似值——也就是能告诉我们参数大致会变为多少。那么，通过基于未来参数的近似值（站的更远看看）而非当前的参数值计算相得应罚函数<img src="https://private.codecogs.com/gif.latex?J%28%5Ctheta_%7Bt-1%7D+%5Cmu%20%5Cast%20m_%7Bt-1%7D%29" alt="img">并求偏导数，我们能让优化器高效地「前进」并收敛：</p><p><img src="https://private.codecogs.com/gif.latex?m_t%3D%5Cmu%20%5Cast%20m_%7Bt-1%7D-%5Ceta%20%5Ctriangledown%20J%28%5Ctheta%20_%7Bt-1%7D+%5Cmu%20%5Cast%20m_%7Bt-1%7D%29" alt="img"></p><p><img src="https://private.codecogs.com/gif.latex?%5Ctheta%20_t%20%3D%20%5Ctheta%20_%7Bt-1%7D+m_t" alt="img"></p><img src="https://img-blog.csdn.net/20170521225135450?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQlZMMTAxMDExMTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" style="zoom:50%;" /><p><img src="https://img-blog.csdn.net/20170728165011954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHN5Y2NuaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src="https://img-blog.csdn.net/20170803165730092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHN5Y2NuaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><strong>优点：</strong><br>这种基于预测的更新方法，使我们避免过快地前进，并提高了算法地响应能力，大大改进了 RNN 在一些任务上的表现【为什么对RNN好呢，不懂啊】<br>没有对比就没有伤害，NAG方法收敛速度明显加快。波动也小了很多。实际上NAG方法用到了二阶信息，所以才会有这么好的结果。<em>先按照原来的梯度走一步的时候已经求了一次梯度，后面再修正的时候又求了一次梯度，所以是二阶信息。</em></p><h1>AdaGrad</h1><p>AdaGrad 算法根据自变量在每个维度的梯度值调整各个维度的学习率，从而避免统一的维度难以适应所有维度的问题。</p><p>adagrad 方法是将每一个参数的每一次迭代的梯度取平方累加再开方，用基础学习率除以这个数，来做学习率的动态更新。【这样每一个参数的学习率就与他们的梯度有关系了，那么每一个参数的学习率就不一样了！也就是所谓的<strong>自适应学习率</strong>】。</p><p>Adagrad其实是对学习率进行了一个约束。即：</p><p><img src="https://www.zhihu.com/equation?tex=n_t%3Dn_%7Bt-1%7D%2Bg_t%5E2" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta%7B%5Ctheta_t%7D%3D-%5Cfrac%7B%5Ceta%7D%7B%5Csqrt%7Bn_t%2B%5Cepsilon%7D%7D%2Ag_t" alt="[公式]"></p><p>此处，对<img src="https://www.zhihu.com/equation?tex=g_t" alt="[公式]">从1到<img src="https://www.zhihu.com/equation?tex=t" alt="[公式]">进行一个递推形成一个约束项regularizer，<img src="https://www.zhihu.com/equation?tex=-%5Cfrac%7B1%7D%7B%5Csqrt%7B%5Csum_%7Br%3D1%7D%5Et%28g_r%29%5E2%2B%5Cepsilon%7D%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%5Cepsilon" alt="[公式]">用来保证分母非0</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/693003f60385bdf2.png" alt=""></p><p><strong>特点：</strong></p><ul><li>前期<img src="https://www.zhihu.com/equation?tex=g_t" alt="[公式]">较小的时候， regularizer较大，能够放大梯度</li><li>后期<img src="https://www.zhihu.com/equation?tex=g_t" alt="[公式]">较大的时候，regularizer较小，能够约束梯度</li><li>适合处理稀疏梯度</li></ul><p><strong>缺点：</strong></p><ul><li>由公式可以看出，仍依赖于人工设置一个全局学习率</li><li><img src="https://www.zhihu.com/equation?tex=%5Ceta" alt="[公式]">设置过大的话，会使regularizer过于敏感，对梯度的调节太大</li><li>中后期，分母上梯度平方的累加将会越来越大，使<img src="https://www.zhihu.com/equation?tex=gradient%5Cto0" alt="[公式]">，使得训练提前结束</li></ul><h1>Adadelta</h1><p>Adagrad会累加之前所有的梯度平方，而Adadelta只累加固定大小的项【其实就是相当于指数滑动平均，只用了前多少步的梯度平方平均值】，并且也不直接存储这些项，仅仅是近似计算对应的平均值【这也就是指数滑动平均的优点】</p><p>RMSprop依然需要自己设定全局学习率，因此Adadelta在RMSprop的基础上，用参数更新的平方来替代全局学习率的位置，这样就可以省略全局学习率了。</p><p><img src="https://img-blog.csdn.net/20180703191607972?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMjY5NzYx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>特点：</strong></p><ul><li>训练初中期，加速效果不错，很快</li><li>训练后期，反复在局部最小值附近抖动</li></ul><h1>momentum（动量梯度下降 Gradient Descent With Momentum）</h1><img src="https://img-blog.csdn.net/20180703160108872?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMjY5NzYx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:50%;" /><p><img src="https://s3.bmp.ovh/imgs/2021/11/18fbba011e3b53d3.png" alt=""></p><h1>RMSProp</h1><p><img src="https://i.bmp.ovh/imgs/2021/07/5a6b98969620d257.png" alt=""></p><p><img src="https://s3.bmp.ovh/imgs/2021/11/79d795a8c621eeed.png" alt=""></p><p>由于AdaGrad单调递减的学习率变化过于激进，RMSprop只关注过去一段时间的梯度平均值，离的时间越远越不重要。</p><p><img src="https://img-blog.csdn.net/2018070319350422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMjY5NzYx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><strong>特点：</strong></p><ul><li>其实RMSprop依然依赖于全局学习率</li><li>RMSprop算是Adagrad的一种发展，和Adadelta的变体，效果趋于二者之间</li><li>适合处理非平稳目标（也就是与时间有关的）</li><li>对于RNN效果很好，因为RMSprop的更新只依赖于上一时刻的更新，所以适合。？？？</li></ul><h1>Adam(Adaptive Moment Estimation)</h1><p>Adam(Adaptive Moment Estimation)本质上是带有动量项的RMSprop，它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。Adam的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=m_t%3D%5Cmu%2Am_%7Bt-1%7D%2B%281-%5Cmu%29%2Ag_t" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=n_t%3D%5Cnu%2An_%7Bt-1%7D%2B%281-%5Cnu%29%2Ag_t%5E2" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bm_t%7D%3D%5Cfrac%7Bm_t%7D%7B1-%5Cmu%5Et%7D" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bn_t%7D%3D%5Cfrac%7Bn_t%7D%7B1-%5Cnu%5Et%7D" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta%7B%5Ctheta_t%7D%3D-%5Cfrac%7B%5Chat%7Bm_t%7D%7D%7B%5Csqrt%7B%5Chat%7Bn_t%7D%7D%2B%5Cepsilon%7D%2A%5Ceta" alt="img"></p><p>其中，<img src="https://www.zhihu.com/equation?tex=m_t" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=n_t" alt="[公式]">分别是对梯度的一阶矩估计和二阶矩估计，可以看作对期望<img src="https://www.zhihu.com/equation?tex=E%7Cg_t%7C" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=E%7Cg_t%5E2%7C" alt="[公式]">的估计；<img src="https://www.zhihu.com/equation?tex=%5Chat%7Bm_t%7D" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=%5Chat%7Bn_t%7D" alt="[公式]">是对<img src="https://www.zhihu.com/equation?tex=m_t" alt="[公式]">，<img src="https://www.zhihu.com/equation?tex=n_t" alt="[公式]">的校正，这样可以近似为对期望的无偏估计。 可以看出，直接对梯度的矩估计对内存没有额外的要求，而且可以根据梯度进行动态调整，而<img src="https://www.zhihu.com/equation?tex=-%5Cfrac%7B%5Chat%7Bm_t%7D%7D%7B%5Csqrt%7B%5Chat%7Bn_t%7D%7D%2B%5Cepsilon%7D" alt="[公式]">对学习率形成一个动态约束，而且有明确的范围。</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/12494375d9ed0ab7.png" alt=""></p><p><strong>特点：</strong></p><ul><li>结合了Adagrad善于处理稀疏梯度和RMSprop善于处理非平稳目标的优点</li><li>对内存需求较小</li><li>为不同的参数计算不同的自适应学习率</li><li>也适用于大多非凸优化 - 适用于大数据集和高维空间</li></ul><h1>Adamax</h1><p>Adamax是Adam的一种变体，此方法对学习率的上限提供了一个更简单的范围。公式上的变化如下：</p><p><img src="https://www.zhihu.com/equation?tex=n_t%3Dmax%28%5Cnu%2An_%7Bt-1%7D%2C%7Cg_t%7C%29" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta%7Bx%7D%3D-%5Cfrac%7B%5Chat%7Bm_t%7D%7D%7Bn_t%2B%5Cepsilon%7D%2A%5Ceta" alt="[公式]"></p><p>可以看出，Adamax学习率的边界范围更简单</p><h1>Nadam</h1><p>Nadam类似于带有Nesterov动量项的Adam。公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bg_t%7D%3D%5Cfrac%7Bg_t%7D%7B1-%5CPi_%7Bi%3D1%7D%5Et%5Cmu_i%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=m_t%3D%5Cmu_t%2Am_%7Bt-1%7D%2B%281-%5Cmu_t%29%2Ag_t" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bm_t%7D%3D%5Cfrac%7Bm_t%7D%7B1-%5CPi_%7Bi%3D1%7D%5E%7Bt%2B1%7D%5Cmu_i%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=n_t%3D%5Cnu%2An_%7Bt-1%7D%2B%281-%5Cnu%29%2Ag_t%5E2" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bn_t%7D%3D%5Cfrac%7Bn_t%7D%7B1-%5Cnu%5Et%7D" alt="[公式]"><img src="https://www.zhihu.com/equation?tex=%5Cbar%7Bm_t%7D%3D%281-%5Cmu_t%29%2A%5Chat%7Bg_t%7D%2B%5Cmu_%7Bt%2B1%7D%2A%5Chat%7Bm_t%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5CDelta%7B%5Ctheta_t%7D%3D-%5Ceta%2A%5Cfrac%7B%5Cbar%7Bm_t%7D%7D%7B%5Csqrt%7B%5Chat%7Bn_t%7D%7D%2B%5Cepsilon%7D" alt="[公式]"></p><p>可以看出，Nadam对学习率有了更强的约束，同时对梯度的更新也有更直接的影响。一般而言，在想使用带动量的RMSprop，或者Adam的地方，大多可以使用Nadam取得更好的效果。</p><h1>优化动画图</h1><p><img src="https://img-blog.csdn.net/20160824161755284" alt=""></p><p><img src="https://img-blog.csdn.net/20160824161815758" alt=""></p><h1>附录</h1><p><img src="https://img-blog.csdn.net/20180703200322455?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMjY5NzYx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机顶级期刊会议及学习网址</title>
      <link href="/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A1%B6%E7%BA%A7%E6%9C%9F%E5%88%8A%E4%BC%9A%E8%AE%AE%E5%8F%8A%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80/"/>
      <url>/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A1%B6%E7%BA%A7%E6%9C%9F%E5%88%8A%E4%BC%9A%E8%AE%AE%E5%8F%8A%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1>CCF推荐计算机顶会/期刊</h1><p>人工智能领域最核心的四大顶会AAAI、IJCAI、ICML和NIPS，以及作为计算机视觉和自然语言为代表的CVPR和ACL这两大学术会议，也涌现了许多“后起之秀”，比如仅创立六年却有深度学习顶会“无冕之王”之称的ICLR，还有创办于1996年的大有赶超ACL之势的自然语言处理领域顶会EMNLP。</p><p><img src="https://pic3.zhimg.com/v2-96a302ec160f9d809db476e85c546a26_b.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-c1a58a9dc1c5960d877db7deaf31b62c_b.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/v2-d5a59758c6e03ee7f6bb031e66b00ac6_b.jpg" alt="img"><img src="https://pic4.zhimg.com/v2-571870548e5232dcafd81c2fa21911db_b.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/v2-15f09c69df90e4179d498549c4a8f15e_b.jpg" alt="img"></p><p>作者：爱学习的团子酱</p><p>链接：<a href="https://zhuanlan.zhihu.com/p/339490850">https://zhuanlan.zhihu.com/p/339490850</a><br>来源：知乎</p><h1>计算机视觉顶会</h1><h2 id="1、-ICCV-International-Conference-on-Computer-Vision">1、 ICCV (International Conference on Computer Vision)</h2><p>ICCV 的全称是 IEEE International Conference on Computer Vision，即国际计算机视觉大会，由IEEE主办，与计算机视觉模式识别会议（<a href="https://baike.baidu.com/item/CVPR/7054378">CVPR</a>）和欧洲计算机视觉会议（<a href="https://baike.baidu.com/item/ECCV/4240509">ECCV</a>）并称计算机视觉方向的三大顶级会议，被<a href="https://baike.baidu.com/item/%E6%BE%B3%E5%A4%A7%E5%88%A9%E4%BA%9A/146759">澳大利亚</a>ICT学术会议排名和<a href="https://baike.baidu.com/item/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A/1594491">中国计算机学会</a>等机构评为最高级别学术会议，在业内具有极高的评价。不同于在美国每年召开一次的CVPR和只在欧洲召开的ECCV，ICCV在世界范围内每两年召开一次。ICCV论文录用率非常低，是三大会议中公认级别最高的。ICCV会议时间通常在四到五天，相关领域的专家将会展示最新的研究成果。(百度百科)</p><h2 id="2、ECCV（European-Conference-on-Computer-Vision）">2、ECCV（European Conference on Computer Vision）</h2><p>ECCV的全称是European Conference on Computer Vision(欧洲计算机视觉国际会议) ，两年一次，是计算机视觉三大会议（另外两个是<a href="https://baike.baidu.com/item/ICCV">ICCV</a>和<a href="https://baike.baidu.com/item/CVPR">CVPR</a>）之一。每次会议在全球范围录用论文300篇左右，主要的录用论文都来自美国、欧洲等顶尖实验室及研究所，中国大陆的论文数量一般在10-20篇之间。ECCV2010的论文录取率为27%。</p><h2 id="3、CVPR（IEEE-Conference-on-Computer-Vision-and-Pattern-Recognition）">3、CVPR（IEEE Conference on Computer Vision and Pattern Recognition）</h2><p>国际计算机视觉与模式识别会议（CVPR）是IEEE一年一度的学术性会议，会议的主要内容是计算机视觉与<a href="https://baike.baidu.com/item/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF/10808656">模式识别技术</a>。</p><h1>计算机视觉顶刊</h1><p>TPAMI（<a href="https://link.zhihu.com/?target=http%3A//ieeexplore.ieee.org/xpl/RecentIssue.jsp%3Freload%3Dtrue%26punumber%3D34">Pattern Analysis and Machine Intelligence, IEEE Transactions on</a>）</p><h5 id="IJCV（International-Journal-of-Computer-Vision）">IJCV（International Journal of Computer Vision）</h5><h5 id="TIP（IEEE-Transactions-on-Image-Processing）">TIP（IEEE Transactions on Image Processing）</h5><h1>国内普通学术论文网站</h1><p>1.维普网 <a href="https://link.zhihu.com/?target=http%3A//t.cn/RJLp7xf">http://t.cn/RJLp7xf</a></p><p>2.中国知网 <a href="https://link.zhihu.com/?target=http%3A//t.cn/EcDxjvz">http://t.cn/EcDxjvz</a></p><p>3.万方 <a href="https://link.zhihu.com/?target=http%3A//t.cn/RQzL7Xw">http://t.cn/RQzL7Xw</a></p><p>4.全国报刊索引 <a href="https://link.zhihu.com/?target=http%3A//t.cn/Raav93J">http://t.cn/Raav93J</a></p><p><a href="https://ieeexplore.ieee.org/browse/periodicals/title">https://ieeexplore.ieee.org/browse/periodicals/title</a></p><p><a href="https://ieeexplore.ieee.org/Xplore/home.jsp">IEEE Xplore</a>校园网可以直接登不用钱。</p><h1>中文博客、国际博客</h1><p><a href="https://www.csdn.net/">CSDN</a></p><p><a href="http://www.cnblogs.com/">博客园</a></p><p><a href="https://segmentfault.com/">SegmentFault</a></p><p><a href="http://www.oschina.net/">开源中国</a></p><p><a href="http://www.w3school.com.cn">W3School</a>（前端）</p><p><a href="https://gitee.com/">Gitee代码托管</a></p><p><a href="https://github.com/">gitHub</a></p><p><a href="http://stackoverflow.com/">Stack Overflow</a></p><h1>其他</h1><p>[Al重要会议ddl计时器](</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期刊会议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不平衡分类的处理方式</title>
      <link href="/2022/09/08/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%88%86%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/09/08/%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%88%86%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>如果你研究过一点机器学习和数据科学，你肯定遇到过不平衡的类分布（imbalanced class distribution）。这种情况是指：属于某一类别的观测样本的数量显著少于其它类别。</p><p>这个问题在异常检测是至关重要的的场景中很明显，例如电力盗窃、银行的欺诈交易、罕见疾病识别等。在这种情况下，利用传统机器学习算法开发出的预测模型可能会存在偏差和不准确。</p><p>发生这种情况的原因是机器学习算法通常被设计成通过减少误差来提高准确率。所以它们并没有考虑类别的分布/比例或者是类别的平衡。</p><p>这篇指南描述了使用多种采样技术来解决这种类别不平衡问题的各种方法。本文还比较了每种技术的优缺点。最后，本文作者还向我们展示了一种让你可以创建一个平衡的类分布的方法，让你可以应用专门为此设计的集成学习技术（ensemble learning technique）。本文作者为来自 KPMG 的数据分析顾问 Upasana Mukherjee。</p><h2 id="1-不平衡数据集面临的挑战"><strong>1. 不平衡数据集面临的挑战</strong></h2><p>当今公用事业行业面临的主要挑战之一就是电力盗窃。电力盗窃是全球第三大盗窃形式。越来越多的公用事业公司倾向于使用高级的数据分析技术和机器学习算法来识别代表盗窃的消耗模式。</p><p>然而，最大的障碍之一就是海量的数据及其分布。欺诈性交易的数量要远低于正常和健康的交易，也就是说，它只占到了总观测量的大约 1-2%。这里的问题是提高识别罕见的少数类别的准确率，而不是实现更高的总体准确率。</p><p>当面临不平衡的数据集的时候，机器学习算法倾向于产生不太令人满意的分类器。对于任何一个不平衡的数据集，如果要预测的事件属于少数类别，并且事件比例小于 5%，那就通常将其称为罕见事件（rare event）。</p><h3 id="1-1不平衡类别的实例">1.1不平衡类别的实例</h3><p>让我们借助一个实例来理解不平衡类别。</p><p>例子：在一个公用事业欺诈检测数据集中，你有以下数据：</p><p>总观测 = 1000</p><p>欺诈观测 = 20</p><p>非欺诈观测 = 980</p><p>罕见事件比例 = 2%</p><p>这个案例的数据分析中面临的主要问题是：对于这些先天就是小概率的异常事件，如何通过获取合适数量的样本来得到一个平衡的数据集？</p><h3 id="1-2使用标准机器学习技术时面临的挑战">1.2使用标准机器学习技术时面临的挑战</h3><p>面临不平衡数据集的时候，传统的机器学习模型的评价方法不能精确地衡量模型的性能。</p><p>诸如决策树和 Logistic 回归这些标准的分类算法会偏向于数量多的类别。它们往往会仅预测占数据大多数的类别。在总量中占少数的类别的特征就会被视为噪声，并且通常会被忽略。因此，与多数类别相比，少数类别存在比较高的误判率。</p><p>对分类算法的表现的评估是用一个包含关于实际类别和预测类别信息的混淆矩阵（Confusion Matrix）来衡量的。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8IAicDoeYFUsXGw04ZiaIgF4tGqwwx6sY4HAicosMtjSXYN5MQzjcibzYfQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><em>如上表所示，模型的准确率 = (TP+TN) / (TP+FN+FP+TP)</em></p><p>然而，在不平衡领域时，准确率并不是一个用来衡量模型性能的合适指标。例如：一个分类器，在包含 2% 的罕见事件时，如果它将所有属于大部分类别的实例都正确分类，实现了 98% 的准确率；而把占 2% 的少数观测数据视为噪声并消除了。</p><h3 id="1-3不平衡类别的其他实例">1.3不平衡类别的其他实例</h3><p>因此，总结一下，在尝试利用不平衡数据集解决特定业务的挑战时，由标准机器学习算法生成的分类器可能无法给出准确的结果。除了欺诈性交易，存在不平衡数据集问题的常见业务问题还有：</p><ul><li>识别客户流失率的数据集，其中绝大多数顾客都会继续使用该项服务。具体来说，电信公司中，客户流失率低于 2%。</li><li>医疗诊断中识别罕见疾病的数据集</li><li>自然灾害，例如地震</li></ul><h3 id="1-4使用的数据集">1.4使用的数据集</h3><p>这篇文章中，我们会展示多种在高度不平衡数据集上训练一个性能良好的模型的技术。并且用下面的欺诈检测数据集来精确地预测罕见事件：<br>总观测 = 1000</p><p>欺诈观测 = 20</p><p>非欺诈性观测 = 980</p><p>事件比例 = 2%</p><p>欺诈类别标志 = 0（非欺诈实例）</p><p>欺诈类别标志 = 1（欺诈实例）</p><h2 id="2-处理不平衡数据集的方法"><strong>2. 处理不平衡数据集的方法</strong></h2><h3 id="2-1-数据层面的方法：重采样技术">2.1 数据层面的方法：重采样技术</h3><p>处理不平衡数据集需要在往机器学习算法输入数据之前，制定诸如提升分类算法或平衡训练数据的类（数据预处理）的策略。后者因为应用范围广泛而更常使用。</p><p>平衡分类的主要目标不是增加少数类的的频率就是降低多数类的频率。这样做是为了获得大概相同数量的两个类的实例。让我们一起看看几个重采样（resampling）技术：</p><h4 id="2-1-1-随机欠采样（Random-Under-Sampling）">2.1.1 随机欠采样（Random Under-Sampling）</h4><p>随机欠采样的目标是通过随机地消除占多数的类的样本来平衡类分布；直到多数类和少数类的实例实现平衡，目标才算达成。</p><p>总观测 = 1000</p><p>欺诈性观察 = 20</p><p>非欺诈性观察 = 980</p><p>事件发生率 = 2%</p><p>这种情况下我们不重复地从非欺诈实例中取 10% 的样本，并将其与欺诈性实例相结合。</p><p>随机欠采样之后的非欺诈性观察 = 980 x 10% = 98</p><p>结合欺诈性与非欺诈性观察之后的全体观察 = 20+98 = 118</p><p>欠采样之后新数据集的事件发生率 = 20／118 = 17%</p><ul><li>优点<ul><li>它可以提升运行时间；并且当训练数据集很大时，可以通过减少样本数量来解决存储问题。</li></ul></li><li>缺点<ul><li>它会丢弃对构建规则分类器很重要的有价值的潜在信息。</li><li>被随机欠采样选取的样本可能具有偏差。它不能准确代表大多数。从而在实际的测试数据集上得到不精确的结果。</li></ul></li></ul><h4 id="2-1-2随机过采样（Random-Over-Sampling）">2.1.2随机过采样（Random Over-Sampling）</h4><p>过采样（Over-Sampling）通过随机复制少数类来增加其中的实例数量，从而可增加样本中少数类的代表性。</p><p>总观测 = 1000</p><p>欺诈性观察 = 20</p><p>非欺诈性观察 = 980</p><p>事件发生率 = 2%</p><p>这种情况下我们复制 20 个欺诈性观察 20 次。</p><p>非欺诈性观察 = 980</p><p>复制少数类观察之后的欺诈性观察 = 400</p><p>过采样之后新数据集中的总体观察 = 1380</p><p>欠采样之后新数据集的事件发生率 = 400/1380 = 29%</p><ul><li>优点<ul><li>与欠采样不同，这种方法不会带来信息损失。</li><li>表现优于欠采样。</li></ul></li><li>缺点<ul><li>由于复制少数类事件，它加大了过拟合的可能性</li></ul></li></ul><h4 id="2-1-3-基于聚类的过采样（Cluster-Based-Over-Sampling）">2.1.3 基于聚类的过采样（Cluster-Based Over Sampling）</h4><p>在这种情况下，K-均值聚类算法独立地被用于少数和多数类实例。这是为了识别数据集中的聚类。随后，每一个聚类都被过采样以至于相同类的所有聚类有着同样的实例数量，且所有的类有着相同的大小。</p><p>总观测 = 1000</p><p>欺诈性观察 = 20</p><p>非欺诈性观察 = 980</p><p>事件发生率 = 2%</p><ul><li>多数类聚类</li></ul><ol><li>聚类 1：150 个观察</li><li>聚类 2：120 个观察</li><li>聚类 3：230 个观察</li><li>聚类 4：200 个观察</li><li>聚类 5：150 个观察</li><li>聚类 6：130 个观察</li></ol><ul><li>少数类聚类</li></ul><ol><li>聚类 1：8 个观察</li><li>聚类 2：12 个观察</li></ol><p>每个聚类过采样之后，相同类的所有聚类包含相同数量的观察。</p><ul><li>多数类聚类</li></ul><ol><li>聚类 1：170 个观察</li><li>聚类 2：170 个观察</li><li>聚类 3：170 个观察</li><li>聚类 4：170 个观察</li><li>聚类 5：170 个观察</li><li>聚类 6：170 个观察</li></ol><ul><li>少数类聚类</li></ul><ol><li>聚类 1：250 个观察</li><li>聚类 2：250 个观察</li></ol><p>基于聚类的过采样之后的事件率 = 500/ (1020+500) = 33 %</p><ul><li>优点<ul><li>这种聚类技术有助于克服类之间不平衡的挑战。表示正例的样本数量不同于表示反例的样本数量。</li><li>有助于克服由不同子聚类组成的类之间的不平衡的挑战。每一个子聚类不包含相同数量的实例。</li></ul></li><li>缺点<ul><li>正如大多数过采样技术，这一算法的主要缺点是有可能过拟合训练集。</li></ul></li></ul><h4 id="2-1-4信息性过采样：合成少数类过采样技术（SMOTE）">2.1.4信息性过采样：合成少数类过采样技术（SMOTE）</h4><p>这一技术可用来避免过拟合——当直接复制少数类实例并将其添加到主数据集时。从少数类中把一个数据子集作为一个实例取走，接着创建相似的新合成的实例。这些合成的实例接着被添加进原来的数据集。新数据集被用作样本以训练分类模型。</p><p>总观测 = 1000</p><p>欺诈性观察 = 20</p><p>非欺诈性观察 = 980</p><p>事件发生率 = 2%</p><p>从少数类中取走一个包含 15 个实例的样本，并生成相似的合成实例 20 次。</p><p>生成合成性实例之后，创建下面的数据集</p><p>少数类（欺诈性观察）= 300</p><p>多数类（非欺诈性观察）= 980</p><p>事件发生率 = 300/1280 = 23.4 %</p><ul><li>优点<ul><li>通过随机采样生成的合成样本而非实例的副本，可以缓解过拟合的问题。</li><li>不会损失有价值信息。</li></ul></li><li>缺点<ul><li>当生成合成性实例时，SMOTE 并不会把来自其他类的相邻实例考虑进来。这导致了类重叠的增加，并会引入额外的噪音。</li><li>SMOTE 对高维数据不是很有效。</li></ul></li></ul><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8nq3B8E6Ffo02wIn4HFM5m8dS7eENZLEy1IoY6h4gwq5RksvIpVksow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"  /><p><em>图 1：合成少数类过采样算法，其中 N 是属性的数量</em></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8AibmQVA6FMYcCVJ8icEogb0KNNgYT8qe8icRc524QLthFvHuLIxCEsSNw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><em>图 2：借助 SMOTE 的合成实例生成</em></p><h4 id="2-1-5-改进的合成少数类过采样技术（MSMOTE）">2.1.5 改进的合成少数类过采样技术（MSMOTE）</h4><p>这是 SMOTE 的改进版本，SMOTE 没有考虑数据集中少数类和潜在噪声的基本分布。所以为了提高 SMOTE 的效果，MSMOTE 应运而生。</p><p>该算法将少数类别的样本分为 3 个不同的组：安全样本、边界样本和潜在噪声样本。分类通过计算少数类的样本和训练数据的样本之间的距离来完成。安全样本是可以提高分类器性能的那些数据点。而另一方面，噪声是可以降低分类器的性能的数据点。两者之间的那些数据点被分类为边界样本。</p><p>虽然 MSOMTE 的基本流程与 SMOTE 的基本流程相同，在 MSMOTE 中，选择近邻的策略不同于 SMOTE。该算法是从安全样本出发随机选择 k-最近邻的数据点，并从边界样本出发选择最近邻，并且不对潜在噪声样本进行任何操作。</p><h3 id="2-2-算法集成技术（Algorithmic-Ensemble-Techniques）">2.2 算法集成技术（Algorithmic Ensemble Techniques）</h3><p>上述部分涉及通过重采样原始数据提供平衡类来处理不平衡数据，在本节中，我们将研究一种替代方法：修改现有的分类算法，使其适用于不平衡数据集。</p><p>集成方法的主要目的是提高单个分类器的性能。该方法从原始数据中构建几个两级分类器，然后整合它们的预测。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8mdwUjdSP9NibLfLdvo39ZFc3vU6p2MRickhbYXQNlGyPQkJNdTty9KUw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><em>图 3：基于集成的方法</em></p><h4 id="2-2-1-基于-Bagging-的方法">2.2.1 基于 Bagging 的方法</h4><p>Bagging 是 Bootstrap Aggregating 的缩写。传统的 Bagging 算法包括生成「n」个不同替换的引导训练样本，并分别训练每个自举算法上的算法，然后再聚合预测。</p><p>Bagging 常被用于减少过拟合，以提高学习效果生成准确预测。与 boosting 不同，bagging 方法允许在自举样本中进行替换。</p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8LocuAel0M7vqnNdXhnliaHb3HcwibQUsd1hwarAz0IcJ4icpP6COpfUnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom:67%;" /><p><em>图 4：Bagging 方法</em></p><p>总观测= 1000</p><p>欺诈观察= 20</p><p>非欺诈观察= 980</p><p>事件率= 2％</p><p>​从具有替换的群体中选择 10 个自举样品。每个样本包含 200 个观察值。每个样本都不同于原始数据集，但类似于分布和变化上与该数据集类似。机器学习算法（如 logistic 回归、神经网络与决策树）拟合包含 200 个观察的自举样本，且分类器 c1，c2 … c10 被聚合以产生复合分类器。这种集成方法能产生更强的复合分类器，因为它组合了各个分类器的结果。</p><ul><li>优点<ul><li>提高了机器学习算法的稳定性与准确性</li><li>减少方差</li><li>减少了 bagged 分类器的错误分类</li><li>在嘈杂的数据环境中，bagging 的性能优于 boosting</li></ul></li><li>缺点<ul><li>bagging 只会在基本分类器效果很好时才有效。错误的分类可能会进一步降低表现。</li></ul></li></ul><h4 id="2-2-2-基于-Boosting-的方法">2.2.2 基于 Boosting 的方法</h4><p>Boosting 是一种集成技术，它可以将弱学习器结合起来创造出一个能够进行准确预测的强大学习器。Boosting 开始于在训练数据上准备的基本分类器/弱分类器。</p><p>基本学习器/分类器是弱学习器，即预测准确度仅略好于平均水平。弱是指当数据的存在小变化时，会引起分类模型出现大的变化。</p><p>在下一次迭代中，新分类器将重点放在那些在上一轮中被错误分类的案例上。</p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8teMRguuBaakjXE4ngq69qXGYbbLMPibvZBa1uzVXVL1CTokBDDXWyicg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" style="zoom: 200%;" /><p><em>图 5：Boosting 方法</em></p><h5 id="2-2-2-1-自适应-boosting——Ada-Boost">2.2.2.1 自适应 boosting——Ada Boost</h5><p>Ada Boost 是最早的 boosting 技术，其能通过许多弱的和不准确的规则的结合来创造高准确度的预测。其中每个训练器都是被串行地训练的，其目标在每一轮正确分类上一轮没能正确分类的实例。</p><p>对于一个学习过的分类器，如果要做出强大的预测，其应该具备以下三个条件：</p><ul><li>规则简单</li><li>分类器在足够数量的训练实例上进行了训练</li><li>分类器在训练实例上的训练误差足够低</li></ul><p>每一个弱假设都有略优于随机猜测的准确度，即误差项 € (t) 应该略大约 ½-β，其中 β&gt;0。这是这种 boosting 算法的基础假设，其可以产生一个仅有一个很小的误差的最终假设。</p><p>在每一轮之后，它会更加关注那些更难被分类的实例。这种关注的程度可以通过一个权重值（weight）来测量。起初，所有实例的权重都是相等的，经过每一次迭代之后，被错误分类的实例的权重会增大，而被正确分类的实例的权重则会减小。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8UBH4XAjBgyibliaLibShQmGx6YphtOt8jN5dhmgAEJ28VLGak5seRCtkQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><em>图 6：自适应 boosting 的方法</em></p><p>比如如果有一个包含了 1000 次观察的数据集，其中有 20 次被标记为了欺诈。刚开始，所有的观察都被分配了相同的权重 W1，基础分类器准确分类了其中 400 次观察。</p><p>然后，那 600 次被错误分类的观察的权重增大为 W2，而这 400 次被正确分类的实例的权重减小为 W3。</p><p>在每一次迭代中，这些更新过的加权观察都会被送入弱的分类器以提升其表现。这个过程会一直持续，直到错误分类率显著降低，从而得到一个强大的分类器。</p><ul><li>优点<ul><li>非常简单就能实现</li><li>可以很好地泛化——适合任何类型的分类问题且不易过拟合</li></ul></li><li>缺点<ul><li>对噪声数据和异常值敏感</li></ul></li></ul><h5 id="2-2-2-2-梯度树-boosting">2.2.2.2 梯度树 boosting</h5><p>在梯度 Boosting（Gradient Boosting）中，许多模型都是按顺序训练的。其是一种数值优化算法，其中每个模型都使用梯度下降（Gradient Descent）方法来最小化损失函数 y = ax+b+e。</p><p>在梯度 Boosting 中，决策树（Decision Tree）被用作弱学习器。</p><p>尽管 Ada Boost 和梯度 Boosting 都是基于弱学习器/分类器工作的，而且都是在努力使它们变成强大的学习器，但这两种方法之间存在一些显著的差异。Ada Boost 需要在实际的训练过程之前由用户指定一组弱学习器或随机生成弱学习器。其中每个学习器的权重根据其每步是否正确执行了分类而进行调整。而梯度 Boosting 则是在训练数据集上构建第一个用来预测样本的学习器，然后计算损失（即真实值和第一个学习器的输出之间的差），然后再使用这个损失在第二个阶段构建改进了的学习器。</p><p>在每一个步骤，该损失函数的残差（residual）都是用梯度下降法计算出来的，而新的残差会在后续的迭代中变成目标变量。</p><p>梯度 Boosting 可以通过 R 语言使用 SAS Miner 和 GBM 软件包中的 Gradient Boosting Node 实现。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8jfW0Le8DnCH5PeXVODxGMHF4YiajOxuex2icic8JIFpaia2VQeWOZsEffA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><em>图 7：梯度 Boosting 方法</em></p><p>比如，如果有一个包含了 1000 次观察的训练数据集，其中有 20 次被标记为了欺诈，并且还有一个初始的基础分类器。目标变量为 Fraud，当交易是欺诈时，Fraud=1；当交易不是欺诈时，Fraud=0.</p><p>比如说，决策树拟合的是准确分类仅 5 次观察为欺诈观察的情况。然后基于该步骤的实际输出和预测输出之间的差，计算出一个可微的损失函数。该损失函数的这个残差是下一次迭代的目标变量 F1。</p><p>类似地，该算法内部计算该损失函数，并在每个阶段更新该目标，然后在初始分类器的基础上提出一个改进过的分类器。</p><ul><li>缺点<ul><li>梯度增强过的树比随机森林更难拟合</li><li>梯度 Boosting 算法通常有 3 个可以微调的参数：收缩（shrinkage）参数、树的深度和树的数量。要很好拟合，每个参数都需要合适的训练。如果这些参数没有得到很好的调节，那么就可能会导致过拟合。</li></ul></li></ul><h5 id="2-2-2-3-XGBoost">2.2.2.3 XGBoost</h5><p>XGBoost（Extreme Gradient Boosting/极限梯度提升）是 Gradient Boosting 算法的一种更先进和更有效的实现。</p><p>相对于其它 Boosting 技术的优点：</p><ul><li>速度比普通的 Gradient Boosting 快 10 倍，因为其可以实现并行处理。它是高度灵活的，因为用户可以自定义优化目标和评估标准，其具有内置的处理缺失值的机制。</li><li>和遇到了负损失就会停止分裂节点的 Gradient Boosting 不同，XGBoost 会分裂到指定的最大深度，然后会对其树进行反向的剪枝（prune），移除仅有一个负损失的分裂。</li></ul><p>XGBoost 可以使用 R 和 Python 中的 （sklearn库中）XGBoost 包实现。</p><h2 id="3-实际案例"><strong>3. 实际案例</strong></h2><h3 id="3-1-数据描述">3.1 数据描述</h3><p>这个例子使用了电信公司的包含了 47241 条顾客记录的数据集，每条记录包含的信息有 27 个关键预测变量</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8w1KJsX6wyzYuYAGpSQZW88dQY33XBibSh9j20HzDpOPg9yHibNOribiboQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>罕见事件数据集的数据结构如下，缺失值删除、异常值处理以及降维。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW8zRspIQNyjaNfjsUI6icwZ8DP7NOOCRtlfUajFdFVicaBanXn1fxIHusVGZLaovGtcYUib3hibE0Vk0g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>后面用R代码，这边不用了。</p><h2 id="结论">结论</h2><p>遇到不平衡数据集时，没有改善预测模型准确性的一站式解决方案。你可能需要尝试多个办法来搞清楚最适合数据集的采样技术。在绝大多数情况下，诸如 SMOTE 以及 MSMOTE 之类的合成技术会比传统过采样或欠采样的办法要好。</p><p>为了获得更好的结果，你可以在使用诸如 Gradeint boosting 和 XGBoost 的同时也使用 SMOTE 和 MSMOTE 等合成采样技术。</p><p>通常用于解决不平衡数据集问题的先进 bagging 技术之一是 SMOTE bagging。这个办法采取了一种完全不同于传统 bagging 技术的办法来创造每个 Bag/Bootstrap。通过每次迭代时设置一个 SMOTE 重采样率，它可以借由 SMOTE 算法生成正例。每次迭代时，负例集会被 bootstrap。</p><p>不平衡数据集的特点不同，最有效的技术也会有所不同。对比模型时要考虑相关评估参数。</p><p>在对比通过全面地结合上述技术而构建的多个预测模型时，ROC 曲线下的 Lift &amp; Area 将会在决定最优模型上发挥作用。</p><p>原文链接：<a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650724464&amp;idx=1&amp;sn=1f34358862bacfb4c7ea17c864d8c44d&amp;chksm=871b1c0eb06c95180e717d8316b0380602f638a764530b4b9e35ac812c7c33799d3357d46f00&amp;scene=0&amp;key=0f5e635eeb6bf20a076ad60d7f11c6ef5c5c1c8f02873bc8b458381b629a1e2ae76174d0d4ba34331c71d095e3b3b92aa7fff5e1e11badeaf6c87ff90fd264f3dc6b1eb074eaccb2ac46e8f2d440cefd&amp;ascene=0&amp;uin=MTU1NTY3MTA0Mg==&amp;devicetype=iMac%20MacBookPro12,1%20OSX%20OSX%2010.11.6%20build%2815G1217%29&amp;version=12010310&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=csWk%2bJXfpl7rA8r527fLqF%2bF3EZEeBKpFRjI%2bWMXoPf2PEtPt/LMrscLX4GBl7gg">从重采样到数据合成：如何处理机器学习中的不平衡分类问题？</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BN层批量归一化</title>
      <link href="/2022/09/08/BN%E5%B1%82%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96/"/>
      <url>/2022/09/08/BN%E5%B1%82%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/wjinjie/article/details/118949226">https://blog.csdn.net/wjinjie/article/details/118949226</a></p><h1>批量归一化问题总结</h1><h2 id="1、批归一化BN">1、批归一化BN</h2><p>Batch Normalization是2015年一篇论文中提出的数据归一化方法，往往用在深度神经网络中激活层之前。其作用可以加快模型训练时的收敛速度，使得模型训练过程更加稳定，避免梯度爆炸或者梯度消失。并且起到一定的正则化作用，几乎代替了Dropout。</p><h2 id="2、为什么要批归一化BN">2、为什么要批归一化BN</h2><p>以前在神经网络训练中，只是对<strong>输入层数据</strong>进行归一化处理，却没有在<strong>中间层</strong>进行归一化处理。</p><p>要知道，虽然我们对输入数据进行了归一化处理，但是输入数据经过 σ ( W X + b ) \sigma(WX+b)σ(WX+b) 这样的矩阵乘法以及非线性运算之后，其数据分布很可能被改变，<strong>而随着深度网络的多层运算之后，数据分布的变化将越来越大。</strong></p><p>如果我们能在网络的中间也进行归一化处理，那么就能将中间层数据<strong>统一到同一量纲</strong>。 这种在<strong>神经网络中间层</strong>也进行归一化处理，使训练效果更好的方法，就是批归一化Batch Normalization（BN）。</p><h2 id="3、BN-计算过程">3、BN 计算过程</h2><p><strong>下面给出 BN 算法在训练时的过程：</strong></p><p><strong>输入</strong>：上一层输出结果</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">X=x_1,x_2,...,x_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,学习参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo separator="true">,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">γ,β</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></p><p><strong>算法流程</strong>：</p><p>（1）计算上一层输出数据的均值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>μ</mi><mi>β</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu_{\beta}=\frac{1}{m} \sum_{i=1}^{m}\left(x_{i}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>其中，$m $是此次训练样本 batch 的大小。</p><p>（2）计算上一层输出数据的标准差</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>σ</mi><mi>β</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>β</mi></msub><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sigma_{\beta}^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(x_{i}-\mu_{\beta}\right)^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2472em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>（3）归一化处理，得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mover accent="true"><mi>x</mi><mo>^</mo></mover><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>μ</mi><mi>β</mi></msub></mrow><mrow><msqrt><msubsup><mi>σ</mi><mi>β</mi><mn>2</mn></msubsup></msqrt><mo>+</mo><mi>ϵ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat{x}_{i}=\frac{x_{i}-\mu_{\beta}}{\sqrt{\sigma_{\beta}^{2}}+\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9903em;vertical-align:-1.73em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.1642em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1642em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7959em;"><span style="top:-2.3987em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4374em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1242em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.88em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.88em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6758em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">ϵ</span></span></span><span style="top:-3.3942em;"><span class="pstrut" style="height:3.1642em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.8412em;"><span class="pstrut" style="height:3.1642em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.73em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 是为了避免分母为 0 而加进去的接近于 0 的很小值。</p><p>（4）重构，对经过上面归一化处理得到的数据进行重构，得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>γ</mi><msub><mover accent="true"><mi>x</mi><mo>^</mo></mover><mi>i</mi></msub><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">y_{i}=\gamma \hat{x}_{i}+\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></span></p><p>其中，$ \gamma, \beta$ 为可学习参数。</p><h2 id="4、BN中均值、方差具体怎么计算得到？">4、BN中均值、方差具体怎么计算得到？</h2><p>神经网络中传递的是张量数据，其维度通常记为【N, H, W, C】，其中 N 是batch_size，H、W是行、列，C是通道数。假设一次送入10张彩色图片进行处理，那么维度是：【10，H，W，3】。</p><p><strong>1）均值的计算</strong>：<br>就是在一个批次内（10张），将每张图中的对应通道中的数字加起来，然后求均值。必例如彩色图像有RGB三个通道。所以求均值时，需要计算的是10张图同一通道上的均值。计算过程：<strong>将10张图中所有R通道上的像素值加起来，再除以（10xHxW），即得到均值</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">u_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。同理可得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>g</mi></msub><mtext>、</mtext><msub><mi>u</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">u_g、u_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><strong>（2）方差的计算</strong>：<br>根据下式，对RGB三个通道，分别计算方差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>r</mi><mn>2</mn></msubsup><mo separator="true">,</mo><mspace width="1em"/><msubsup><mi>σ</mi><mi>g</mi><mn>2</mn></msubsup><mo separator="true">,</mo><mspace width="1em"/><msubsup><mi>σ</mi><mi>b</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma_{r}^{2}, \quad \sigma_{g}^{2}, \quad \sigma_{b}^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1972em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4169em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831em;"><span></span></span></span></span></span></span></span></span></span>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mfrac><mn>1</mn><mn>10</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>10</mn></munderover><msup><mrow><mo fence="true">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sigma^{2}=\frac{1}{10} \sum_{i=1}^{10}\left(x_{i}-\mu\right)^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">10</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="5、训练与推理中BN的区别">5、训练与推理中BN的区别</h2><p>训练时，均值、方差分别是该批次内数据相应维度上的均值与方差；训练一旦结束，学习参数gamma和bata也就确定了。</p><p>推理时，通常进行一个样本的预测，就并没有batch的概念，因此，这个时候用的是<strong>全部训练数据</strong>的均值和方差。实际过程中，这种方法比较消耗内存，所以一般通过<strong>滑动平均法</strong>来求得。</p><h2 id="6、归一化的作用（优点）">6、归一化的作用（优点）</h2><p>归一化是深度学习神经网络训练中常用的技巧，它的作用主要在于：</p><ul><li><strong>统一量纲，使网络层数据呈同一分布，使模型的训练过程更加稳定。</strong></li><li><strong>加快梯度下降的速度，促使模型快速收敛</strong></li><li><strong>在一定程度上缓解了深层网络中梯度弥散的问题</strong>，从而使训练深层网络模型更加容易（原因是：比如tanh、sigmoid等激活函数，在输入较大或较小时，梯度会出现弥散。而归一化将输入限幅在了0-1之间）</li><li>重构了原始的数据分布，一定程度上缓解过拟合，防止每批训练中某一个样本经常被挑选到，有助于提高精度。</li><li>减少了人为选择参数。在某些情况下可以取消 dropout 和 L2 正则项参数，或者采取更小的 L2 正则项约束参数。</li><li>减少了对学习率的要求。现在我们可以使用初始很大的学习率或者选择了较小的学习率，算法也能够快速训练收敛。</li><li>可以不再使用局部响应归一化。BN 本身就是归一化网络(局部响应归一化在 AlexNet 网络中存在)。</li></ul><h2 id="7、批归一化BN适用范围">7、批归一化BN适用范围</h2><h4 id="（1）-BN在激活函数之前"><strong>（1） BN在激活函数之前</strong></h4><p>在CNN中，BN一般作用在激活函数之前（如下所示，是一个经典的例子）。个人觉得，这是由激活函数的性质决定的。由于像sigmoid、tanh等激活函数，当输入过大或过小时，梯度接近于0，会导致梯度弥散，所以要在激活函数输入之前将数值限制在0-1之间。而对于relu等激活函数几乎不受这种影响，但是在relu函数之前加入BN，经过relu之后输出的数值范围也在0-1之间，因此送入卷积层计算的数值也就在0-1范围之间。</p><p>相反，如果在卷积层之前添加BN时，虽然卷积层的输入数据能限制在 0-1 范围之间，但是经过卷积层之后的数据就不一定在0-1 范围之间，就达不到在激活函数之前限幅的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.listLayers = [self.bn1,</span><br><span class="line">                   layers.Activation(<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">                   self.conv1,</span><br><span class="line">                   self.bn2,</span><br><span class="line">                   layers.Activation(<span class="string">&quot;relu&quot;</span>),</span><br><span class="line">                   self.conv2,</span><br><span class="line">                   self.dropout]</span><br></pre></td></tr></table></figure><h4 id="（2）BN适用场景"><strong>（2）BN适用场景</strong></h4><p><strong>在神经网络训练时遇到收敛速度很慢，或梯度爆炸等无法训练</strong>的状况时可以尝试BN来解决。另外，在一般使用情况下也可以加入BN来加快训练速度，提高模型精度。</p><p>BN 在每个 mini-batch 比较大，数据分布比较接近的场景比较适用。在进行训练之前，要做好充分的shuffle，否则效果会差很多。另外，由于BN需要在运行过程中统计每个mini-batch的一阶统计量和二阶统计量，因此不适用于动态的网络结构和RNN网络。</p><h2 id="8、常见的归一化类型">8、常见的归一化类型</h2><p><strong>（1）线性归一化</strong></p><p>比较适用于在数值比较集中的情况。缺点是如果 max 和 min 不稳定，很容易使得归一化结果不稳定，使得后续使用效果也不稳定。线性归一化公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">x^{\prime}=\frac{x-\min (x)}{\max (x)-\min (x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>（2）标准差标准化</strong></p><p>使经过处理的数据符合标准正太分布，即均值为 0，标准差为 1。其中 $ \mu$ 为所有样本数据的均值，$ \sigma$ 为所有样本数据的标准差。标准差标准化公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></mrow><annotation encoding="application/x-tex">x^{\prime}=\frac{x-\mu}{\sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8019em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.9463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">μ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>（3）局部响应归一化</strong></p><p>LRN （Local Response Normalization）是一种提高深度学习准确度的技术方法。在 ALexNet 中，提出了 LRN 层，对局部神经元的活动创建竞争机制，使其中响应比较大对值变得相对更大，并抑制其他反馈较小的神经元，增强了模型的泛化能力。LRN 一般是在激活、池化函数后使用。</p><p>局部响应归一化原理是仿造生物学上活跃的神经元对相邻神经元的抑制现象（侧抑制），其公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>b</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><mi>i</mi></msubsup><mo>=</mo><msubsup><mi>a</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><mi>i</mi></msubsup><mi mathvariant="normal">/</mi><msup><mrow><mo fence="true">(</mo><mi>k</mi><mo>+</mo><mi>α</mi><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><mrow><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow></munderover><msup><mrow><mo fence="true">(</mo><msubsup><mi>a</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><mi>j</mi></msubsup><mo fence="true">)</mo></mrow><mn>2</mn></msup><mo fence="true">)</mo></mrow><mi>β</mi></msup></mrow><annotation encoding="application/x-tex">b_{x, y}^{i}=a_{x, y}^{i} /\left(k+\alpha \sum_{j=\max (0, i-n / 2)}^{\min (N-1, i+n / 2)}\left(a_{x, y}^{j}\right)^{2}\right)^{\beta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2578em;vertical-align:-0.3831em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.839em;vertical-align:-1.55em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.875em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='3.600em' viewBox='0 0 875 3600'><path d='M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,-36,557 l0,84c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189l0,-92c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.961em;"><span style="top:-1.809em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mop mtight"><span class="mtight">m</span><span class="mtight">a</span><span class="mtight">x</span></span><span class="mopen mtight">(</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">n</span><span class="mord mtight">/2</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mtight">m</span><span class="mtight">i</span><span class="mtight">n</span></span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight">n</span><span class="mord mtight">/2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8747em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3831em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0787em;"><span style="top:-3.3276em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.875em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='3.600em' viewBox='0 0 875 3600'><path d='M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,9c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558l0,-144c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:2.289em;"><span style="top:-4.5029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>a 表示<strong>卷积层（包括卷积操作和激活操作）后的输出结果</strong>。这个输出的结果是一个四维数组 [batch,height,width,channel]。这个输出结构中的一个位置 [a,b,c,d]，可以理解成在某一张特征图中的某一个通道下的某个高度和某个宽度位置的点，即<strong>第 a 张特征图的第 d 个通道下的高度为 b 宽度为 c 的点。</strong></li><li><img src="https://www.zhihu.com/equation?tex=a_%7Bx%2Cy%7D%5E%7Bi%7D" alt="[公式]"> 表示第 i 片特征图在位置（x,y）运用激活函数 ReLU 后的输出。n 是同一位置上临近的 feature map 的数目，N 是特征图的总数。</li></ul><img src="https://pic4.zhimg.com/80/v2-198aff65688eabc9943a26fb0a54864f_720w.jpg" alt="img" style="zoom: 33%;" /><ul><li>参数 <img src="https://www.zhihu.com/equation?tex=k%2C+n%2C+%5Calpha%EF%BC%8C%5Cbeta" alt="[公式]"> 都是超参数。k=2，n=5，α=10-4，β=0.75。</li></ul><p>举一个例子：</p><blockquote><p>i = 10, N = 96 时，第 i=10 个卷积核在位置（x,y）处的取值为 <img src="https://www.zhihu.com/equation?tex=a_%7Bx%2Cy%7D%5E%7Bi%7D" alt="[公式]"> ，它的局部响应归一化过程如下：用 <img src="https://www.zhihu.com/equation?tex=a_%7Bx%2Cy%7D%5E%7Bi%7D+" alt="[公式]"> 除以第 8、9、10、11、12 片特征图位置（x,y）处的取值求和。</p></blockquote><p>也就是跨通道的一个 Normalization 操作。</p><p><strong>（4）非线性归一化</strong></p><p>非线性归一化经常用在数据分化比较大的场景，有些数值很大，有些很小。通过一些数学函数，将原始值进行映射。该方法包括 log、指数，正切等。</p><h2 id="9、BN、LN、IN与GN对比">9、BN、LN、IN与GN对比</h2><p>深度学习中数据的维度一般是【N, H, W, C】格式，其中 N 是batch size，H、W是特征图的高和宽，C是特征图的通道数。如下图所示，是 BN、LN、IN 与 GN 作用方式的对比图。</p><p><img src="https://img-blog.csdnimg.cn/4cdb038463ce4259823140aa74e7e020.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaW5qaWU=,size_16,color_FFFFFF,t_70" alt="img"></p><p>下面分别来解释这四种不同的归一化方式：</p><ul><li>批归一化BN：对批次方向（N）做归一化</li><li>层归一化LN：在通道方向（C）上做归一化，主要对RNN作用明显</li><li>实例归一化IN：在一个图像像素内做归一化，主要用于风格化迁移</li><li>组归一化GN：在通道方向上分组，然后再每个组内做归一化</li></ul><p>组归一化的优点：组归一化将通道分成组，并在每组内计算归一化的均值和方差。组归一化的计算与批量大小无关，所以其准确度在各种批量大小都很稳定。</p><h2 id="10、BN-和-WN-比较">10、BN 和 WN 比较</h2><p>WN（Weight Normalization）是权重归一化，它与BN都属于参数重写的方法，只是采用的方式不同。WN 是对网络权值 W进行归一化， BN 是对网络某一层输入数据进行归一化。</p><p>WN 相比 BN 的优势在于：</p><ul><li>通过重写深度学习网络的权重W的方式来加速深度学习网络参数收敛，没有引入 minbatch 的依赖，适用于 RNN、LSTM网络；而 BN 不能直接用于RNN，原因在于：(1) RNN 处理的 Sequence 是变长的；2) RNN 是基于时间状态 计算，如果直接使用 Batch Normalization 处理，需要保存每个时间状态下mini btach 的均值和方差，效率低且占内存）。</li><li>Batch Normalization 基于一个 mini batch 的数据计算均值和方差，而不是基于整个 Training set 来做，相当于进行梯度计算式引入噪声。因此，Batch Normalization 不适用于对噪声敏感的强化学习、生成模型。相反，Weight Normalization 对通过标量 g  和向量 v 对权重 W 进行重写，重写向量 v是固定的，因此，基于 Weight Normalization 的 Normalization 可以看做比 Batch Normalization 引入更少的噪声。</li><li>不需要额外的存储空间来保存 mini batch 的均值和方差，同时实现 Weight Normalization 时，对深度学习网络进行正向信号传播和反向梯度计算带来的额外计算开销也很小。因此，要比采用 Batch Normalization 进行 normalization 操作时，速度快。</li></ul><h2 id="11、归一化和标准化的联系与区别">11、归一化和标准化的联系与区别</h2><ul><li>联系：都能取消由于量纲不同引起的误差；都是一种线性变换；都是对向量按照比例压缩再进行平移。</li><li>区别：归一化是将样本的特征值转换到同一量纲下，把数据映射到 [0, 1] 或 [-1, 1] 区间内，区间放缩法是归一化的一种。标准化是将样本转换成标准正太分布，使其和整体样本分布相关，每个样本点都能对标准化产生影响。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归一化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可拓学知识目录</title>
      <link href="/2022/09/08/%E5%8F%AF%E6%8B%93%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/09/08/%E5%8F%AF%E6%8B%93%E5%AD%A6%E7%9F%A5%E8%AF%86%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>可拓学</h1><h2 id="创新四步">创新四步</h2><p>基元建模-&gt;拓展-&gt;变换-&gt;评价</p><h2 id="基元">基元</h2><ul><li>三种元：物元，事元，关系元</li><li>3种基本元组合的复合元</li><li>结构：对象，特征，量值</li><li>发散思维：一物多征，一征多物，一征多值，一值多征，一值多物，同征同值多对象</li></ul><h2 id="可托集合">可托集合</h2><h3 id="三种集合">三种集合</h3><ul><li>康拓集合</li><li>模糊集合</li><li>可拓集合</li></ul><h3 id="其他要素">其他要素</h3><ul><li>元素</li><li>准则</li><li>论域</li><li>距离和可托距</li></ul><h2 id="拓展">拓展</h2><h3 id="拓展的思维结构">拓展的思维结构</h3><ul><li>发散树：多角度多特征考虑问题</li><li>相关网：牵一发而动全身</li><li>蕴含系：世间万物蕴含因果</li><li>分合链：分解和组合的艺术</li></ul><h3 id="拓展的基本方法">拓展的基本方法</h3><ul><li>共轭分析</li><li>相关分析</li><li>蕴含分析</li><li>可扩分析</li></ul><h2 id="变换">变换</h2><h3 id="基本变换">基本变换</h3><ul><li>置换变换（置换量值，置换对象，置换特征）</li><li>增删变换（增加变换，删减变换）</li><li>扩缩变换（扩大变换，缩小变换）</li><li>组分变换（组合变换，分解变换，先组合后分解，先分解后组合）</li><li>复制变换（扩大复制，缩小复制，近似复制，多次复制）</li></ul><h3 id="变换的运算">变换的运算</h3><ul><li>主动变换（与，或，积，逆）</li><li>传导变换</li><li>共轭变换（虚实，软硬，潜显，负正）</li></ul><h2 id="选">选</h2><p>7个步骤</p><ul><li>选择衡量条件</li><li>确定权重</li><li>首次评价</li><li>建立失联函数</li><li>计算规范关联度</li><li>计算综合优度</li><li>按优度的大小排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 可拓学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可拓学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sigmoid函数与损失函数求导</title>
      <link href="/2022/09/08/sigmoid%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/"/>
      <url>/2022/09/08/sigmoid%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%B1%82%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1>深度学习：Sigmoid函数与损失函数求导</h1><h2 id="1、sigmoid函数">1、sigmoid函数</h2><p>sigmoid函数，也就是s型曲线函数，如下：<br><img src="http://r.photo.store.qq.com/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/45NBuzDIW489QBoVep5mcf*48pd3sw1EG6ASFdDywaGGCr4lxdd5LhJ4BRqpK06sV0ipiHOzf97Pdrhqvqvj5D6MUjEuN03e2lZZ5vA8.2g!/r" alt=""></p><h2 id="1-1-从指数函数到sigmoid">1.1 从指数函数到sigmoid</h2><p>首先我们来画出指数函数的基本图形：<br><img src="https://img-blog.csdn.net/20170718141138825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhpc2hlbmdxaWFuanVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>从上图，我们得到了这样的几个信息，指数函数过(0,1)点，单调递增/递减，定义域为(−∞,+∞)，值域为(0,+∞)，再来我们看一下sigmoid函数的图像：</p><p><img src="https://img-blog.csdn.net/20170718141443040?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhpc2hlbmdxaWFuanVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>如果直接把e−xe−x放到分母上，就与exex图像一样了，所以分母加上1，就得到了上面的图像，定义域是(−∞,+∞)(−∞,+∞)，值域是(0,1)(0,1)，那么就有一个很好地特性了，就是不管xx是什么，都可以得到(0,1)(0,1)之间的值；</p><h2 id="1-2-对数函数与sigmoid">1.2 对数函数与sigmoid</h2><p>首先来看一下对数函数的图像：<br><img src="https://img-blog.csdn.net/20170718141517032?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhpc2hlbmdxaWFuanVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>对数函数的图像如上，单调递减，有一个比较好的特性就是在(0,1)(0,1)之间，在接近0的时候，就近无穷大，接近1的时候为0，如果我们把前面的sigmoid函数放到自变量的位置上，就得到了(0,1)(0,1)的图像；</p><p>我们如何来衡量一个结果与实际计算值得差距呢？一种思路就是，如果结果越接近，差值就越小，反之越大，这个函数就提供了这样一种思路，如果计算得到的值越接近1，那么那么表示与世界结果越接近，反之越远，所以利用这个函数，可以作为逻辑回归分类器的损失函数，如果所有的结果都能接近结果值，那么就越接近于0，如果所有的样本计算完成以后，结果接近于0，就表示计算结果与实际结果非常相近。</p><h1>sigmoid函数求导</h1><p>sigmoid导数具体的推导过程如下：<br><img src="http://a1.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5p2BoDdDGE3C9GgoOAwcZ46Xt1h.nEPTaeD4vpTM6*1vIOlBtRe0xiJJx3PJi53RUlpunUxPqIaf4R3me9KsVis!/c&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=yQFrAckBawEDGTw!&amp;tl=1&amp;vuin=1005741898&amp;tm=1619020800&amp;sce=60-2-2&amp;rf=0-0" alt=""></p><h2 id="神经网络损失函数求导">神经网络损失函数求导</h2><p>神经网络的损失函数可以理解为是一个多级的复合函数，求导使用链式法则。<br><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/45NBuzDIW489QBoVep5mcRJuoBoG9GSnvJHF*2oFLc6yUTYBZBJ3B1rAuCZQjPrQXzFAi2b*LXCApUHrQX6o.vRJzg8p2NufGYgHR9y0BOw!/b&amp;bo=QwT*AEME*wADGTw!&amp;rf=viewer_4" alt=""></p><h4 id="简化复合函数求导：">简化复合函数求导：</h4><p><img src="https://img-blog.csdn.net/20170718141630182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhpc2hlbmdxaWFuanVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>如上图所示，我们从上往下开始计算，将每个单元的值计算出来，然后计算每个单元的偏导数，保存下来；</p><p>接下来继续计算子单元的值，子单元的偏导数，保存下来；将最后的子单元到根节点所在的路径的所有偏导乘起来，就是该函数对这个变量的偏导，计算的本质就是从上往下，计算的时候将值存起来，乘到后面的单元上去，这样每个路径的偏导计算只需要一次，从上到下计算一遍就得到了所有的偏导数。</p><p>实际上BP(Backpropagation，反向传播算法)，就是如此计算的，如果现在有一个三层的神经网络，有输入、一个隐藏层，输出层，我们对损失函数求权重的偏导数，它是一个复杂的复合函数，如果先对第一层的权重求偏导，然后在对第二层的权重求偏导，会发现，其中有很多重复计算的步骤，就像上面的简单函数的示例，所以，为了避免这种消耗，我们采用的就是从后往前求偏导，求出每个单元的函数值，求出对应单元的偏导数，保存下来，一直乘下去，输入层。</p><p>下面用一个简单的示例来演示一下<strong>反向传播求偏导</strong>的过程：<br><img src="https://img-blog.csdn.net/20170718141653072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhpc2hlbmdxaWFuanVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 损失函数函数求导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数模国赛当天推荐流程</title>
      <link href="/2022/09/08/%E6%95%B0%E6%A8%A1%E5%9B%BD%E8%B5%9B%E5%BD%93%E5%A4%A9%E6%8E%A8%E8%8D%90%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/09/08/%E6%95%B0%E6%A8%A1%E5%9B%BD%E8%B5%9B%E5%BD%93%E5%A4%A9%E6%8E%A8%E8%8D%90%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>国赛流程</h1><h2 id="时间安排：">时间安排：</h2><p>第一天晚上：问题分析，模型讨论，数据处理，模型假设。</p><p>第二天：代码与模型公式的准备。流程图的书写</p><p>第三天：完成所有问题的求解，同时帮助论文手制作图片。</p><p>第四天：完成论文书写。前4个小时前一起看论文改正。最后两小时用来打包提交。</p><h2 id="题目思路：">题目思路：</h2><h3 id="1-问题复述">1.问题复述</h3><ul><li>题意</li><li>数据的抓取</li><li>条件的捕捉</li></ul><h3 id="2-问题分析">2.问题分析</h3><p>每道题具体分析具体情况，注意结合数据。</p><h3 id="3-模型假设">3.模型假设</h3><p>基于问题分析，我们把无关因素全部排除，模型假设中执行。</p><ul><li>内部联系</li><li>外部因素</li><li>数据层面</li></ul><h3 id="4-因素确定">4.因素确定</h3><p>如果是评价模型，需要做提炼指标。如果没有数据需要找数据，但是一定要把影响因素都找出来，有时会生成二级的指标，注意符合客观事实，可以参考别的相关文献。</p><h3 id="5-模型讨论">5.模型讨论</h3><p>具体问题具体讨论，如果出现两种可能都很好的解，可以让两人分别执行，注意不要太浪费时间。尽量还是一个模型为主。</p><h3 id="6-代码coding与论文picturing（画图）">6.代码coding与论文picturing（画图）</h3><p>求解的流程图与求解代码同时进行，不要跟错。模型手可以做查找论文以及辅助绘图的工作，也可以帮忙coding。</p><h3 id="7-结果分析">7.结果分析</h3><p>每道题的结果最好大家来一起讨论，可以帮助论文手写出更好的论文，也可以帮助模型的改良。</p><h3 id="8-模型检验">8.模型检验</h3><p>代码手再最后需要进行灵敏度检验，模型的进一步的表现预期，简单一个图4、5行话即可。</p><h3 id="9-共同写作">9.共同写作</h3><p>论文一定要再最后一起过一遍，尤其是摘要！</p><p>模型的评价，可以一起来评价。</p><h3 id="10-打包处理">10.打包处理</h3><p>这一步也要一起做，操作简单，但是不能犯错。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LR逻辑回归模型</title>
      <link href="/2022/09/08/LR%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/09/08/LR%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>LR逻辑回归(logistics regression)</h1><p>逻辑回归是一个分类算法，它可以处理二元分类以及多元分类。<br>逻辑回归就是根据之前的数据，预测某事件为真的概率值</p><h2 id="一-分类和回归任务的区别"><strong>一.分类和回归任务的区别</strong></h2><p>​我们可以按照任务的种类,将任务分为回归任务和分类任务.那这两者的区别是什么呢?按照较官方些的说法,输入变量与输出变量均为连续变量的预测问题是回归问题,输出变量为有限个离散变量的预测问题成为分类问题.</p><p>​通俗一点讲,我们要预测的结果是一个数,比如要通过一个人的饮食预测一个人的体重,体重的值可以有无限多个,有的人50kg,有的人51kg,在50和51之间也有无限多个数.这种预测结果是某一个确定数,而具体是哪个数有无限多种可能的问题,我们会训练出一个模型,传入参数后得到这个确定的数,这类问题我们称为回归问题.预测的这个变量(体重)因为有无限多种可能,在数轴上是连续的,所以我们称这种变量为连续变量.<br>​我们要预测一个人身体健康或者不健康,预测会得癌症或者不会得癌症,预测他是水瓶座,天蝎座还是射手座,这种结果只有几个值或者多个值的问题,我们可以把每个值都当做一类,预测对象到底属于哪一类.这样的问题称为分类问题.如果一个分类问题的结果只有两个,比如&quot;是&quot;和&quot;不是&quot;两个结果,我们把结果为&quot;是&quot;的样例数据称为&quot;正例&quot;,讲结果为&quot;不是&quot;的样例数据称为&quot;负例&quot;,对应的,这种结果的变量称为离散型变量.</p><h2 id="二-逻辑回归不是回归"><strong>二.逻辑回归不是回归</strong></h2><p>​从名字来理解逻辑回归.在逻辑回归中,逻辑一词是logistics [lə’dʒɪstɪks]的音译字,并不是因为这个算法是突出逻辑的特性.</p><p>​至于回归,我们前一段讲到回归任务是结果为连续型变量的任务,logistics regression是用来做分类任务的,为什么叫回归呢?那我们是不是可以假设,逻辑回归就是用回归的办法来做分类的呢.跟上思路.</p><h3 id="三-怎么做">三.怎么做</h3><p>​假设刚刚的思路是正确的,逻辑回归就是在用回归的办法做分类任务,那有什么办法可以做到呢,此时我们就先考虑最简单的二分类,结果是正例或者负例的任务.</p><p>​按照多元线性回归的思路,我们可以先对这个任务进行线性回归,学习出这个事情结果的规律,比如根据人的饮食,作息,工作和生存环境等条件预测一个人&quot;有&quot;或者&quot;没有&quot;得恶性肿瘤,可以先通过回归任务来预测人体内肿瘤的大小,取一个平均值作为阈值,假如平均值为y,肿瘤大小超过y为恶心肿瘤,无肿瘤或大小小于y的,为非恶性.这样通过线性回归加设定阈值的办法,就可以完成一个简单的二分类任务.如下图:</p> <img src="https://img-blog.csdnimg.cn/20181110164028163.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQ0NTU1Ng==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><p>​上图中,红色的x轴为肿瘤大小,粉色的线为回归出的函数的图像,绿色的线为阈值.<br>​预测肿瘤大小还是一个回归问题,得到的结果(肿瘤的大小)也是一个连续型变量.通过设定阈值,就成功将回归问题转化为了分类问题.但是,这样做还存在一个问题.</p><p>​我们上面的假设,依赖于所有的肿瘤大小都不会特别离谱,如果有一个超大的肿瘤在我们的例子中,阈值就很难设定.加入还是取平均大小为阈值,则会出现下图的情况:</p><p>​         <img src="https://img-blog.csdnimg.cn/20181110165551883.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQ0NTU1Ng==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /></p><p>​从上边的例子可以看出,使用线性的函数来拟合规律后取阈值的办法是行不通的,行不通的原因在于拟合的函数太直,离群值(也叫异常值)对结果的影响过大,但是我们的整体思路是没有错的,错的是用了太&quot;直&quot;的拟合函数,如果我们用来拟合的函数是非线性的,不这么直,是不是就好一些呢?</p><p>​所以我们下面来做两件事:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1-找到一个办法解决掉回归的函数严重受离群值影响的办法.</span><br><span class="line">2-选定一个阈值.</span><br></pre></td></tr></table></figure><h2 id="四-把回归函数掰弯"><strong>四:把回归函数掰弯</strong></h2><p>​没错,本小节用来解决上边说的第一个问题.开玩笑了,无论如何我也不可能掰弯这个函数.我们能做的呢,就是换一个.原来的判别函数我们用线性的y = <img src="https://private.codecogs.com/gif.latex?w%5E%7BT%7Dx" alt="w^{T}x">,逻辑回归的函数呢,我们目前就用sigmod函数,函数如下:</p><img src="https://img-blog.csdnimg.cn/20200407172245460.png" style="zoom: 50%;" /><p>​公式中,e为欧拉常数(是常数,如果不知道,自行百度),Z就是我们熟悉的多元线性回归中的<img src="https://private.codecogs.com/gif.latex?W%5E%7BT%7DX" alt="W^{T}X">,建议现阶段大家先记住逻辑回归的判别函数用它就好了.</p><p>​就像我们说多元线性回归的判别函数为<img src="https://private.codecogs.com/gif.latex?y%20%3D%20w_%7B0%7Dx_%7B0%7D%20+%20w_%7B1%7Dx_%7B1%7D%20+%20...%20+w_%7Bn%7Dx_%7Bn%7D" alt="y = w_{0}x_{0} + w_{1}x_{1} + ... +w_{n}x_{n}">一样.追究为什么是他花费的经历会比算法本身更多.</p><p>sigmod函数的图像如下:</p><img src="https://img-blog.csdnimg.cn/20181110172820614.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQ0NTU1Ng==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 33%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = numpy.dot(X, theta)     <span class="comment">#python代码</span></span><br><span class="line">h = <span class="number">1</span>/(<span class="number">1</span>+numpy.exp(-z))     <span class="comment"># exp: e 的多少次方</span></span><br></pre></td></tr></table></figure><p>​该函数具有很强的鲁棒性(鲁棒是Robust的音译，也就是健壮和强壮的意思),并且将函数的输入范围(∞,-∞)映射到了输出的(0,1)之间且具有概率意义.具有概率意义是怎么理解呢:将一个样本输入到我们学习到的函数中,输出0.7,意思就是这个样本有70%的概率是正例,1-70%就是30%的概率为负例.</p><p>​再次强调一下,如果你的数学功底很好,可以看一下我上边分享的为什么是sigmod函数的连接,如果数学一般,我们这个时候没有必要纠结为什么是sigmod,函数那么多为什么选他.学习到后边你自然就理解了</p><p>​总结一下上边所讲:我们利用线性回归的办法来拟合然后设置阈值的办法容易受到离群值的影响,sigmod函数可以有效的帮助我们解决这一个问题,所以我们只要在拟合的时候把即y =<img src="https://private.codecogs.com/gif.latex?y%20%3D%20w_%7B0%7Dx_%7B0%7D%20+%20w_%7B1%7Dx_%7B1%7D%20+%20...%20+w_%7Bn%7Dx_%7Bn%7D" alt="img"> 换成<img src="https://private.codecogs.com/gif.latex?W%5E%7BT%7DX" alt="img">即可,其中</p><p>z=<img src="https://private.codecogs.com/gif.latex?W%5E%7BT%7DX" alt="img">,也就是说g(z) =<img src="https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B1%20+%20e%5E%7Bw%5E%7BT%7Dx%7D%7D" alt="img"> . 同时,因为g(z)函数的特性,它输出的结果也不再是预测结果,而是一个值预测为正例的概率,预测为负例的概率就是1-g(z).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数形式表达:</span><br><span class="line"></span><br><span class="line">         P(y=0|w,x) = 1 – g(z)</span><br><span class="line"></span><br><span class="line">         P(y=1|w,x) =  g(z)</span><br><span class="line"></span><br><span class="line">         P(正确) = *         为某一条样本的预测值,取值范围为0或者1.</span><br><span class="line"></span><br><span class="line">到这里,我们得到一个回归函数,它不再像y=wT * x一样受离群值影响,他的输出结果是样本预测为正例的概率(0到1之间的小数).我们接下来解决第二个问题:选定一个阈值.</span><br></pre></td></tr></table></figure><h2 id="五-选定阈值"><strong>五:选定阈值</strong></h2><p>​选定阈值的意思就是,当我选阈值为0.5,那么小于0.5的一定是负例,哪怕他是0.49.此时我们判断一个样本为负例一定是准确的吗?其实不一定,因为它还是有49%的概率为正利的.但是即便他是正例的概率为0.1,我们随机选择1w个样本来做预测,还是会有接近100个预测它是负例结果它实际是正例的误差.无论怎么选,误差都是存在的.所以我们选定阈值的时候就是在选择可以接受误差的程度.<br>​我们现在知道了sigmod函数预测结果为一个0到1之间的小数,选定阈值的第一反应,大多都是选0.5,其实实际工作中并不一定是0.5,阈值的设定往往是根据实际情况来判断的.本小节我们只举例让大家理解为什么不完全是0.5,并不会有一个万能的答案,都是根据实际工作情况来定的.</p><p>​0到1之间的数阈值选作0.5当然是看着最舒服的,可是假设此时我们的业务是像前边的例子一样,做一个肿瘤的良性恶性判断.选定阈值为0.5就意味着,如果一个患者得恶性肿瘤的概率为0.49,模型依旧认为他没有患恶性肿瘤,结果就是造成了严重的医疗事故.此类情况我们应该将阈值设置的小一些.阈值设置的小,加入0.3,一个人患恶性肿瘤的概率超过0.3我们的算法就会报警,造成的结果就是这个人做一个全面检查,比起医疗事故来讲,显然这个更容易接受.<br>​第二种情况,加入我们用来识别验证码,输出的概率为这个验证码识别正确的概率.此时我们大可以将概率设置的高一些.因为即便识别错了又能如何,造成的结果就是在一个session时间段内重试一次.机器识别验证码就是一个不断尝试的过程,错误率本身就很高.</p><p>​ 以上两个例子可能不大准确,只做意会,你懂了就好.</p><pre><code>到这里,逻辑回归的由来我们就基本理清楚了,现在我们知道了逻辑回归的判别函数就是![img](https://private.codecogs.com/gif.latex?g%28z%29%20%3D%20%5Cfrac%7B1%7D%7B1+e%5E%7B-z%7D%7D)</code></pre><p>，z=<img src="https://private.codecogs.com/gif.latex?W%5E%7BT%7DX" alt="img"></p><h2 id="六-最大似然估计"><strong>六.最大似然估计</strong></h2><p>​此时我们想要找到一组w,使函数<img src="https://private.codecogs.com/gif.latex?g%28z%29%20%3D%20%5Cfrac%7B1%7D%7B1+e%5E%7B-z%7D%7D" alt="g(z) = \frac{1}{1+e^{-z}}">正确的概率最大.而我们在上面的推理过程中已经得到每个单条样本预测正确概率的公式:</p><pre><code>P(正确) =![(g(w,xi))^&#123;y^&#123;i&#125;&#125;](https://private.codecogs.com/gif.latex?%28g%28w%2Cxi%29%29%5E%7By%5E%7Bi%7D%7D) *![img](https://private.codecogs.com/gif.latex?%281-g%28w%2Cxi%29%29%5E%7B1-y%5E%7Bi%7D%7D)若想让预测出的结果全部正确的概率最大,根据最大似然估计([多元线性回归推理](https://blog.csdn.net/weixin_39445556/article/details/81416133)中有讲过,此处不再赘述),就是所有样本预测正确的概率相乘得到的P(总体正确)最大,此时我们让&lt;img src=&quot;https://img-blog.csdnimg.cn/20181110220832633.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt; ,数学表达形式如下:</code></pre><img src="https://img-blog.csdnimg.cn/2018111022095526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQ0NTU1Ng==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 25%;" /><p>​上述公式最大时公式中W的值就是我们要的最好的W.下面对公式进行求解.</p><p>​     我们知道,一个连乘的函数是不好计算的,我们可以通过两边同事取log的形式让其变成连加.</p><img src="https://img-blog.csdnimg.cn/2018111022143681.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQ0NTU1Ng==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:33%;" /><p>得到的这个函数越大,证明我们得到的W就越好.因为在函数最优化的时候习惯让一个函数越小越好,所以我们在前边加一个负号.得到公式如下:</p><p><img src="https://img-blog.csdnimg.cn/20181110222213701.jpg" alt="img"></p><p>这个函数就是我们逻辑回归(logistics regression)的损失函数,我们叫它<strong>交叉熵损失函数</strong>.</p><h2 id="七-求解交叉熵损失函数"><strong>七.求解交叉熵损失函数</strong></h2><p>​求解损失函数的办法我们还是使用梯度下降,同样在<a href="https://blog.csdn.net/weixin_39445556/article/details/83661219">批量梯度下降与随机梯度下降</a>一节有详细写到,此处我们只做简要概括.</p><p>求解步骤如下:</p><p>​        1-随机一组W.</p><p>​        2-将W带入交叉熵损失函数,让得到的点沿着负梯度的方向移动.</p><p>​        3-循环第二步.</p><p>​    求解梯度部分同样是对损失函数求偏导,过程如下:</p><p><img src="https://img-blog.csdnimg.cn/20181110223349772.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQ0NTU1Ng==,size_16,color_FFFFFF,t_70" alt="img"></p><p>交叉熵损失函数的梯度和最小二乘的梯度形式上完全相同,区别在于,此时的<img src="https://private.codecogs.com/gif.latex?h_%7B%5CTheta%7D%28x%29%20%3D%20g%28z%29" alt="h_{\Theta}(x) = g(z)">。而最小二乘的<img src="https://private.codecogs.com/gif.latex?h_%7B%5CTheta%7D%20%3D%20W%5E%7BT%7DX" alt="h_{\Theta} = W^{T}X"></p><p>PS:加一个总结:逻辑回归为什么对切斜的数据特别敏感(正负例数据比例相差悬殊时预测效果不好)</p><p>​    首先从文章开头部分举例的两个图可以看到,使用线性模型进行分类第一个要面对的问题就是如何降低离群值的影响,而第二大问题就是,在正负例数据比例相差悬殊时预测效果不好.为什么会出现这种情况呢?原因来自于逻辑回归交叉熵损失函数是通过最大似然估计来推导出的.</p><p>​使用最大似然估计来推导损失函数,那无疑,我们得到的结果就是所有样本被预测正确的最大概率.注意重点是我们得到的结果是预测正确率最大的结果,100个样本预测正确90个和预测正确91个的两组w,我们会选正确91个的这一组.那么,当我们的业务场景是来预测垃圾邮件,预测黄色图片时,我们数据中99%的都是负例(不是垃圾邮件不是黄色图片),如果有两组w,第一组为所有的负例都预测正确,而正利预测错误,正确率为99%,第二组是正利预测正确了,但是负例只预测出了97个,正确率为98%.此时我们算法会认为第一组w是比较好的.但实际我们业务需要的是第二组,因为正例检测结果才是业务的根本.</p><p>​此时我们需要对数据进行欠采样/重采样来让正负例保持一个差不多的平衡,或者使用树型算法来做分类.一般树型分类的算法对数据倾斜并不是很敏感,但我们在使用的时候还是要对数据进行欠采样/重采样来观察结果是不是有变好.</p><p>————————————————<br>版权声明：本文为CSDN博主「winrar_setup.rar」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_39445556/article/details/83930186">https://blog.csdn.net/weixin_39445556/article/details/83930186</a></p><h2 id="python代码参考">python代码参考</h2><h3 id="普通逻辑回归">普通逻辑回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">data = numpy.loadtxt(<span class="string">&#x27;logicData2.txt&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    x, y = data[:, :-<span class="number">1</span>], data[:, -<span class="number">1</span>]</span><br><span class="line">    X = (x - numpy.mean(x, axis=<span class="number">0</span>)) / numpy.std(x, axis=<span class="number">0</span>, ddof=<span class="number">1</span>)</span><br><span class="line">    onex, y = numpy.c_[numpy.ones(<span class="built_in">len</span>(X)), X], numpy.c_[y]</span><br><span class="line">    m, n = onex.shape</span><br><span class="line">    alpha, iter0 = <span class="number">0.1</span>, <span class="number">20000</span></span><br><span class="line">    theta, J = numpy.zeros((n, <span class="number">1</span>)), numpy.zeros(iter0)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter0):</span><br><span class="line">        z = numpy.dot(onex, theta)</span><br><span class="line">        h = <span class="number">1</span> / (<span class="number">1</span> + numpy.exp(-z))</span><br><span class="line">        J[i] = (-<span class="number">1</span> / m) * numpy.<span class="built_in">sum</span>(y * numpy.log(h) + (<span class="number">1</span> - y) * numpy.log(<span class="number">1</span> - h))</span><br><span class="line">        grad = (<span class="number">1</span> / m) * numpy.dot(onex.T, h - y)</span><br><span class="line">        theta -= alpha * grad</span><br><span class="line">    <span class="built_in">print</span>(theta)</span><br></pre></td></tr></table></figure><h3 id="多元逻辑回归">多元逻辑回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = numpy.loadtxt(<span class="string">&#x27;logicData2.txt&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    x, y = data[:, :-<span class="number">1</span>], data[:, -<span class="number">1</span>]</span><br><span class="line">    X = (x - numpy.mean(x, axis=<span class="number">0</span>)) / numpy.std(x, axis=<span class="number">0</span>, ddof=<span class="number">1</span>)</span><br><span class="line">    onex, y = numpy.c_[numpy.ones(<span class="built_in">len</span>(X)), X], numpy.c_[y]</span><br><span class="line">    m, n = onex.shape</span><br><span class="line">    alpha, iter0 = <span class="number">0.1</span>, <span class="number">20000</span></span><br><span class="line">    theta, J = numpy.zeros((n, <span class="number">1</span>)), numpy.zeros(iter0)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter0):</span><br><span class="line">    z = numpy.dot(onex, theta)</span><br><span class="line">    h = <span class="number">1</span> / (<span class="number">1</span> + numpy.exp(-z))</span><br><span class="line">J[i] = (-<span class="number">1</span> / m) * numpy.<span class="built_in">sum</span>(y * numpy.log(h) + (<span class="number">1</span> - y) * numpy.log(<span class="number">1</span> - h)</span><br><span class="line">     grad = (<span class="number">1</span> / m) * numpy.dot(onex.T, h - y)</span><br><span class="line">        theta -= alpha * grad</span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"><span class="built_in">print</span>(J)</span><br></pre></td></tr></table></figure><h3 id="非线性逻辑回归">非线性逻辑回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取数据</span></span><br><span class="line">data = numpy.loadtxt(<span class="string">&#x27;logicData.txt&#x27;</span>, delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment"># 多项式的次数</span></span><br><span class="line">d = <span class="number">3</span></span><br><span class="line"><span class="comment"># 数据处理</span></span><br><span class="line">x, y = data[:, :-<span class="number">1</span>], data[:, -<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 特征缩放</span></span><br><span class="line">X = (x - numpy.mean(x)) / numpy.std(x, axis=<span class="number">0</span>, ddof=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># onex的拼接</span></span><br><span class="line">onex = numpy.c_[numpy.ones(<span class="built_in">len</span>(X))]</span><br><span class="line">y = numpy.c_[y]</span><br><span class="line"><span class="comment"># onex = numpy.c_[numpy.ones(len(X)), X[:, 0] ** 1, X[:, 0] ** 2, X[:, 0] ** 3]</span></span><br><span class="line"><span class="comment"># 拼接x1^i</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, d + <span class="number">1</span>):</span><br><span class="line">    onex = numpy.c_[onex, X[:, <span class="number">0</span>] ** i]</span><br><span class="line"><span class="comment"># 拼接x2</span></span><br><span class="line">onex = numpy.c_[onex, X[:, <span class="number">1</span>]]</span><br><span class="line">m, n = onex.shape</span><br><span class="line">alpha, iter0 = <span class="number">0.1</span>, <span class="number">20000</span></span><br><span class="line">theta, J = numpy.zeros((n, <span class="number">1</span>)), numpy.zeros(iter0)</span><br><span class="line"><span class="comment"># 梯度下降</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iter0):</span><br><span class="line">   z = numpy.dot(onex, theta)  <span class="comment"># 公式一</span></span><br><span class="line">    h = <span class="number">1</span> / (<span class="number">1</span> + numpy.exp(-z))  <span class="comment"># 公式一</span></span><br><span class="line">    J[i] = (-<span class="number">1</span> / m) * numpy.<span class="built_in">sum</span>(y * numpy.log(h) + (<span class="number">1</span> - y) * numpy.log(<span class="number">1</span> - h))  <span class="comment"># 公式二</span></span><br><span class="line">    grad = (<span class="number">1</span> / m) * numpy.dot(onex.T, h - y)  <span class="comment"># 公式三</span></span><br><span class="line">    theta -= alpha * grad  <span class="comment"># 公式三</span></span><br><span class="line"><span class="built_in">print</span>(theta)</span><br><span class="line"><span class="built_in">print</span>(J)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="comment"># numpy.where:条件函数，判断h是不是大于0.5.</span></span><br><span class="line">    <span class="comment"># 如果是，则返回1，如果不是则返回0</span></span><br><span class="line">    <span class="keyword">if</span> (numpy.where(h[i] &gt;= <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0</span>) == y[i]):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">rate = count / m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分类准确率为&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(rate))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.plot(J)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line"><span class="comment"># 利用布尔型索引绘制散点图</span></span><br><span class="line">plt.scatter(X[y[:, <span class="number">0</span>] == <span class="number">1</span>, <span class="number">0</span>], X[y[:, <span class="number">0</span>] == <span class="number">1</span>, <span class="number">1</span>], c=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">plt.scatter(X[y[:, <span class="number">0</span>] == <span class="number">0</span>, <span class="number">0</span>], X[y[:, <span class="number">0</span>] == <span class="number">0</span>, <span class="number">1</span>], c=<span class="string">&#x27;g&#x27;</span>, marker=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制分割线</span></span><br><span class="line">x1 = numpy.sort(X[:, <span class="number">0</span>])</span><br><span class="line">x2 = numpy.zeros(<span class="built_in">len</span>(y))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d + <span class="number">1</span>):</span><br><span class="line">    x2 += theta[i] * (x1 ** i)</span><br><span class="line">x2 = -x2 / theta[-<span class="number">1</span>]</span><br><span class="line">plt.plot(x1, x2, c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分类评价指标</title>
      <link href="/2022/09/08/%E4%BA%8C%E5%88%86%E7%B1%BB%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
      <url>/2022/09/08/%E4%BA%8C%E5%88%86%E7%B1%BB%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h1>二分类评价指标</h1><p>评价指标是针对同样的数据，输入不同的算法，或者输入相同的算法但参数不同 而给出这个算法或者参数好坏的定量指标。</p><p>本文将问题看成二分类问题，因此本文主 要用到的评价指标有准确度、召回率、ROC 曲线以及 AUC 面积，这些是在二分类问 题比较常见的指标。</p><p><strong>混淆矩阵</strong>是 ROC 曲线绘制的基础，同时它也是衡量分类型模型 准确度中最基本、最直观、计算最简单的方法。以分类模型中的二分类为例，对于这 种问题，模型最终需要判断样本的结果是 0 还是 1，或者说是 Positive 还是 Negative。</p><p>因此，能得到这四个基础指标，可以看成是一级指标：</p><p>真实值是 Positive，模型认为 是 Positive 的数量(TP)。</p><p>真实值是 Positive，模型认为是 Negative 的数量(FN)。</p><p>真实值 是 Negative，模型认为是 Positive 的数量(FP)。</p><p>真实值是 Negative，模型认为是 Negative的数量(TN)。</p><p>将这四个指标一起呈现在表格中，就能得到如表 3 这样一个矩阵，称它 为<strong>混淆矩阵</strong>。预测性分类模型，是希望越准越好。在混淆矩阵中，TP 与 TN 的数量越 大越好，而 FP 与 FN 的数量越小越好。</p><h2 id="一、混淆矩阵">一、混淆矩阵</h2><p><img src="http://m.qpic.cn/psc?/V12XQ1QV3cpyPD/45NBuzDIW489QBoVep5mcZ2W2.kP5EuomFAVHtKzXCNvG.5Fg2QHu70oplOqCqWRBUmUdf5cb3HnE1wW54oXTKfi6OfdS8nOLb9tHYRyEU8!/b&amp;bo=qgU*AQAAAAADF6M!&amp;rf=viewer_4" alt="img"></p><h2 id="二、准确率，错误率，召回率">二、准确率，错误率，召回率</h2><p>准确率和错误率也是常用的评估指标，精确率是一个二分类指标，准确率能应用 于多分类。</p><p><img src="http://m.qpic.cn/psc?/V12XQ1QV3cpyPD/45NBuzDIW489QBoVep5mcR4xurrCi7UfqgyAMhZt3kUyNZ2mMTTpGYpYtmyBoVCrP5lYEBXmiRl5mY8Q1QsP2z0ZGAj2yo7E8YRHxKwGG.U!/b&amp;bo=LgRqAS4EagEDFzI!&amp;rf=viewer_4" alt="img"></p><p><strong>准确率</strong>指的是预测值为 1 且真实值也为 1 的样本在预测值为 1 的所有样本中所占 的比例。</p><p><strong>召回率</strong>指的是预测值为 1 且真实值也为 1 的样本在真实值为 1 的所有样本中 所占的比例。</p><h2 id="三、AUC值">三、AUC值</h2><p>AUC 是指 ROC 曲线下与坐标轴围成的面积，这个面积的数值小于等于 1。又因 为 ROC 曲线一般都处于 y=x 这条直线的上方，所以 AUC 的取值范围在 0.5 和 1 之间。 AUC 越接近 1.0，检测方法的实性越高；等于 0.5 时真实性最低，无应用价值。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>U</mi><mi>C</mi><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>P</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></munder><mfrac><mrow><mrow><mo fence="true">(</mo><mi>T</mi><mi>P</mi><msub><mi>R</mi><mi>i</mi></msub><mo>+</mo><mi>T</mi><mi>P</mi><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow><mo>×</mo><mrow><mo fence="true">(</mo><mi>F</mi><mi>P</mi><msub><mi>R</mi><mi>i</mi></msub><mo>−</mo><mi>F</mi><mi>P</mi><msub><mi>R</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo fence="true">)</mo></mrow></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">A U C=\sum_{i \in(P+N)} \frac{\left(T P R_{i}+T P R_{i-1}\right) \times\left(F P R_{i}-F P R_{i-1}\right)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.943em;vertical-align:-1.516em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.809em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">TP</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">TP</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">FP</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">FP</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 评价指标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境变量解析</title>
      <link href="/2022/09/08/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/09/08/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是环境变量">什么是环境变量</h2><p>主流的操作系统 Windows、Linux、MacOS 都有环境变量的概念。</p><p>打开 Windows 10 中的环境变量设置，如下图所示，<br>主流的操作系统 Windows、Linux、MacOS 都有环境变量的概念。</p><p>打开 Windows 10 中的环境变量设置，如下图所示，</p><p><img src="http://cdn1.python3.vip/imgs/api/tut_20200605092447_10.png" alt=""></p><p>这些环境变量本质上都是存储在 Windows 系统注册表里面的。</p><p><strong>环境变量</strong>可以理解为 影响 程序运行的一些 信息配置项 。英文叫 Environment Variables，下文中，有时我会简称 env</p><p>每个环境变量都是一个配置项，提供一个信息。</p><p>看到这些环境变量，很容易对环境变量产生误解，以为它们就是用来配置路径的。</p><p>不一定都是这样！</p><p>环境变量可以用来配置路径，也可以用来配置其他，比如上图中的 NUMBER_OF_PROCESSORS，指明了系统中处理器核心是4个。</p><h2 id="如何产生的">如何产生的</h2><p>一部分是由程序创建、修改 的，</p><p>一部分是由人手工创建的。</p><p>程序可以通过操作系统编程接口 增加、读取、删除、修改 环境变量配置。</p><p>人也可以通过命令或者操作界面 增加、查看、删除、修改 环境变量配置。</p><h2 id="有什么用？">有什么用？</h2><p>主要是为<strong>应用程序提供信息， 程序可以根据这些信息，决定它们的行为。</strong></p><p>因为某些程序会读取一些环境变量的值，根据这些值决定程序的处理。</p><p>举个例子，上文中的 NUMBER_OF_PROCESSORS，是操作系统程序创建的，目的就是提供信息给 系统中所有的程序， 告诉他们当前系统所在计算机的CPU核心是4个。</p><p>那么如果有一个程序需要给客户显示系统中有多少个CPU，就可以读取这个数据，显示在界面上。</p><p>更常见的，就是指明一些程序文件或者数据文件所在的目录。比如 path、ANDROID_HOME 。</p><p>从上面的描述，可以思考出这样一个结论：</p><p>到底哪些程序 会 受哪些环境变量的影响， 是由程序本身决定的。</p><p>程序的代码 到底会 读取哪些环境变量，根据这些值做出什么行为，完全是程序开发者设计决定的。</p><p>环境变量本身只是一些配置信息。</p><h2 id="path环境变量">path环境变量</h2><p>环境变量中，我们接触最密切的恐怕就是 path 这个环境变量了。</p><p>因为很多程序都会根据它的值 决定自己的行为。</p><p>最典型的就是 命令行解释器（运行在命令行窗口中的）， 有时也叫shell程序。</p><p>就是解释执行我们从 命令行窗口（术语是伪终端模拟器）输入命令的程序。</p><p>当我们在命令行窗口敲入如下一行指令的时候</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python.exe hyhy.py</span><br></pre></td></tr></table></figure><p>shell程序会接收到这行命令， 它会以空格作为分隔符，把指令分割为n个部分，第一个部分就是要执行的程序，后面的都是这个程序的参数。</p><p>那么第一个问题就是， 到哪里找这个程序 python.exe 呢？</p><p>这就是根据环境变量 path 的值决定的。</p><p>它会依次到环境变量 path 里面指定的目录下面， 一个个的找。</p><p>先在哪个目录下面找到了python.exe，就执行哪个目录下面的 python.exe。</p><p>不仅仅是 shell 要使用 环境变量 path， 很多其他程序也会使用，比如 Windows 操作系统寻找dll文件时，path里面指定的目录也是搜索路径之一。</p><p>看到这个例子，有些朋友可能又有误解了。</p><p>认为只要是配置目录的，都像 path 那样，可以配置好几个目录给程序依次查找。</p><p>不是的！！</p><p>还是那句话，怎么使用 环境变量 要看 各个程序本身的设计。</p><p>比如 环境变量 ANDROID_HOME， 就是只能包含一个目录的。</p><h2 id="修改环境变量配置">修改环境变量配置</h2><p>如果一个程序用到Windows 系统配置里面的环境变量， 当我们修改了 系统配置里面的环境变量，注意，一定要重启这个程序。</p><p>比如：cmd命令行解释器。</p><p>如果你修改了环境变量path，比如添加了一个目录，注意一定要重启cmd。</p><p>因为cmd启动后，就保留了一份自己的环境变量，这是再去修改 配置环境变量，不会影响已经启动的cmd程序。</p><p>如果要使修改生效，必须重启cmd程序。</p><h2 id="环境变量的继承">环境变量的继承</h2><p>我们再来看一个例子， 刚才我们说，程序重启后，系统配置里面的环境变量就会生效。</p><p>我们再通过一个程序来看一下。</p><p>大家在集成开发环境 Pycharm，先运行一下，下面的Python程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;环境变量 byhy ：<span class="subst">&#123;os.environ[<span class="string">&#x27;byhy&#x27;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以发现，程序会报 KeyError: ‘byhy’ 错误，因为我们并没有这样的一个环境变量。</p><p>现在，我们去修改 系统配置，添加这个环境变量。</p><p>然后，在 重新运行程序（就像重启一样），你会惊奇的发型，仍然会报错。</p><p>为什么？不是重启程序，修改后的环境变量就会生效吗？<br>其实，每个程序启动后（运行的程序叫做进程），就会自己拷贝 一份 父进程 环境变量表，作为该 进程 的环境变量表。</p><p>父进程 通俗的说 就是 启动了这个程序的 程序。</p><p>我们是在 Pycharm 里面运行 Python 程序， Pycharm 就是 Python 程序的父进程。</p><p>如果我们在 命令行cmd 中运行 Python 程序， 命令行cmd 就是 Python 程序的父进程。</p><p>那怎么解决这个问题呢？</p><p>连 Pycharm 也重新启动一下，这样 Pycharm 的 环境变量也更新了，它的子进程当然也会使用更新后的环境变量 就可以了。</p><p>那 pycharm 和 cmd 的父进程又是谁呢？ 是 Windows 桌面管理器 explorer 。</p><p>explorer启动时，会从注册表中读取 环境变量配置作为自己进程的环境变量。</p><p>后续用户启动的程序 大都是 直接 或者 间接的从 explorer继承的环境变量，当然也就使用了配置的环境变量。</p><p>前面的例子，我们重启 cmd窗口，可以有效的重新加载系统配置的环境变量，是因为 cmd窗口的父进程是 explorer。</p><p>explorer每次启动新的进程，会重新读取 配置环境变量， 作为子进程的环境变量。所以重启cmd就有效了。</p><p>但是 cmd 或者 pycharm 启动子进程， 并不会 重新读取 配置环境变量，而是把自己的环境变量作为 子进程的环境变量。 当然，修改的配置不会生效。</p><p>那么是不是 只有explorer 启动的子程序，才能使用最新的 配置环境变量呢？</p><p>也不是，要看程序的设计，完全可以启动子程序时，重新读取 系统配置里面的环境变量给子程序使用。</p><h4 id="案例">案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码文件 e1.py</span></span><br><span class="line"><span class="keyword">import</span> os,subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printEnv</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> os.environ.items():</span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>:<span class="subst">&#123;v&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;A1&#x27;</span>] = <span class="string">&#x27;白月黑羽1&#x27;</span></span><br><span class="line">printEnv(<span class="string">&#x27;e1.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subprocess.Popen(</span><br><span class="line">    [<span class="string">r&#x27;c:\Python37\python.exe&#x27;</span>,<span class="string">r&#x27;h:\tmp\e2.py&#x27;</span>],</span><br><span class="line">    shell=<span class="literal">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码文件 e2.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printEnv</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> os.environ.items():</span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>:<span class="subst">&#123;v&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;A2&#x27;</span>] = <span class="string">&#x27;白月黑羽2&#x27;</span></span><br><span class="line">printEnv(<span class="string">&#x27;e2.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行 <a href="http://e1.py">e1.py</a> 后， e1.py的代码会启动 <a href="http://e2.py">e2.py</a>。</p><p>所以程序运行时， <a href="http://e1.py">e1.py</a> 就是 <a href="http://e2.py">e2.py</a> 的父进程。</p><p>上面的程序运行后，可以发现 e2.py记录的 环境变量 是在 e1.py的基础上多一个 A2=白月黑羽2 。</p><p>可以证明：<strong>环境变量从父进程继承而来。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda配置虚拟环境</title>
      <link href="/2022/09/08/conda%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/09/08/conda%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="一、检验当前conda的版本">一、检验当前conda的版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure><h3 id="二、查看已经有的虚拟环境">二、查看已经有的虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list </span><br></pre></td></tr></table></figure><h3 id="三、创建虚拟环境和删除虚拟环境">三、创建虚拟环境和删除虚拟环境</h3><p>anaconda命令创建python版本为x.x，名字为env_name的虚拟环境。<br>env_name文件可以在Anaconda安装目录envs文件下找到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建</span></span><br><span class="line">conda create -n env_name python=x.x</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">conda remove -n env_name --all</span><br></pre></td></tr></table></figure><p>需要注意两点：</p><ol><li>=的前后不要有空格，否则命令无法被正常解析。</li><li>不输入python版本号，虚拟环境也能新建成功，但是没有python解释器，不能直接使用！</li></ol><h3 id="四、激活虚拟环境和关闭虚拟环境">四、激活虚拟环境和关闭虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活</span></span><br><span class="line">conda activate env_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><h3 id="五、对虚拟环境中安装和删除额外的包">五、对虚拟环境中安装和删除额外的包</h3><p>如果没有进入到当前虚拟环境，使用-n env_name 的方式去指定对某个虚拟环境安装软件，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定环境下已安装的package</span></span><br><span class="line">conda list -n env_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定环境下某个package</span></span><br><span class="line">conda install -n env_name [package]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定环境下某个package</span></span><br><span class="line">conda remove -n env_name [package]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新指定环境下某个package</span></span><br><span class="line">conda update -n env_name [package]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新conda，保持conda最新</span></span><br><span class="line">conda update conda</span><br></pre></td></tr></table></figure><h3 id="六、pycharm-中使用conda虚拟环境">六、pycharm 中使用conda虚拟环境</h3><h4 id="1-使用cmd查看新建的虚拟环境的目录：-conda-env-list">1.使用cmd查看新建的虚拟环境的目录：&gt; conda env list</h4><p>如图：我输入命令后，显示我有俩个三个虚拟环境，分别名叫spide1、tensorflow，root（root是必须有的，就是anaconda3安装路径）</p><p><img src="https://img-blog.csdnimg.cn/20200412155536911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDE3OTEy,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="2-打开pycharm，选择File-setting-Project-Project-Interperter，点击下图的Add按钮。">2.打开pycharm，选择File-&gt;setting-&gt;Project:****-&gt;Project Interperter，点击下图的Add按钮。</h4><p><img src="https://img-blog.csdnimg.cn/20200412160140649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDE3OTEy,size_16,color_FFFFFF,t_70" alt="img"></p><h4 id="3-选择conda-environment，点击existing-environment，选择你的conda环境，一定要选择到python-exe结尾。如我的Anaconda安装路径为：C-Users-Y-Anaconda3，我就选择我">3.选择conda environment，点击existing environment，选择你的conda环境，一定要选择到python.exe结尾。如我的Anaconda安装路径为：C:\Users\Y\Anaconda3，我就选择我</h4><p>创建的虚拟环境的路径为：C:\Users\Y\Anaconda3\envs\tensorflow\python.exe，其中tensorflow表示虚拟环境的名字。勾选“make available to all projects”，表示可以将这个环境使用到其他项目。</p><p><img src="https://img-blog.csdnimg.cn/20200412160425469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NDE3OTEy,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征工程介绍</title>
      <link href="/2022/09/08/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/09/08/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1>特征方程</h1><h2 id="1、特征方程是什么">1、特征方程是什么</h2><p>是对原始数据进行一系列工程处理，将其提炼为特征，作为输入供算法和模型使用。从本质上来讲，特征工程是一个表示和展现数据的过程。在实际工作中，特征工程旨在去除原始数据中的杂质和冗余，设计更高效的特征以刻画求解的问题与预测模型之间的关系</p><p><strong>对于一个机器学习问题，数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。</strong></p><p>通过总结和归纳，人们认为特征工程包括以下方面：</p><p><img src="https://pic3.zhimg.com/80/20e4522e6104ad71fc543cc21f402b36_1440w.jpg?source=1940ef5c" alt="img"></p><p><strong>特征处理</strong>是特征工程的核心部分，sklearn提供了较为完整的特征处理方法，包括数据预处理，特征选择，降维等。首次接触到sklearn，通常会被其丰富且方便的算法模型库吸引，但是这里介绍的特征处理库也十分强大！</p><h2 id="2、数据预处理">2、<strong>数据预处理</strong></h2><p>通过特征提取，我们能得到未经处理的特征，这时的特征可能有以下问题：</p><p>作者：城东<br>链接：<a href="https://www.zhihu.com/question/29316149/answer/110159647">https://www.zhihu.com/question/29316149/answer/110159647</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><ul><li>不属于同一量纲：即特征的规格不一样，不能够放在一起比较。无量纲化可以解决这一问题。</li><li>信息冗余：对于某些定量特征，其包含的有效信息为区间划分，例如学习成绩，假若只关心“及格”或不“及格”，那么需要将定量的考分，转换成“1”和“0”表示及格和未及格。二值化可以解决这一问题。</li><li>定性特征不能直接使用：某些机器学习算法和模型只能接受定量特征的输入，那么需要将定性特征转换为定量特征。最简单的方式是为每一种定性值指定一个定量值，但是这种方式过于灵活，增加了调参的工作。<a href="https://link.zhihu.com/?target=http%3A//www.ats.ucla.edu/stat/mult_pkg/faq/general/dummy.htm">通常使用哑编码的方式将定性特征转换为定量特征</a>：假设有N种定性值，则将这一个特征扩展为N种特征，当原始特征值为第i种定性值时，第i个扩展特征赋值为1，其他扩展特征赋值为0。哑编码的方式相比直接指定的方式，不用增加调参的工作，对于线性模型来说，使用哑编码后的特征可达到非线性的效果。</li><li>存在缺失值：缺失值需要补充。</li><li>信息利用率低：不同的机器学习算法和模型对数据中信息的利用是不同的，之前提到在线性模型中，使用对定性特征哑编码可以达到非线性的效果。类似地，对定量变量多项式化，或者进行其他的转换，都能达到非线性的效果。</li></ul><p>我们使用sklearn中的preproccessing库来进行数据预处理，可以覆盖以上问题的解决方案。</p><h3 id="2-1-无量纲化"><strong>2.1 无量纲化</strong></h3><p>无量纲化使不同规格的数据转换到同一规格。常见的无量纲化方法有标准化和区间缩放法。标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布。区间缩放法利用了边界值信息，将特征的取值区间缩放到某个特点的范围，例如[0, 1]等。</p><h4 id="2-1-1-标准化"><strong>2.1.1 标准化</strong></h4><p>标准化需要计算特征的均值和标准差，公式表达为：</p><p>使用preproccessing库的StandardScaler类对数据进行标准化的代码如下：</p><p><img src="https://pic1.zhimg.com/80/c7e852db6bd05b7bb1017b5425ffeec1_1440w.jpg?source=1940ef5c" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"> </span><br><span class="line"><span class="comment">#标准化，返回值为标准化后的数据</span></span><br><span class="line">StandardScaler().fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h4 id="2-1-2-区间缩放法"><strong>2.1.2 区间缩放法</strong></h4><p>区间缩放法的思路有多种，常见的一种为利用两个最值进行缩放，公式表达为：</p><p>使用preproccessing库的MinMaxScaler类对数据进行区间缩放的代码如下：</p><p><img src="https://pic1.zhimg.com/50/0f119a8e8f69509c5b95ef6a8a01a809_720w.jpg?source=1940ef5c" alt="img"></p><h4 id="2-1-3-标准化与归一化的区别"><strong>2.1.3 标准化与归一化的区别</strong></h4><p>**标准化(**StandardizationStandardization)：将数据变换为均值为0，标准差为1的分布切记，并非一定是正态的；</p><p><img src="https://img-blog.csdnimg.cn/20191021220535129.png#pic_center" alt="img"></p><p><strong>归一化</strong>(<em>N<strong>o</strong>r<strong>m</strong>a<strong>l</strong>i<strong>z</strong>a<strong>t</strong>i<strong>o</strong>n</em>)：将一列数据变化到某个固定区间(范围)中，通常，这个区间是[0, 1]，广义的讲，可以是各种区间，比如映射到[0，1]一样可以继续映射到其他范围，图像中可能会映射到[0,255]，其他情况可能映射到[-1,1]；</p><p><img src="https://img-blog.csdnimg.cn/20191021220509274.png#pic_center" alt="img"></p><p>使用preproccessing库的Normalizer类对数据进行归一化的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Normalizer</span><br><span class="line"></span><br><span class="line"><span class="comment">#归一化，返回值为归一化后的数据</span></span><br><span class="line">Normalizer().fit_transform(iris.data)</span><br></pre></td></tr></table></figure><p><strong>中心化</strong>：另外，还有一种处理叫做中心化，也叫零均值处理，就是将每个原始数据减去这些数据的均值。</p><h4 id="2-1-4-标准化，归一化的时机差别">2.1.4 标准化，归一化的时机差别</h4><p>如果你对处理后的数据范围有严格要求，那肯定是归一化，个人经验，标准化是ML中更通用的手段，如果你无从下手，可以直接使用标准化；如果数据不为稳定，存在极端的最大最小值，不要用归一化。在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，标准化表现更好；在不涉及距离度量、协方差计算的时候，可以使用归一化方法。</p><h3 id="2-2-对定量特征二值化"><strong>2.2 对定量特征二值化</strong></h3><p>定量特征二值化的核心在于设定一个阈值，大于阈值的赋值为1，小于等于阈值的赋值为0，公式表达如下：</p><p><img src="https://pic1.zhimg.com/50/11111244c5b69c1af6c034496a2591ad_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/11111244c5b69c1af6c034496a2591ad_1440w.jpg?source=1940ef5c" alt="img"></p><p>使用preproccessing库的Binarizer类对数据进行二值化的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Binarizer</span><br><span class="line"></span><br><span class="line"><span class="comment">#二值化，阈值设置为3，返回值为二值化后的数据</span></span><br><span class="line">Binarizer(threshold=<span class="number">3</span>).fit_transform(iris.data)</span><br></pre></td></tr></table></figure><h3 id="2-3-对定性特征哑编码"><strong>2.3 对定性特征哑编码</strong></h3><p>由于IRIS数据集的特征皆为定量特征，故使用其目标值进行哑编码（将离散定性数据转化为数字数据）。使用preproccessing库的OneHotEncoder类对数据进行哑编码的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line"><span class="comment">#哑编码，对IRIS数据集的目标值，返回值为哑编码后的数据</span></span><br><span class="line">OneHotEncoder().fit_transform(iris.target.reshape((-<span class="number">1</span>,<span class="number">1</span>)))</span><br></pre></td></tr></table></figure><p>哑变量编码直观的解释就是任意的将一个状态位去除。还是拿上面的例子来说，我们用4个状态位就足够反应上述5个类别的信息，也就是我们仅仅使用前四个状态位 [0,0,0,0] 就可以表达博士了。只是因为对于一个我们研究的样本，他已不是小学生、也不是中学生、也不是大学生、又不是研究生，那么我们就可以默认他是博士，是不是。（额，当然他现实生活也可能上幼儿园，但是我们统计的样本中他并不是，^-^）。所以，我们用哑变量编码可以将上述5类表示成：<br><img src="https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106151030778-484474659.png" alt="img" style="zoom:33%;" /></p><h4 id="2-3-1-独热编码one-hot-encoding">2.3.1 独热编码one-hot encoding</h4><p>one-hot的基本思想：将离散型特征的每一种取值都看成一种状态，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态，one-hot编码保证了每一个取值只会使得一种状态处于“激活态”，也就是说这N种状态中只有一个状态位值为1，其他状态位都是0。举个例子，假设我们以学历为例，我们想要研究的类别为小学、中学、大学、硕士、博士五种类别，我们使用one-hot对其编码就会得到：<br><img src="https://images2017.cnblogs.com/blog/1251096/201711/1251096-20171106143504638-2121612119.png" alt="img" style="zoom: 33%;" /></p><h3 id="2-4-缺失值计算"><strong>2.4 缺失值计算</strong></h3><p>由于IRIS数据集没有缺失值，故对数据集新增一个样本，4个特征均赋值为NaN，表示数据缺失。使用preproccessing库的Imputer类对数据进行缺失值计算的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> vstack, array, nan</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line"></span><br><span class="line"><span class="comment">#缺失值计算，返回值为计算缺失值后的数据</span></span><br><span class="line"><span class="comment">#参数missing_value为缺失值的表示形式，默认为NaN</span></span><br><span class="line"><span class="comment">#参数strategy为缺失值填充方式，默认为mean（均值）</span></span><br><span class="line">Imputer().fit_transform(vstack((array([nan, nan, nan, nan]), iris.data)))</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>missing_values ：指定何种占位符表示缺失值，可选 number ，string ，np.nan(default) ，None</li><li>strategy ：插补策略，字符串，默认&quot;mean&quot;<ul><li>“mean” ：使用每列的<strong>平均值</strong>替换缺失值，只能与数字数据一起使用</li><li>“median”：则使用每列的<strong>中位数</strong>替换缺失值，只能与数字数据一起使用</li><li>“most_frequent” ：则使用每列中<strong>最常用的值</strong>(众数)替换缺失值，可以与字符串或数字数据一起使用</li><li>“constant” ：则用 fill_value 替换缺失值。可以与字符串或数字数据一起使用</li></ul></li></ul><p>友情链接：</p><p><a href="https://www.zhihu.com/question/29316149/answer/110159647">知乎原文</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各类激活函数</title>
      <link href="/2022/09/08/%E5%90%84%E7%B1%BB%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/08/%E5%90%84%E7%B1%BB%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>激活函数</h1><h2 id="为什么要使用激活函数？">为什么要使用激活函数？</h2><p>激活函数用来怎加非线性因素的，提高模型拟合能力。如果不存在激活函数，神经网络的每一层的输入都是对前面输入的线性变化，就算把网络加到很深也无法去拟合任意函数的。</p><h2 id="激活函数具有的特性">激活函数具有的特性</h2><p>虽然我们常用激活函数不是很多，那是否只有这些函数能作为激活函数呢？我们从神经网络的工作过程中看，激活函数具有什么样的性质能够更好的帮助神经网络的训练。</p><ul><li>非线性：数，激活函数必须是非线性的。</li><li>计算简单：神经元都要经过激活运算的，在随着网络结构越来越庞大、参数量越来越多，激活函数如果计算量小就节约了大量的资源。</li><li>f ( x ) ≈ x:在向前传播时，如果参数的初始化是随机量的最小值，神经网络的训练很高效。在训练的时候不会出现输出的幅度随着不断训练发生倍数的增长，是网络更加的稳定，同时也使得梯度更容易回传。</li><li>可微：因为神经网络要通过反向传播来跟新参数，如果激活函数不可微，就无法根据损失函数对权重求偏导，也就无法更新权重。传统的激活函数如sigmoid等满足处处可微。对于分段线性函数比如ReLU，只满足几乎处处可微（即仅在有限个点处不可微）。对于SGD算法来说，由于几乎不可能收敛到梯度接近零的位置，有限的不可微点对于优化结果不会有很大影响。</li><li>非饱和性：（饱和函数有Sigmoid、Tanh等，非饱和函数ReLU等）例如Sigmoid函数求导以后的值很小，两端的值接近为零在反向传播的时候，如果网络的层次过大便会发生梯度消失的问题，使得浅层的参数无法更新。（梯度消失后面会介绍）</li><li>单调性：当激活函数单调时，单层网络保证是凸函数。</li><li>输出值的范围： 当激活函数输出值是有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著；当激活函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况小，一般需要更小的Learning Rate。</li></ul><h1>sigmoid</h1><p>sigmoid函数，也就是s型曲线函数，如下：</p><img src="http://r.photo.store.qq.com/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/45NBuzDIW489QBoVep5mcf*48pd3sw1EG6ASFdDywaGGCr4lxdd5LhJ4BRqpK06sV0ipiHOzf97Pdrhqvqvj5D6MUjEuN03e2lZZ5vA8.2g!/r" style="zoom: 50%;" /><p><strong>原函数图像：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190828171615342.jpg#pic_center" alt="img"></p><p><strong>函数性质</strong></p><ul><li>非线性函数</li><li>求导简单，函数求导后为<em>f</em>′(<em>x</em>)=<em>f</em>(<em>x</em>)(1−<em>f</em>(<em>x</em>))</li><li>不满足f ( x ) ≈ x</li><li>在定义域内处处可导</li><li><strong>饱和激活函数</strong></li><li>函数为单调函数</li><li>函数的输出区间在（0，1）之间，函数定义域为负无穷到正无穷</li></ul><p><strong>倒数及其导数图像</strong>：</p><p><img src="https://img-blog.csdnimg.cn/20190828174210519.jpg#pic_center" alt="img"></p><p><strong>优点和缺点</strong></p><ul><li>优点：平滑、容易求导</li><li>缺点：<ul><li>激活函数运算量大（包含幂的运算）</li><li>函数输出不关于原点对称，使得权重更新效率变低，同时这会导致后一层的神经元将得到上一层输出的非0均值的信号作为输入，随着网络的加深，会改变数据的原始分布</li><li>由图像知道导数的取值范围[0,0.25]，非常的小。在进行反向传播计算的时候就会乘上一个很小的值，如果网络层次过深，就会发生“梯度消失”的现象了，无法更新浅层网络的参数了。</li></ul></li></ul><h2 id="hard-sigmoid">hard sigmoid</h2><p><strong>函数公式：</strong></p><p><img src="https://img-blog.csdnimg.cn/20191106153422324.png#pic_center" alt="img"></p><p>解释：当 x &lt; -2.5输出<strong>0</strong>，当 x &gt; 2.5时，输出<strong>1</strong>，当 -2.5 &lt; x &amp; x &lt; 2.5时，输出为 <strong>(2x+5) / 10</strong>，线性函数。<br>那么其导数，当 x &lt; -2.5输出<strong>0</strong>，当 x &gt; 2.5时，输出<strong>0</strong>，当 -2.5 &lt; x &amp; x &lt; 2.5时，输出为 <strong>1 / 5</strong>。</p><p><strong>hard-Sigmoid</strong>函数时<strong>Sigmoid</strong>激活函数的分段线性近似。从公示和曲线上来看，其更易计算，因此会提高训练的效率，不过同时会导致一个问题：就是首次派生值为零可能会导致神经元died或者过慢的学习率。</p><p><strong>函数图像：</strong></p><img src="https://img-blog.csdnimg.cn/20191106153649526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><h2 id="Tanh-双曲正切函数-激活函数">Tanh(双曲正切函数)激活函数</h2><p><strong>函数图像：</strong></p><img src="https://img-blog.csdnimg.cn/20190828191851823.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25lb19sY3g=,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p><strong>函数公式：</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>=</mo><mfrac><mrow><mo fence="true">(</mo><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup><mo fence="true">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">f\left( x\right) =\dfrac{\left( e^{x}-e^{-x}\right) }{\left( e^{x}+e^{-x}\right) }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.3843em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4483em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6973em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>导数公式</strong>:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>=</mo><mn>1</mn><mo>−</mo><msup><mrow><mo fence="true">(</mo><mi>f</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f\left( x\right) =1-\left( f\left( x\right) \right) ^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.204em;vertical-align:-0.25em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>倒数图像：</strong></p><img src="https://img-blog.csdnimg.cn/20190828192827207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25lb19sY3g=,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p><strong>函数性质</strong></p><ul><li>非线性函数</li><li>求导简单</li><li>不满足f ( x ) ≈ x</li><li><strong>饱和激活函数</strong></li><li>函数为单调函数</li><li>函数的输出区间在（-1，1）之间，函数定义域为负无穷到正无穷</li></ul><p><strong>优点与缺点：</strong></p><ul><li>优点：<ul><li>解决了Sigmoid的输出不关于零点对称的问题</li><li>也具有Sigmoid的优点平滑，容易求导</li></ul></li><li>缺点：<ul><li>激活函数运算量大（包含幂的运算）</li><li>Tanh的导数图像虽然最大之变大，使得梯度消失的问题得到一定的缓解，但是不能根本解决这个问题</li></ul></li></ul><h2 id="ReLU激活函数">ReLU激活函数</h2><p>ReLU函数代表的的是“修正线性单元”，它是带有卷积图像的输入x的最大函数(x,o)。ReLU函数将矩阵x内所有负值都设为零，其余的值不变</p><p><strong>函数公式：</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f\left( x\right) =\max \left( 0,x\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p><strong>函数图像：</strong></p><img src="https://img-blog.csdnimg.cn/20190828195811214.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25lb19sY3g=,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p><strong>激活函数的性质：</strong></p><ul><li>非线性函数（虽然单侧是线性函数）</li><li>计算简单是真的简单(不管是在神经网络向前计算过程中还是反向传播的时候)</li><li>右侧满足f ( x ) ≈ x {\rm{f}}(x) \approx xf(x)≈x</li><li>右侧为单调函数</li><li>输出为（0，+无穷）</li></ul><p><strong>优点和缺点：</strong></p><ul><li><p>优点</p><ul><li><p>计算量小，相对于之前使用sigmoid和Tanh激活函数需要进行指数运算，使用ReLu的计算量小很多，在使用反向传播计算的时候也要收敛更更快。</p></li><li><p>缓解了在深层网络中使用sigmoid和Tanh激活函数造成了梯度消失的现象（右侧导数恒为1）</p></li><li><p>缓解过拟合的问题。由于函数的会使小于零的值变成零，使得一部分神经元的输出为0，造成网络的稀疏</p><p>性，减少参数相互依赖的关系缓解过拟合的问题（<a href="https://www.zhihu.com/question/29021768/answer/43488153">请问人工神经网络中的activation function的作用具体是什么？为什么ReLu要好过于tanh和sigmoid function?</a>）</p></li></ul></li><li><p>缺点</p><ul><li>造成神经元的“死亡”（详细的介绍见连接<a href="https://www.zhihu.com/question/67151971/answer/434079498">深度学习中，使用relu存在梯度过大导致神经元“死亡”，怎么理解？</a>）</li></ul><p>解决方法：优化函数，采用较小学习速率，采用momentum based 优化算法</p><ul><li>ReLU的输出不是0均值的</li></ul></li></ul><h2 id="Leaky-ReLU-变种激活函数">Leaky ReLU 变种激活函数</h2><p><strong>函数公式：</strong></p><p>f ( x ) = max ⁡ ( α x , x )</p><p><strong>函数图像：</strong></p><img src="https://img-blog.csdnimg.cn/2019083013484538.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25lb19sY3g=,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p>函数图像跟之前的ReLu图像很像，同样的PReLU和ELU激活函数也是在ReLu的基础上针对ReLU在训练时神经元容易死亡做出了优化，基本的思路就是让函数小于0的部分不直接为0，而是等于一个很小的数，使得负轴的信息不至于完全丢弃。</p><h2 id="softmax">softmax</h2><p>softmax函数，又称**归一化指数函数。**它是二分类函数sigmoid在多分类上的推广，目的是将多分类的结果以概率的形式展现出来。</p><img src="https://img-blog.csdnimg.cn/20181128162309759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X3BldGVy,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" /><p>下面为大家解释一下为什么softmax是这种形式。</p><p>首先，我们知道概率有两个性质：1）预测的概率为非负数；2）各种预测结果概率之和等于1。</p><p>softmax就是将在负无穷到正无穷上的预测结果按照这两步转换为概率的。</p><p><strong>1）将预测结果转化为非负数</strong></p><p>下图为y=exp(x）的图像，我们可以知道<strong>指数函数</strong>的值域取值范围是零到正无穷。<strong>softmax第一步就是将模型的预测结果转化到指数函数上，这样保证了概率的非负性。</strong></p><img src="https://img-blog.csdnimg.cn/2019111910482712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X3BldGVy,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" /><p>2）各种预测结果概率之和等于1</p><p>为了确保各个预测结果的概率之和等于1。我们只需要将转换后的结果进行归一化处理。方法就是将转化后的结果除以所有转化后结果之和，可以理解为转化后结果占总数的百分比。这样就得到近似的概率。</p><p>下面为大家举一个例子，假如模型对一个三分类问题的预测结果为-3、1.5、2.7。我们要用softmax将模型结果转为概率。步骤如下：</p><p>1）将预测结果转化为非负数</p><p>y1 = exp(x1) = exp(-3) = 0.05</p><p>y2 = exp(x2) = exp(1.5) = 4.48</p><p>y3 = exp(x3) = exp(2.7) = 14.88</p><p>2）各种预测结果概率之和等于1</p><p>z1 = y1/(y1+y2+y3) = 0.05/(0.05+4.48+14.88) = 0.0026</p><p>z2 = y2/(y1+y2+y3) = 4.48/(0.05+4.48+14.88) = 0.2308</p><p>z3 = y3/(y1+y2+y3) = 14.88/(0.05+4.48+14.88) = 0.7666</p><p>总结一下softmax如何将多分类输出转换为概率，可以分为两步：</p><p><strong>1）分子：通过指数函数，将实数输出映射到零到正无穷。</strong></p><p><strong>2）分母：将所有结果相加，进行归一化。</strong></p><img src="https://img-blog.csdnimg.cn/20181212223827495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6X3BldGVy,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%;" /><h2 id="SELU（可伸缩的指数线性单元）">SELU（可伸缩的指数线性单元）</h2><p>SELU Scaled Exponential Linear Unit等同于：<code>scale * elu(x, alpha)</code>，其中 alpha 和 scale 是预定义的常量。只要正确初始化权重（参见 <code>lecun_normal</code> 初始化方法）并且输入的数量「足够大」（参见参考文献获得更多信息），选择合适的 alpha 和 scale 的值，就可以在两个连续层之间保留输入的均值和方差。</p><p>函数形式：</p><p><img src="https://ftp.bmp.ovh/imgs/2021/07/510ee62a38ceee09.png" alt=""></p><p>深度学习在卷积神经网络和循环神经网络取得很大突破，但标准前馈网络的成功消息却很少。因此引入自归一化的神经网络，来尝试进行高级抽象表示。<br>这种自归一化的神经网络的激活函数就是selu，它也是一种基于激活函数的正则化方案。它具有自归一化特点，即使加入噪声也能收敛到均值为0、方差为1或方差具有上下界。<br>优点：在全连接层效果好，可以避免梯度消失和爆炸。<br>缺点：在卷积网络效果尚未证明。可能引起过拟合。</p><h2 id="ELU（指数线性单元）">ELU（指数线性单元）</h2><p>其将激活函数的平均值接近零，从而加快学习的速度。同时，还可以通过正值的标识来避免梯度消失的问题。根据一些研究，ELU的分类 精确度要高于Relu。</p><p><strong>函数公式：</strong></p><img src="https://img-blog.csdnimg.cn/20191030135243499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p><strong>函数图像：</strong></p><img src="https://img-blog.csdnimg.cn/20191030140332643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><ul><li>融合了sigmoid和ReLU，左侧具有软饱和性，右侧无饱和性。</li><li>右侧线性部分使得ELU能够缓解梯度消失，而左侧软饱能够让ELU对输入变化或噪声更鲁棒。</li><li>ELU的输出均值接近于零，所以收敛速度更快。</li><li>在 ImageNet上，不加 Batch Normalization 30 层以上的 ReLU<br>网络会无法收敛，PReLU网络在MSRA的Fan-in （caffe ）初始化下会发散，而 ELU<br>网络在Fan-in/Fan-out下都能收敛。</li></ul><h2 id="SELU（给ELU乘个系数）">SELU（给ELU乘个系数）</h2><p><strong>函数公式：</strong></p><img src="https://img-blog.csdnimg.cn/20191030142451758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p><strong>函数图像：</strong></p><p>lambda为系数</p><img src="https://img-blog.csdnimg.cn/20191030153053550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:33%;" /><h2 id="P-Relu（参数化修正线性单元）">P-Relu（参数化修正线性单元）</h2><p>可以看作是Leaky ReLU的一个变体，不同的是，P-ReLU中的负值部分的斜率是根据数据来定的，即a的值并不是一个常数。</p><h2 id="R-Relu（随机纠正线性单元）">R-Relu（随机纠正线性单元）</h2><p>R-ReLU也是Leaky ReLU的一个变体，只不过在这里负值部分的斜率在训练的时候是随机的，即在一个范围内随机抽取a的值，不过这个值在测试环节会固定下来。</p><h2 id="Swish">Swish</h2><p><strong>函数公式：</strong></p><img src="https://img-blog.csdnimg.cn/20191030142614595.png#pic_center" alt="img" style="zoom:50%;" /><p><strong>导数公式：</strong></p><img src="https://img-blog.csdnimg.cn/20191030151728500.png#pic_center" alt="img" style="zoom:50%;" /><p><strong>函数图像：</strong></p><img src="https://img-blog.csdnimg.cn/2019103014450670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p><strong>导数图像：</strong></p><img src="https://img-blog.csdnimg.cn/20191030151508307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p>当β = 0时,Swish变为线性函数f(x)=x2f(x)=x2.<br>β → ∞, σ(x)=(1+exp(−x))−1σ(x)=(1+exp⁡(−x))−1为0或1. Swish变为ReLU: f(x)=2max(0,x)<br>所以Swish函数可以看做是介于线性函数与ReLU函数之间的平滑函数.</p><h2 id="Mish">Mish</h2><p><strong>函数公式</strong></p><img src="https://img-blog.csdnimg.cn/20191101121536815.png#pic_center" alt="img" style="zoom:50%;" /><p><strong>公式推导：</strong></p><p><img src="https://img-blog.csdnimg.cn/20191101121647443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p><p>Mish和Swish中参数=1的曲线对比：（第一张是原始函数，第二张是导数）</p><img src="https://img-blog.csdnimg.cn/20191101121931980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20191101121949780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><p><strong>优点</strong></p><p>以上无边界(即正值可以达到任何高度)避免了由于封顶而导致的饱和。理论上对负值的轻微允许允许更好的梯度流，而不是像ReLU中那样的硬零边界。</p><p>最后，可能也是最重要的，目前的想法是，平滑的激活函数允许更好的信息深入神经网络，从而得到更好的准确性和泛化。</p><p>要区别可能是Mish函数在曲线上几乎所有点上的平滑度</p><h2 id="Maxout">Maxout</h2><p>与常规的激活函数不同，Maxout是一个可以学习的分段线性函数。<br>其可以看做是在深度学习网络中加入了一层激活函数层，包含一个参数k，这一层相比ReLU，Sigmoid等，其在于增加了k个神经元，然后输出激活值最大的值。<br>其需要学习的参数就是k个神经元中的权值和偏置，这就相当于常规的激活函数一层，而Maxout是两层，而且参数个数增加了K倍。<br>其可以有效的原理是，任何ReLU及其变体等激活函数都可以看成分段的线性函数，而Maxout加入的一层神经元正是一个可以学习参数的分段线性函数。</p><p><strong>优点</strong>：其拟合能力很强，理论上可以拟合任意的凸函数；<br>具有ReLU的所有优点，线性和非饱和性；<br>同时没有ReLU的一些缺点，如神经元的死亡；<br><strong>缺点</strong>：导致整体参数的激增。</p><p>网络图片：</p><img src="https://img-blog.csdnimg.cn/20191030153907257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /><h2 id="关于激活函数统一说明">关于激活函数统一说明</h2><p>ELU在正半轴取输入x奸情了梯度弥散情况（正半轴导数处处为1），而这一点特性，基本上除了swish其他非饱和激活函数都具有这个特性。而只有ReLU在负半轴的输出没有复制，所以ReLU的输出均值一定是大于0的，而当激活值的均值非0时，会对下一层造成以bias，也就是下一层的激活单元会出现bias shift现象，通过不断的层数叠加，bias shift会变得非常大。而ELU可以让激活函数的输出均值尽可能接近0，类似于BN操作，但是计算复杂度更低。而且虽然Leaky ReLU和PReLU等都有负值，但是它们不保证在不激活的状态对噪声鲁棒，这里的不激活指的是负半轴。而ELU在输入取较小值时具有软饱和的特性，提升了对噪声的鲁棒性。Swish和ELU都是可以取负值，同时在负半轴具有软饱和的性能，提高了对噪声的鲁棒性，SELU效果比ELU效果还要更好。</p><p><img src="https://img-blog.csdnimg.cn/20191030152606832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pza19sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激活函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各类损失函数</title>
      <link href="/2022/09/08/%E5%90%84%E7%B1%BB%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/08/%E5%90%84%E7%B1%BB%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>损失函数</h1><p><strong>损失函数</strong>loss function）是用来<strong>估量模型的预测值f(x)与真实值Y的不一致程度</strong>，它是一个非负实值函数,通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。损失函数是<strong>经验风险函数</strong>的核心部分，也是<strong>结构风险函数</strong>重要组成部分。模型的结构风险函数包括了经验风险项和正则项，通常可以表示成如下式子：</p><p><img src="https://img-blog.csdnimg.cn/20210213230218627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><h1>损失函数、代价函数、目标函数之间的关系</h1><p><img src="https://img-blog.csdnimg.cn/20210213230545604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><h1>常见的损失函数</h1><h2 id="均方差-Mean-Squared-Error，MSE">均方差(Mean Squared Error，MSE)</h2><p>均方差（Mean Squared Error，MSE）损失是机器学习、深度学习回归任务中最常用的一种损失函数，也称为 L2 Loss。其基本形式如下：</p><p><img src="https://img-blog.csdnimg.cn/20210214151903438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><p>可以看到这个实际上就是均方差损失的形式。也就是说在模型输出与真实值的误差服从高斯分布的假设下，最小化均方差损失函数与极大似然估计本质上是一致的，因此在这个假设能被满足的场景中（比如回归），均方差损失是一个很好的损失函数选择；当这个假设没能被满足的场景中（比如分类），均方差损失不是一个好的选择</p><h2 id="平均绝对误差损失（Mean-Absolute-Error-Loss-MAE">平均绝对误差损失（Mean Absolute Error Loss,MAE)</h2><p>平均绝对误差（Mean Absolute Error Loss，MAE）是另一类常用的损失函数，也称为L1 Loss。其基本形式如下：</p><p><img src="https://img-blog.csdnimg.cn/20210214152318230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>MAE与MSE的区别：</strong></p><ul><li>MSE比MAE能够更快收敛：当使用梯度下降算法时，MSE损失的梯度为<img src="https://img-blog.csdnimg.cn/20210214154406320.png" alt="img" style="zoom:50%;" />，而MAE损失的梯度为正负1。所以。MSE的梯度会随着误差大小发生变化，而MAE的梯度一直保持为1，这不利于模型的训练。</li><li>MAE对异常点更加鲁棒：从损失函数上看，MSE对误差平方化，使得异常点的误差过大；从两个损失函数的假设上看，MSE假设了误差服从高斯分布，MAE假设了误差服从拉普拉斯分布，拉普拉斯分布本身对于异常点更加鲁棒</li></ul><h4 id="拉普拉斯分布">拉普拉斯分布</h4><p>Laplace分布是统计学中的概念，是一种连续的概率分布。如果随机变量的概率密度函数分布为：</p><p><img src="https://www.zhihu.com/equation?tex=f%28x%7C%5Cmu%2Cb%29%3D%5Cfrac%7B1%7D%7B2b%7D%5Cexp+%28-%5Cfrac%7B%7Cx-%5Cmu%7C%7D%7Bb%7D%29%3D%5Cfrac%7B1%7D%7B2b%7D%5Cbegin%7Bcases%7D+%5Cexp%28-+%5Cfrac%7B%5Cmu-x%7D%7Bb%7D%29+%26+x+%3C+%5Cmu+%5C%5C+%5Cexp%28-+%5Cfrac%7Bx-%5Cmu%7D%7Bb%7D%29+%26+x+%5Cge+%5Cmu+%5Cend%7Bcases%7D%5C%5C" alt=""></p><p>么它就是拉普拉斯分布。其中，<img src="https://www.zhihu.com/equation?tex=%5Cmu" alt=""> 是位置参数，<img src="https://www.zhihu.com/equation?tex=b%3E0" alt="">是尺度参数。画出来就是长这样：</p><img src="https://pic2.zhimg.com/80/v2-cfc09f0381e99b9866fcfd856b2df531_720w.jpg" style="zoom:50%;" /><h4 id="高斯分布">高斯分布</h4><p>高斯分布（正态分布）是一个常见的连续概率分布。正态分布的数学期望值或期望值等于位置参数，决定了分布的位置；其方差的开平方或标准差 等于尺度参数，决定了分布的幅度。正态分布的概率密度函数曲线呈钟形，因此人们又经常称之为钟形曲线（类似于寺庙里的大钟，因此得名）。我们通常所说的标准正态分布是位置参数μ = 0 ，方差σ^2 = 1 的正态分布。</p><img src="https://img-blog.csdnimg.cn/20200301225748575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbmdoYW5nXw==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><p><img src="https://ftp.bmp.ovh/imgs/2021/07/540978ddb2d0bfd5.png" alt=""></p><h2 id="平均绝对误差百分比-Mean-Absolute-Percentage-ErrorAPE-MAPE">平均绝对误差百分比(Mean Absolute Percentage ErrorAPE,MAPE)</h2><p>**MAPE(Mean Absolute Percentage Error)平均绝对误差百分比：**是用来做销量预测最常用的指标，在实际的线上线下销量预测中有着非常重要的评估意义。但是在实际的项目过程中发现，有些时候的指标并不能非常好的表示模型拟合的效果，因此对这部分进行了深入分析，发现有更优化的评价指标来度量销量预测问题。</p><p>MAPE公式如下：</p><p><img src="https://private.codecogs.com/gif.latex?MAPE%3D%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bn%7D%5E%7B1%7D%5Cfrac%7B%7C%7By%7D%27-y%7C%7D%7By%7D" alt="img"></p><p><img src="https://private.codecogs.com/gif.latex?y" alt="y">, <img src="https://private.codecogs.com/gif.latex?%7By%7D%27" alt="{y}'">分别为真实值和预测值。</p><h2 id="平均平方log误差-Mean-Squared-Logarithmic-Error-MSLE">平均平方log误差(Mean Squared Logarithmic Error, <em>MSLE</em>)</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msubsup><mi>y</mi><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msubsup><mi>y</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L= \frac {1}{n} \sum^n_{i=1} (log(y_{true}^{(i)} +1) - log( y_{pred}^{(i)}+1))^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4542em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">e</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2458em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.4822em;vertical-align:-0.4374em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.3987em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">re</span><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4374em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msle相比与mse的改进:如果想要预测的值范围很大,mse会受到一些大的值的引导,即使小的值预测准也不行.假设如:</span><br><span class="line">y_true:[1,2,3,100]</span><br><span class="line">y_1:[1,2,3,110]</span><br><span class="line">y_2:[2,3,4,100]</span><br><span class="line">mse计算结果(y_1:100,y_2:3)会认为y_2优于y_1.</span><br><span class="line">msle计算结果(有_1:0.047,0.27)通过预先将所有值取log缓解了这一情况,会认为y_1优于y_2.这比较合理.</span><br></pre></td></tr></table></figure><p>当目标实现指数增长时，例如人口数量、一种商品在几年时间内的平均销量等，这个指标最适合使用。请注意，这个指标惩罚的是一个被低估的估计大于被高估的估计。</p><h2 id="Huber-Loss">Huber Loss</h2><p>Huber Loss是一种将MSE与MAE结合起来，取两者优点的损失函数，也被称作Smooth Mean Absolute Error Loss 。其原理很简单，就是在误差接近0时使用MSE，误差较大时使用MAE，公式为：</p><img src="https://img-blog.csdnimg.cn/20210214153331543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" /><p>在 <img src="https://img-blog.csdnimg.cn/20210214153414616.png" alt="img" style="zoom: 33%;" />内实际上就是MSE的损失，使损失函数可导并且梯度更加稳定；在<img src="https://img-blog.csdnimg.cn/20210214153425597.png" alt="img" style="zoom:33%;" />和<img src="https://img-blog.csdnimg.cn/20210214153433361.png" alt="img" style="zoom:33%;" />区间内为MAE损失，降低了异常点的影响，使训练更加鲁棒。</p><h2 id="回归损失函数：Log-Cosh-Loss">回归损失函数：Log-Cosh Loss</h2><p>Log-Cosh是应用于回归任务中的另一种损失函数，它比L2损失更平滑。Log-cosh是预测误差的双曲余弦的对数。</p><p><img src="https://img-blog.csdnimg.cn/20190507161816893.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190507161857100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4NDExOTY=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>优点：</strong><br>对于较小的X值，log(cosh(x))约等于(x ** 2) / 2；对于较大的X值，则约等于abs(x) - log(2)。这意味着Log-cosh很大程度上工作原理和平均方误差很像，但偶尔出现错的离谱的预测时对它影响又不是很大。它具备了Huber损失函数的所有优点，但不像Huber损失，它在所有地方都二次可微。<br>但Log-cosh也不是完美无缺。如果始终出现非常大的偏离目标的预测值时，它就会遭受梯度问题。</p><p><strong>Log-cosh损失函数的Python代码:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># log cosh 损失</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logcosh</span>(<span class="params">true, pred</span>):</span><br><span class="line">    loss = np.log(np.cosh(pred - true))<span class="keyword">return</span> np.<span class="built_in">sum</span>(loss)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中位数绝对误差-Median-absolute-error-MAE）">中位数绝对误差(Median absolute error,MAE）</h2><p>中位数绝对误差适用于包含异常值的数据的衡量。先计算出数据与它们的中位数之间的残差（偏差），MedAE就是这些偏差的绝对值的中位数。</p><p><img src="https://private.codecogs.com/gif.latex?MedAE%3D%20median%20%28%7CYi%20-%20Yi%20predict%7C%29%20i%3D0.1.2.....n" alt="img"></p><p>绝对中位差,一种统计离差的测量。而且，是一种鲁棒统计量，比标准差更能适应数据集中的异常值。对于标准差，使用的是数据到均值的距离平方，所以大的偏差权重更大，异常值对结果也会产生重要影响。对于绝对中位差，少量的异常值不会影响最终的结果。</p><p>由于绝对中位差是一个比样本方差或者标准差更鲁棒的度量，它对于不存在均值或者方差的分布效果更好，比如柯西分布。</p><h2 id="explained-variance-score-解释方差分"><strong>explained_variance_score(解释方差分)</strong></h2><p>解释回归模型的方差得分，这个指标用来衡量我们模型对数据集波动的解释程度，其值取值范围是[0,1]，越接近于1说明自变量越能解释因变量的方差变化，值越小说明效果越差。</p><p><img src="https://img-blog.csdnimg.cn/20190714231102416.png" alt="img"></p><h2 id="分位数损失（Quantile-Loss）">分位数损失（Quantile Loss）</h2><p>分位数回归Quantile Regression是一类在实际应用中非常有用的回归算法，通常的回归算法是拟合目标值的<strong>期望（MSE）或者中位数（MAE）</strong>，而分位数回归可以通过给定不同的分位点，拟合目标值的不同分位数。</p><img src="https://img-blog.csdnimg.cn/20210214153743301.png" alt="img" style="zoom:50%;" /><p>式中的r为分位数，这个损失函数是一个分段的函数，当r&gt;0.5时，低估()的损失要比高估的损失更大；反之，当r&lt;0.5 时，高估的损失要比低估的损失更大，分位数损失实现了分别用不同的系数控制高估和低估的损失，进而实现分位数回归。特别地，当r=0.5时，分位数损失退化为MAE损失，从这里可以看出 MAE 损失实际上是分位数损失的一个特例—中位数回归。</p><img src="https://img-blog.csdnimg.cn/20210214154259628.png" alt="img" style="zoom:50%;" /><h1>分类常用的损失函数</h1><h2 id="0-1损失函数-zero-one-loss"><strong>0-1损失函数(zero-one loss)</strong></h2><p><img src="https://img-blog.csdnimg.cn/20210214155126120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="log对数损失函数"><strong>log对数损失函数</strong></h2><p><img src="https://img-blog.csdnimg.cn/20210214155225513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="指数损失函数（exponential-loss）"><strong>指数损失函数（exponential loss）</strong></h2><p><img src="https://img-blog.csdnimg.cn/20210214155359325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="hinge损失函数"><strong>hinge损失函数</strong></h2><p>支持向量机Support Vector Machine (SVM)模型的损失函数本质上就是Hinge Loss + L2正则化。</p><p><img src="https://img-blog.csdnimg.cn/20210214155550537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="交叉熵损失函数-Cross-entropy-loss-function"><strong>交叉熵损失函数 (Cross-entropy loss function)</strong></h2><p><img src="https://img-blog.csdnimg.cn/20210214160234906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><h3 id="多分类问题的交叉熵损失函数"><strong>多分类问题的交叉熵损失函数</strong></h3><p><img src="https://img-blog.csdnimg.cn/20210214160822703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwNjk1NTI=,size_16,color_FFFFFF,t_70" alt="img"></p><img src="https://pic3.zhimg.com/v2-75a934ce9c4310b16ff1a2e852c147e8_1440w.jpg?source=172ae18b" alt="img" style="zoom: 33%;" /><h2 id="相对熵">相对熵</h2><p>KL距离全称为Kullback-Leibler Divergence，也被称为相对熵。公式为：</p><img src="https://img-blog.csdn.net/20161018155350970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom: 67%;" /><p>感性的理解，KL距离可以解释为在相同的事件空间P(x)中两个概率P(x)和Q(x)分布的差异情况。</p><p>从其物理意义上分析：可解释为在相同事件空间里，概率分布P(x)的事件空间，若用概率分布Q（x）编码时，平均每个基本事件（符号）编码长度增加了多少比特。</p><img src="https://img-blog.csdn.net/20161018155413159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:67%;" /><p>如上面展开公式所示，前面一项是在P(x)概率分布下的熵的负数，而熵是用来表示在此概率分布下，平均每个事件需要多少比特编码。这样就不难理解上述物理意义的编码的概念了。</p><p>但是KL距离并不是传统意义上的距离。</p><p>传统意义上的距离需要满足三个条件：</p><ul><li><p>1）非负性；</p></li><li><p>2）对称性（不满足）；</p></li><li><p>3）三角不等式（不满足）。</p></li></ul><p>但是KL距离三个都不满足。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识神经网络</title>
      <link href="/2022/09/08/%E8%AE%A4%E8%AF%86%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/09/08/%E8%AE%A4%E8%AF%86%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1>神经网络</h1><h2 id="什么是神经网络">什么是神经网络</h2><p><a href="https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/382460">人工神经网络</a>：是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型。在工程与学术界也常直接简称为“神经网络”或类神经网络。（百度百科）</p><p><strong>神经网络</strong>是一门重要的机器学习技术。它是目前最为火热的研究方向–深度学习的基础。</p><p>单层神经网络-感知器</p><p>两层神经网络-多层感知器</p><p>多层神经网络-深度学习</p><h2 id="神经网络结构">神经网络结构</h2><p>这是一个包含三个层次的神经网络。红色的是<strong>输入层</strong>，绿色的是<strong>输出层</strong>，紫色的是<strong>中间层</strong>（也叫<strong>隐藏层</strong>）。输入层有3个输入单元，隐藏层有4个单元，输出层有2个单元。后文中，我们统一使用这种颜色来表达神经网络的结构。</p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNjczNzkzLzIwMTUxMi82NzM3OTMtMjAxNTEyMTkxNTE2MDQzMTgtMTU1NzczNzI4OS5qcGc?x-oss-process=image/format,png" style="zoom:50%;" /><p>神经网络结构图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、设计一个神经网络时，输入层与输出层的节点数往往是固定的，中间层则可以自由指定；</span><br><span class="line"><span class="number">2</span>、神经网络结构图中的拓扑与箭头代表着预测过程时数据的流向，跟训练时的数据流有一定的区别；</span><br><span class="line"><span class="number">3</span>、结构图里的关键不是圆圈（代表“神经元”），而是连接线（代表“神经元”之间的连接）。每个连接线对应一个不同的权重（其值称为权值），这是需要训练得到的。  </span><br></pre></td></tr></table></figure><p>除了从左到右的形式表达的结构图，还有一种常见的表达形式是从下到上来表示一个神经网络。这时候，输入层在图的最下方。</p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNjczNzkzLzIwMTUxMi82NzM3OTMtMjAxNTEyMTkxNzQ2MzE2OTMtNzc1MTgxOTMwLmpwZw?x-oss-process=image/format,png" style="zoom:50%;" /><p>从下到上的神经网络结构图</p><h2 id="神经元模型">神经元模型</h2><p><strong>神经元模型</strong>是一个包含输入，输出与计算功能的模型。输入可以类比为神经元的树突，而输出可以类比为神经元的轴突，计算则可以类比为细胞核。</p><p>下图是一个典型的神经元模型：包含有3个输入，1个输出，以及2个计算功能。</p><p>注意中间的箭头线。这些线称为“连接”。每个上有一个“权值”。</p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNjczNzkzLzIwMTUxMi82NzM3OTMtMjAxNTEyMTkxNTM4NTY4MDItMzA3NzMyNjIxLmpwZw?x-oss-process=image/format,png" style="zoom:50%;" /><p>连接是神经元中最重要的东西。每一个连接上都有一个权重。</p><p>一个神经网络的训练算法就是让权重的值调整到最佳，以使得整个网络的预测效果最好。</p><p>我们使用a来表示输入，用w来表示权值。一个表示连接的有向箭头可以这样理解：在初端，传递的信号大小仍然是a，端中间有加权参数w，经过这个加权后的信号会变成a<em>w，因此在连接的末端，信号的大小就变成了a</em>w。</p><p>在其他绘图模型里，有向箭头可能表示的是值的不变传递。而在神经元模型里，每个有向箭头表示的是值的加权传递。</p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNjczNzkzLzIwMTUxMi82NzM3OTMtMjAxNTEyMTkxODA2MTQ4MTktMTY1MjU3NDIzNS5qcGc?x-oss-process=image/format,png" style="zoom:50%;" /><p>将神经元图中的所有变量用符号表示，并且写出输出的计算公式的话，就是下图。</p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNjczNzkzLzIwMTUxMi82NzM3OTMtMjAxNTEyMzAyMDE0NDE3OTItMTUwNTI4MzkyMC5qcGc?x-oss-process=image/format,png" style="zoom:50%;" /><p>可见z是在输入和权值的线性加权和叠加了一个<strong>函数g</strong>的值。在MP模型里，函数g是sgn函数，也就是取符号函数。这个函数当输入大于0时，输出1，否则输出0。</p><p>下面对神经元模型的图进行一些扩展。首先将sum函数与sgn函数合并到一个圆圈里，代表神经元的内部计算。其次，把输入a与输出z写到连接线的左上方，便于后面画复杂的网络。最后说明，一个神经元可以引出多个代表输出的有向箭头，但值都是一样的。</p><p>神经元可以看作一个计算与存储单元。计算是神经元对其的输入进行计算功能。存储是神经元会暂存计算结果，并传递到下一层。</p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvNjczNzkzLzIwMTUxMi82NzM3OTMtMjAxNTEyMzAyMDQwMzY0NzktNDYxNDQwOTQ4LmpwZw?x-oss-process=image/format,png" style="zoom:50%;" /><p>神经元扩展</p><p>当我们用“神经元”组成网络以后，描述网络中的某个“神经元”时，我们更多地会用“<strong>单元</strong>”（unit）来指代。同时由于神经网络的表现形式是一个有向图，有时也会用“<strong>节点</strong>”（node）来表达同样的意思。</p><p>神经元的输出是a = g（Wx + b），其中g是激活函数（sigmoid，tanh，ReLU，…）</p><p><strong>效果</strong></p><p>神经元模型的使用可以这样理解：</p><p>我们有一个数据，称之为样本。样本有四个属性，其中三个属性已知，一个属性未知。我们需要做的就是通过三个已知属性<strong>预测</strong>未知属性。</p><p>具体办法就是使用神经元的公式进行计算。三个已知属性的值是a1，a2，a3，未知属性的值是z。z可以通过公式计算出来。</p><p>这里，已知的属性称之为<strong>特征</strong>，未知的属性称之为<strong>目标</strong>。假设特征与目标之间确实是线性关系，并且我们已经得到表示这个关系的权值w1，w2，w3。那么，我们就可以通过神经元模型预测新样本的目标。</p><p>“cache”记录来自正向传播单元的值并将其发送到反向传播单元，因为需要链式计算导数。</p><p>我们用“cache”传递前向传播中计算的变量到相应的反向传播步骤，它包含用于计算导数的反向传播的有用值。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机</title>
      <link href="/2022/09/08/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2022/09/08/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1>感知机（perceptron)</h1><hr><h2 id="感知机是什么？">感知机是什么？</h2><ul><li><strong>感知机</strong>：感知机是神经网络（深度学习）的起源算法，学习感知机的构造是通向神经网络和深度学习的一种重要思想。</li><li>感知机接收多个输入信号，输出一个信号。</li><li>这里所说的“信号”可以想 象成电流或河流那样具备“流动性”的东西。</li></ul><p>像电流流过导线，向前方输送 电子一样，感知机的信号也会形成流，向前方输送信息。</p><p>但是，和实际的电 流不同的是，感知机的信号只有“流/不流”（1/0）两种取值。</p><p>0 对应“不传递信号”，1对应“传递信号”。</p><p>x 1 、x 2 是输入信号，</p><p>y 是输出信号，</p><p>w 1 、w 2 是权重 （w 是 weight 的首字母）。</p><p>图中的○称为“神 经元”或者“节点”。</p><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5qrzfmRpXP9qnoSM4GDTu3LxBdCLAtm.P0NYa6nfmTCRQ22zkHE1NjtRedkE2Jg5QD1OLkDjKwj2F3zWbI7dS30!/mnull&amp;bo=zgFMAc4BTAEDCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>输入信号被送往神经元时，会被分别乘以固定的权重（w 1 x 1 、w 2 x 2 ）。</p><p>神经元会计算传送过来的信号的总和，只有当这个总和超过 了某个界限值时，才会输出1。</p><p>这也称为“神经元被激活”。这里将这个界限值称为阈值，用符号θ表示。</p><p>公式一：</p><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5pMtwSErNnhqJl*CVqk8cgtIKTkiE4aIXo4il9SHzinWjvt96p.gSB5rh6qLvZ6Pc4LDR3hij4GClZwuu2xeQjU!/mnull&amp;bo=pQLrAKUC6wADCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>感知机的多个输入信号都有各自固有的权重，这些权重发挥着控制各个 信号的重要性的作用。也就是说，权重越大，对应该权重的信号的重要性就越高。</p><p>权重：相当于电流里的电阻。电阻是决定电流流动难度的参数， 电阻越低，通过的电流就越大。</p><p>而感知机的权重则是值越大，通过的信号就越大。</p><p>不管是电阻还是权重，在控制信号流动难度（或者流 动容易度）这一点上的作用都是一样的。</p><h1>简单的逻辑电路</h1><h2 id="与门（and）">与门（and）</h2><ul><li>与门仅在 两个输入均为1时输出1，其他时候则输出0。</li></ul><h2 id="与非门（NAND">与非门（NAND)</h2><ul><li><p>x1 和x2 同时为1时输出0，其他时候则输出1。</p><p>实际上，只要把实现与门的参数值的符号取反， 就可以实现与非门。</p></li></ul><h2 id="或门（or）">或门（or）</h2><ul><li>或门是“只要有一个输入信号是1，输 出就为1”的逻辑电路。</li></ul><p>感知机可以表示与门、与非门、或门的逻 辑电路。</p><p>这里重要的一点是：与门、与非门、或门的感知机构造是一样的。</p><p>实际上，3个门电路只有参数的值（权重和阈值）不同。</p><p>也就是说，相同构造 的感知机，只需通过适当地调整参数的值，就可以像“变色龙演员”表演不 同的角色一样，变身为与门、与非门、或门。</p><h1>感知机的实现</h1><hr><h2 id="与门的代码实现">与门的代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def AND(x1, x2):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">与门</span><br><span class="line"></span><br><span class="line">在函数内初始化参数 w1 、 w2 、 theta ，当输入的加权总和超过阈值时返回 1 ， 否则返回 0 。</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># w：权重，theta：阈值，x：参数</span><br><span class="line">w1, w2, theta = 0.5, 0.5, 0.7</span><br><span class="line">tmp = x1 * w1 + x2 * w2</span><br><span class="line">print(tmp)</span><br><span class="line">if tmp &lt;= theta:</span><br><span class="line">    return 0</span><br><span class="line">elif tmp &gt; theta:</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">print(AND(0, 0))</span><br><span class="line">print(AND(1, 0))</span><br><span class="line">print(AND(0, 1))</span><br><span class="line">print(AND(0.5, 1))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">0.0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">0.5</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">0.5</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">0.75</span><br><span class="line">1</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="导入权重和偏置的代码实现">导入权重和偏置的代码实现</h2><p>另外一种实现形式。在此之前，首先把公式一的θ换成−b，于 是就可以用式来表示感知机的行为。<br>公式二：<br><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5hxcI9YFYZf8uDa7rxRl27HqvauX8qx*LIPWYKFWpxN2bItoqeZtuu9w*l2tP3i3842lD4ewoYn699onZABIXXw!/mnull&amp;bo=lQK5AJUCuQADCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>b称为偏置，w1和w2称为权重。<br>感知机会计算输入 信号和权重的乘积，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: import numpy as np                                                                          </span><br><span class="line"></span><br><span class="line">In [2]: x = np.array([0,1])        # 输入                                                                 </span><br><span class="line"></span><br><span class="line">In [3]: w = np.array([0.5,0.5])        # 权重                                                            </span><br><span class="line"></span><br><span class="line">In [4]: b = -0.7                            # 偏置                                                        </span><br><span class="line"></span><br><span class="line">In [5]: w * x                                                                                       </span><br><span class="line">Out[5]: array([0. , 0.5])</span><br><span class="line"></span><br><span class="line">In [6]: np.sum(w * x)                                                                               </span><br><span class="line">Out[6]: 0.5</span><br><span class="line"></span><br><span class="line">In [7]: np.sum(w * x) + b                                                                           </span><br><span class="line">Out[7]: -0.19999999999999996    # 大约为 0.2(浮点小数造成的位运算误差)</span><br></pre></td></tr></table></figure><p>如上例所示，在NumPy数组的乘法运算中，当两个数组的元素个数相同时， 各个元素将分别相乘。</p><p>因此 wx 的结果就是它们的各个元素分别相乘（ [0, 1] * [0.5, 0.5] =&gt; [0, 0.5] ）。之后， 再计算相乘后的各个元素的总和。 np.sum(wx)</p><p>最后再把偏置加到这个加权总和上，就完成了 公式二 计算。</p><h2 id="使用权重和偏置的代码实现">使用权重和偏置的代码实现</h2><p>使用权重和偏置，可以像下面这样实现与门。<br>import numpy as np</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def AND(x1, x2):</span><br><span class="line">x = np.array([x1, x2])</span><br><span class="line">w = np.array([0.5, 0.5])</span><br><span class="line">b = -0.7    # 偏置大于权重</span><br><span class="line">tmp = np.sum(w * x) + b</span><br><span class="line">print(tmp)</span><br><span class="line">if tmp &lt;= 0:</span><br><span class="line">    return 0</span><br><span class="line">else:</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(AND(0, 0))</span><br><span class="line">print(AND(1, 0))</span><br><span class="line">print(AND(0, 1))</span><br><span class="line">print(AND(0.5, 1))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">-0.7</span><br><span class="line">0</span><br><span class="line">-0.19999999999999996</span><br><span class="line">0</span><br><span class="line">-0.19999999999999996</span><br><span class="line">0</span><br><span class="line">0.050000000000000044</span><br><span class="line">1</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>偏置和权重w 1 、w 2 的作用是不 一样的。</p><p>w 1 和w 2 是控制输入信号的重要性的参数;</p><p>而偏置是调整神经元被激活的容易程度（输出信号为 1 的程度）的参数。</p><p>比如，若 b 为 −0.1， 则只要输入信号的加权总和超过0.1，神经元就会被激活。</p><p>但是如果b 为−20.0，则输入信号的加权总和必须超过20.0，神经元才会被激活。</p><p>像这样， 偏置的值决定了神经元被激活的容易程度。</p><p>另外，这里我们将w 1 和w 2 称为权重， 将b称为偏置，但是根据上下文，有时也会将b、w 1 、w 2 这些参数统称为权重。</p><p>小知识：偏置这个术语，有“穿木屐” 的效果，即在没有任何输入时（输入为 0时），给输出穿上多高的木屐（加上多大的值）的意思。实际上，在 公式二 的b + w 1 x 1 + w 2 x 2 的计算中，当输入x 1 和x 2 为0时，只输出 偏置的值。</p><h2 id="与非门和或门的代码实现">与非门和或门的代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def NAND(x1, x2):</span><br><span class="line">x = np.array([x1, x2])</span><br><span class="line">w = np.array([-0.5, -0.5])  # 仅权重和偏置 与 AND不同！</span><br><span class="line">b = 0.7 # 偏置设置为正，权重设置为负(与 AND相反)</span><br><span class="line">tmp = np.sum(w * x) + b</span><br><span class="line">print(tmp)</span><br><span class="line">if tmp &lt;= 0:</span><br><span class="line">    return 0</span><br><span class="line">else:</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">print(NAND(0, 0))</span><br><span class="line">print(NAND(1, 0))</span><br><span class="line">print(NAND(0, 1))</span><br><span class="line">print(NAND(0.5, 1))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">0.7</span><br><span class="line">1</span><br><span class="line">0.19999999999999996</span><br><span class="line">1</span><br><span class="line">0.19999999999999996</span><br><span class="line">1</span><br><span class="line">-0.050000000000000044</span><br><span class="line">0</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print(&#x27;-&#x27; * 100)</span><br><span class="line"></span><br><span class="line">def OR(x1, x2):</span><br><span class="line">    x = np.array([x1, x2])</span><br><span class="line">    w = np.array([0.5, 0.5])  # 仅权重和偏置 与 AND不同！</span><br><span class="line">b = -0.2        # 偏置小于 权重</span><br><span class="line">tmp = np.sum(w * x) + b</span><br><span class="line">print(tmp)</span><br><span class="line">if tmp &lt;= 0:</span><br><span class="line">    return 0</span><br><span class="line">else:</span><br><span class="line">    return 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">print(OR(0, 0))</span><br><span class="line">print(OR(1, 0))</span><br><span class="line">print(OR(0, 1))</span><br><span class="line">print(OR(0.5, 1))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">-0.2</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">0.3</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">0.3</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">0.55</span><br><span class="line">1</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>与门、与非门、或门是具有相同构造的感知机， 区别只在于权重参数的值。</p><p>因此，在与非门和或门的实现中，仅设置权重和 偏置的值这一点和与门的实现不同。</p><h2 id="感知机的局限性">感知机的局限性</h2><p>使用感知机可以实现与门、与非门、或门三种逻 辑电路。</p><p>现在我们来考虑一下异或门（XOR gate） 。</p><h2 id="异或门">异或门</h2><p>异或门也被称为逻辑异或电路。</p><p>仅当x 1 或x 2 中的一方为 1时，才会输出1（“异或”是拒绝其他的意思）。<br>实际上，用前面介绍的感知机是无法实现这个异或门的。</p><p>我们试着将或门的<strong>动作形象化</strong>。</p><p>或门的情况下，当权重参数 (b, w 1 , w 2 ) = (−0.5, 1.0, 1.0)时，可满足 或门 的真值表条件。</p><p>此时，感知机 可用下面的式 公式三 表示。</p><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5ipXFgRONGDoifEuHxYdiwBOBAPYmZw1fDfT.b1xgb*TsYrWzIH24q0GENsC8O0QWh4Lpybb9kYR5HHt4E4mdEg!/mnull&amp;bo=4QLmAOEC5gADCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>公式三 表示的感知机会生成由直线−0.5 + x 1 + x 2 = 0分割开的两个空间。</p><p>其中一个空间输出1，另一个空间输出0，如下图所示。</p><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5nXMkAhCgMvhNd83kDUP03wxr0fm6wTkzu4v8k73nU69FZkdyyHbbsG1I6rS2FIT1RcqRQCHqCk2..*wcIxY31k!/mnull&amp;bo=6QLSAukC0gIDCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>感知机的可视化图：灰色区域是感知机输出0的区域，这个区域与或门的性质一致</p><p>或门在 (x 1 , x 2 ) = (0, 0) 时输出 0，在 (x 1 , x 2 ) 为 (0, 1)、(1, 0)、(1, 1) 时输 出1。感知机的可视化图中，○表示0，△表示1。</p><p>现在需要用直线将上图中的○和△分开。实际上，刚才的那条直线就将这4个点正确地分开了（归类）。</p><p>如果我们换成异或门的话，能否像或门那样，用一条直线作出分 割 下图中的○和△的空间呢？<br><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5iwpiPtNsFgeDzabzAVidjq7u6geT0lTg9jjzCYNjR9oRsbFC3WNDU0jAXA5qe300.c3MA9aOHqnIvngI.hiSgo!/mnull&amp;bo=*wLaAv8C2gIDCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>想要用一条直线将 上图 中的○和△分开，无论如何都做不到。事实上， 用一条直线是无法将○和△分开的。</p><p>但是如果将 “直线” 这个限制去掉，就可以实现了。</p><h2 id="线性-和-非线性">线性 和 非线性</h2><p>感知机的<strong>局限性</strong>就在于它<strong>只能表示由一条直线分割的空间</strong>。</p><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5nsR9Xkuh*VAv9qbJoQVu8DY5W7Y4UwjJwE0jvHzsZmxlhDi1QuEyB76wntcrY8mcOzf7EWr7oSHB.XiFQOM57s!/mnull&amp;bo=cAJqAnACagIDCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>上图中 这样弯曲的曲线是无法用感知机表示的。</p><p>由<strong>曲线分割</strong> 而成的空间称为 <strong>非线性空间</strong>；</p><p>由<strong>直线分割</strong> 而成的空间称为 <strong>线性空间</strong>。</p><p>线性、非线性这两个术语在机器学习领域很常见，可以将其想象成上图所示的直线和曲线分割而成的空间。</p><h2 id="多层感知机">多层感知机</h2><p>“单层感知机无法表示异或门”或者“单层感知机无法分离非线性空间”。</p><p>但感知机 的绝妙之处在于它可以**“叠加层”**（通过叠加层来表示异或门）。</p><p>异或门的制作方法有很多，其中之一就是组合我们前面做好的与门、与 非门、或门进行配置。</p><p><strong>代码实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def XOR(x1, x2):</span><br><span class="line">s1 = NAND(x1, x2)  # 与 AND 相反  有0 就行</span><br><span class="line">s2 = OR(x1, x2)  # 只要有一个既返回 1   # 有 1就行</span><br><span class="line">y = AND(s1, s2)  # 必须两个都是1</span><br><span class="line">return y</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5rAk6AALhZlzJksPve.PkE8k3KWYCBYP*YURGUpvOSQtixDQ97ahA7FGVXFGyXYeWjOWXBgqT39Vre2vOzTq4mc!/mnull&amp;bo=pAPJAqQDyQIDCSw!&amp;rf=photolist&amp;t=5" alt=""></p><p>通过组合与门、与非门、或门实现异或门</p><p>这里，把s1 作为 与非门 的输出，把s 2 作为或门的输出，填入真值表中。</p><p>结果如图所示，观察x1、x 2 、y，可以发现确实符合异或门的输出。</p><p>异或门是一种<strong>多层结构的神经网络。</strong></p><p>与门、或门是单层感知机，而异或门是2层感知机。叠加了多 层的感知机也称为多层感知机（multi-layered perceptron） 。</p><p><img src="http://a1.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5ipXFgRONGDoifEuHxYdiwDLof4m2W9aaA3faRTLTHyVOlyXhNPVMf.zBGeJpiNYmwJiCBRbWjbfbRv6R3LvFhU!/c&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=qgKVAaoClQEDGTw!&amp;tl=1&amp;vuin=1005741898&amp;tm=1618934400&amp;sce=60-2-2&amp;rf=0-0" alt=""></p><p>用感知机表示异或门</p><p>上图中的感知机总共由3层构成，但是因为拥有权重的层实质 上只有2层（第0层和第1层之间，第1层和第2层之间），所以称 为“2层感知机”。不过，有的文献认为上图的感知机是由3层 构成的，因而将其称为“3层感知机”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.第0层的两个神经元接收输入信号，并将信号发送至第1层的神经元。</span><br><span class="line"></span><br><span class="line">2.第1层的神经元将信号发送至第2层的神经元，第2层的神经元输出y。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>小结</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">感知机是具有输入和输出的算法。给定一个输入后，将输出一个既 定的值。</span><br><span class="line"></span><br><span class="line">感知机将权重和偏置设定为参数。</span><br><span class="line"></span><br><span class="line">使用感知机可以表示与门和或门等逻辑电路。</span><br><span class="line"></span><br><span class="line">异或门无法通过单层感知机来表示。</span><br><span class="line"></span><br><span class="line">使用2层感知机可以表示异或门。</span><br><span class="line"></span><br><span class="line">单层感知机只能表示线性空间，而多层感知机可以表示非线性空间。</span><br><span class="line"></span><br><span class="line">多层感知机（在理论上）可以表示计算机。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作者：陈宝佳<br>链接：<a href="https://www.jianshu.com/p/a25788130897">https://www.jianshu.com/p/a25788130897</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感知机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则化、离散化、归一化、标准化</title>
      <link href="/2022/09/08/%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%BD%92%E4%B8%80%E5%8C%96/"/>
      <url>/2022/09/08/%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96%E3%80%81%E5%BD%92%E4%B8%80%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1>正则化(regularization)</h1><hr><h2 id="正则化的目的">正则化的目的</h2><p>正则化是为了防止过拟合， 进而增强<strong>泛化</strong>能力。<br>&quot;<strong>泛化</strong>&quot;指的是一个假设模型能够应用到新样本的能力。</p><h1>离散化</h1><h2 id="定义">定义</h2><p><strong>离散化</strong>是指将连续的数据进行分段，使其变为一段段离散化的区间。分段的原则有基于等距离、等频率或优化的方法。</p><h2 id="作用">作用</h2><ol><li><strong>模型限制</strong><br>比如决策树、朴素贝叶斯等算法，都是基于离散型的数据展开的。如果要使用该类算法，必须将离散型的数据进行。有效的离散化能减小算法的时间和空间开销，提高系统对样本的分类聚类能力和抗噪声能力。</li><li><strong>离散化的特征更易理解</strong><br>比如工资收入，月薪2000和月薪20000，从连续型特征来看高低薪的差异还要通过数值层面才能理解，但将其转换为离散型数据(低薪、高薪)，则可以更加直观的表达出了我们心中所想的高薪和低薪。</li><li><strong>使模型结果更加稳定</strong></li></ol><h1>归一化</h1><hr><p>归一化方法有两种形式，一种是把数变为(0，1)之间的小数，一种是把有量纲表达式变为无量纲表达式。</p><p>主要是为了数据处理方便提出来的，把数据映射到0~1范围之内处理，更加便捷快速，应该归到数字信号处理范畴之内。</p><p>原始数据经过数据标准化处理后，各指标处于<strong>同一数量级</strong>，适合进行综合对比评价。</p><h2 id="min-max标准化（Min-Max-Normalization）">min-max标准化（Min-Max Normalization）</h2><p>也称为<strong>离差标准化</strong>，是对原始数据的线性变换，使结果值映射到[0 , 1]之间。<br><img src="https://img-blog.csdn.net/20160704143022847" alt=""></p><p>使用这种方法目的：<br>1、对于方差非常小的属性可以增强其稳定性；<br>2、维持稀疏矩阵中为0的条目。</p><h4 id="手写代码实现：">手写代码实现：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">arr = np.asarray([0, 10, 50, 80, 100])</span><br><span class="line">for x in arr:</span><br><span class="line">x = float(x - np.min(arr))/(np.max(arr)- np.min(arr))</span><br><span class="line">print x</span><br><span class="line"> </span><br><span class="line"># output</span><br><span class="line"># 0.0</span><br><span class="line"># 0.1</span><br><span class="line"># 0.5</span><br><span class="line"># 0.8</span><br><span class="line"># 1.0</span><br></pre></td></tr></table></figure><h4 id="sklearn代码实现：">sklearn代码实现：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import preprocessing   </span><br><span class="line"> </span><br><span class="line">import numpy as np  </span><br><span class="line"> </span><br><span class="line">X = np.array  ([[ 1., -1.,  2.],  </span><br><span class="line">[ 2.,  0.,  0.],  </span><br><span class="line">[ 0.,  1., -1.]])  </span><br><span class="line"></span><br><span class="line">min_max_scaler = preprocessing.MinMaxScaler() #MinMaxScalar函数 </span><br><span class="line">X_minMax = min_max_scaler.fit_transform(X)   </span><br><span class="line"></span><br><span class="line">X_minMax</span><br><span class="line"></span><br><span class="line"># output </span><br><span class="line">array([ [ 0.5       ,  0.        ,  1.        ],  </span><br><span class="line">[ 1.        ,  0.5       ,  0.33333333],  </span><br><span class="line">[ 0.        ,  1.        ,  0.        ]]) </span><br></pre></td></tr></table></figure><p>当然，在构造类对象的时候也可以直接指定最大最小值的范围：<br>feature_range=(min, max)，<br>此时应用的公式变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_std=(X-X.min(axis=0))/(X.max(axis=0)-X.min(axis=0))  </span><br><span class="line">X_minmax=X_std/(X.max(axis=0)-X.min(axis=0))+X.min(axis=0))</span><br></pre></td></tr></table></figure><h2 id="Z-score标准化方法-mean-normaliztion">Z-score标准化方法(mean normaliztion)</h2><p>也称为均值归一化(mean normaliztion)， 给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合<strong>标准正态分布</strong>，即均值为0，标准差为1。转化函数为：<br><img src="https://img-blog.csdn.net/20160704143139785" alt=""><br>其中 μ 为所有样本数据的均值，σ为所有样本数据的标准差。</p><h4 id="手写代码实现">手写代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line">arr = np.asarray([0, 10, 50, 80, 100])</span><br><span class="line">for x in arr:</span><br><span class="line">x = float(x - arr.mean())/arr.std()</span><br><span class="line">print x</span><br><span class="line"> </span><br><span class="line"># output</span><br><span class="line"># -1.24101045599</span><br><span class="line"># -0.982466610991</span><br><span class="line"># 0.0517087689995</span><br><span class="line"># 0.827340303992</span><br><span class="line"># 1.34442799399</span><br></pre></td></tr></table></figure><h4 id="skleran代码实现">skleran代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import preprocessing</span><br><span class="line"></span><br><span class="line">data = preprocessing.scale(values) #注意，这里的values是array</span><br></pre></td></tr></table></figure><h2 id="函数转换方法">函数转换方法</h2><h3 id="log函数转换">log函数转换</h3><p>通过以10为底的log函数转换的方法同样可以实现归一下，具体方法如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/562539f87010cf3a9ab7a06c900641e1.png" alt=""></p><p>使用注意：max为样本数据最大值，并且所有的数据都要大于等于1。</p><h3 id="atan函数转换">atan函数转换</h3><p>通过反正切函数也可以实现数据的归一化：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c7d28474a16c90f87284a9ae982b88e7.png" alt=""></p><p>使用这个方法需要注意的是如果想映射的区间为[0,1]，则数据都应该大于等于0，小于0的数据将被映射到[-1,0]区间上，而并非所有数据标准化的结果都映射到[0,1]区间上。</p><h3 id="Sigmoid函数转换（十分重要）">Sigmoid函数转换（十分重要）</h3><p>Sigmoid函数是一个具有S形曲线的函数，是<strong>良好的阈值函数</strong>，在(0, 0.5)处中心对称，在(0, 0.5)附近有比较大的斜率，而当数据趋向于正无穷和负无穷的时候，映射出来的值就会无限趋向于1和0，是个人非常喜欢的“归一化方法”，之所以打引号是因为我觉得Sigmoid函数在<strong>阈值分割</strong>上也有很不错的表现，根据公式的改变，就可以改变分割阈值，这里作为归一化方法，我们只考虑(0, 0.5)作为分割阈值的点的情况：</p><p><img src="https://img-blog.csdn.net/20141006211516437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3J5b2xpdGg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sigmoid(X,useStatus):</span><br><span class="line">if useStatus:</span><br><span class="line">     return 1.0 / (1 + np.exp(-float(X)))</span><br><span class="line">else:</span><br><span class="line">    return float(X)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐算法概述</title>
      <link href="/2022/09/08/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/09/08/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-推荐算法概述">1 推荐算法概述</h2><p>推荐算法是非常古老的，在机器学习还没有兴起的时候就有需求和应用了。概括来说，可以分为以下5种：</p><ol><li><strong>基于内容的推荐</strong>：这一类一般依赖于自然语言处理NLP的一些知识，通过挖掘文本的TF-IDF特征向量，来得到用户的偏好，进而做推荐。这类推荐算法可以找到用户独特的小众喜好，而且还有较好的解释性。这一类由于需要NLP的基础，本文就不多讲，在后面专门讲NLP的时候再讨论。</li><li><strong>协调过滤推荐</strong>：本文后面要专门讲的内容。协调过滤是推荐算法中目前最主流的种类，花样繁多，在工业界已经有了很多广泛的应用。它的优点是不需要太多特定领域的知识，可以通过基于统计的机器学习算法来得到较好的推荐效果。最大的优点是工程上容易实现，可以方便应用到产品中。目前绝大多数实际应用的推荐算法都是协同过滤推荐算法。</li><li><strong>混合推荐</strong>：这个类似我们机器学习中的集成学习，博才众长，通过多个推荐算法的结合，得到一个更好的推荐算法，起到三个臭皮匠顶一个诸葛亮的作用。比如通过建立多个推荐算法的模型，最后用投票法决定最终的推荐结果。混合推荐理论上不会比单一任何一种推荐算法差，但是使用混合推荐，算法复杂度就提高了，在实际应用中有使用，但是并没有单一的协调过滤推荐算法，比如逻辑回归之类的二分类推荐算法广泛。</li><li><strong>基于规则的推荐</strong>：这类算法常见的比如基于最多用户点击，最多用户浏览等，属于大众型的推荐方法，在目前的大数据时代并不主流。</li><li><strong>基于人口统计信息的推荐</strong>：这一类是最简单的推荐算法了，它只是简单的根据系统用户的基本信息发现用户的相关程度，然后进行推荐，目前在大型系统中已经较少使用。</li></ol><h2 id="2-协调过滤推荐算法">2 协调过滤推荐算法</h2><p><strong>协同过滤(Collaborative Filtering)作</strong>为推荐算法中最经典的类型，包括在线的协同和离线的过滤两部分。所谓在线协同，就是通过在线数据找到用户可能喜欢的物品，而离线过滤，则是过滤掉一些不值得推荐的数据，比比如推荐值评分低的数据，或者虽然推荐值高但是用户已经购买的数据。</p><p>协同过滤的模型一般为m个物品，m个用户的数据，只有部分用户和部分数据之间是有评分数据的，其它部分评分是空白，此时我们要用已有的部分稀疏数据来预测那些空白的物品和数据之间的评分关系，找到最高评分的物品推荐给用户。</p><p>一般来说，协同过滤推荐分为三种类型：<br>第一种是基于用户(user-based)的协同过滤，<br>第二种是基于项目(item-based)的协同过滤，<br>第三种是基于模型(model based)的协同过滤。</p><p><strong>基于用户(user-based)的协同过滤</strong>主要考虑的是用户和用户之间的相似度，只要找出相似用户喜欢的物品，并预测目标用户对对应物品的评分，就可以找到评分最高的若干个物品推荐给用户。</p><p><strong>基于项目(item-based)的协同过滤</strong>和基于用户的协同过滤类似，只不过这时我们转向找到物品和物品之间的相似度，只有找到了目标用户对某些物品的评分，那么我们就可以对相似度高的类似物品进行预测，将评分最高的若干个相似物品推荐给用户。比如你在网上买了一本机器学习相关的书，网站马上会推荐一堆机器学习，大数据相关的书给你，这里就明显用到了基于项目的协同过滤思想。</p><p>我们可以简单比较下基于用户的协同过滤和基于项目的协同过滤：基于用户的协同过滤需要在线找用户和用户之间的相似度关系，计算复杂度肯定会比基于基于项目的协同过滤高。但是可以帮助用户找到新类别的有惊喜的物品。而基于项目的协同过滤，由于考虑的物品的相似性一段时间不会改变，因此可以很容易的离线计算，准确度一般也可以接受，但是推荐的多样性来说，就很难带给用户惊喜了。一般对于小型的推荐系统来说，基于项目的协同过滤肯定是主流。但是如果是大型的推荐系统来说，则可以考虑基于用户的协同过滤。</p><p><strong>基于模型(model based)的协同过滤</strong>是目前最主流的协同过滤类型了，我们的一大堆机器学习算法也可以在这里找到用武之地。下面我们就重点介绍基于模型的协同过滤。</p><h2 id="3-基于模型的协同过滤">3 基于模型的协同过滤</h2><p>基于模型的协同过滤作为目前最主流的协同过滤类型，其相关算法可以写一本书了，当然我们这里主要是对其思想做有一个归类概括。我们的问题是这样的m个物品，m个用户的数据，只有部分用户和部分数据之间是有评分数据的，其它部分评分是空白，此时我们要用已有的部分稀疏数据来预测那些空白的物品和数据之间的评分关系，找到最高评分的物品推荐给用户。</p><p>对于这个问题，用机器学习的思想来建模解决，主流的方法可以分为：用关联算法，聚类算法，分类算法，回归算法，矩阵分解，神经网络,图模型以及隐语义模型来解决。下面我们分别加以介绍。</p><h4 id="3-1-用关联算法做协同过滤">3.1 用关联算法做协同过滤</h4><p>一般我们可以找出用户购买的所有物品数据里频繁出现的项集活序列，来做频繁集挖掘，找到满足支持度阈值的关联物品的频繁N项集或者序列。如果用户购买了频繁N项集或者序列里的部分物品，那么我们可以将频繁项集或序列里的其他物品按一定的评分准则推荐给用户，这个评分准则可以包括支持度，置信度和提升度等。<br>常用的关联推荐算法有<strong>Apriori</strong>，<strong>FP Tree</strong>和<strong>PrefixSpan</strong>。如果大家不熟悉这些算法，可以参考我的另外几篇文章：<br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6293298.html">Apriori算法原理总结</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6307064.html" title="FP Tree算法原理总结">FP Tree算法原理总结</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6323182.html">PrefixSpan算法原理总结</a></p><h4 id="3-2-用聚类算法做协同过滤">3.2 用聚类算法做协同过滤</h4><p>用聚类算法做协同过滤就和前面的基于用户或者项目的协同过滤有些类似了。我们可以按照用户或者按照物品基于一定的距离度量来进行聚类。如果基于用户聚类，则可以将用户按照一定距离度量方式分成不同的目标人群，将同样目标人群评分高的物品推荐给目标用户。基于物品聚类的话，则是将用户评分高物品的相似同类物品推荐给用户。<br>常用的聚类推荐算法有<strong>K-Means</strong>, <strong>BIRCH</strong>, <strong>DBSCAN</strong>和<strong>谱聚类</strong>，如果大家不熟悉这些算法，可以参考我的另外几篇文章：<br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6164214.html">K-Means聚类算法原理</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6179132.html">BIRCH聚类算法原理</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6208966.html">DBSCAN密度聚类算法</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6221564.html">谱聚类（spectral clustering）原理总结</a></p><h4 id="3-3-用分类算法做协同过滤">3.3 用分类算法做协同过滤</h4><p>如果我们根据用户评分的高低，将分数分成几段的话，则这个问题变成分类问题。比如最直接的，设置一份评分阈值，评分高于阈值的就是推荐，评分低于阈值就是不推荐，我们将问题变成了一个二分类问题。虽然分类问题的算法多如牛毛，但是目前使用最广泛的是逻辑回归。为啥是逻辑回归而不是看起来更加高大上的比如支持向量机呢？因为逻辑回归的解释性比较强，每个物品是否推荐我们都有一个明确的概率放在这，同时可以对数据的特征做工程化，得到调优的目的。目前逻辑回归做协同过滤在BAT等大厂已经非常成熟了。<br>常见的分类推荐算法有<strong>逻辑回归</strong>和<strong>朴素贝叶斯</strong>，两者的特点是解释性很强。如果大家不熟悉这些算法，可以参考我的另外几篇文章：<br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6029432.html">逻辑回归原理小结</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6069267.html">朴素贝叶斯算法原理小结</a></p><h4 id="3-4-用回归算法做协同过滤">3.4 用回归算法做协同过滤</h4><p>用回归算法做协同过滤比分类算法看起来更加的自然。我们的评分可以是一个连续的值而不是离散的值，通过回归模型我们可以得到目标用户对某商品的预测打分。</p><p>常用的回归推荐算法有<strong>Ridge回归</strong>，<strong>回归树</strong>和<strong>支持向量回归</strong>。如果大家不熟悉这些算法，可以参考我的另外几篇文章：<br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6004041.html">线性回归原理小结</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6053344.html">决策树算法原理(下)</a><br><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6113120.html">支持向量机原理(五)线性支持回归</a></p><h4 id="3-5-用矩阵分解做协同过滤">3.5 用矩阵分解做协同过滤</h4><p>用矩阵分解做协同过滤是目前使用也很广泛的一种方法。由于传统的奇异值分解SVD要求矩阵不能有缺失数据，必须是稠密的，而我们的用户物品评分矩阵是一个很典型的稀疏矩阵，直接使用传统的SVD到协同过滤是比较复杂的。</p><p>目前主流的矩阵分解推荐算法主要是<strong>SVD</strong>的一些变种，比如FunkSVD，BiasSVD和SVD++。这些算法和传统SVD的最大区别是不再要求将矩阵分解为UΣVT的形式，而变是两个低秩矩阵PTQ的乘积形式。<br>对于矩阵分解的推荐算法，后续我会专门开篇来讲。</p><h4 id="3-6-用神经网络做协同过滤">3.6 用神经网络做协同过滤</h4><p>用神经网络乃至深度学习做协同过滤应该是以后的一个趋势。目前比较主流的用两层神经网络来做推荐算法的是<strong>限制玻尔兹曼机(RBM)</strong>。在目前的Netflix算法比赛中， RBM算法的表现很牛。当然如果用深层的神经网络来做协同过滤应该会更好，大厂商用深度学习的方法来做协同过滤应该是将来的一个趋势。后续我会专门开篇来讲讲RBM。</p><h4 id="3-7-用图模型做协同过滤">3.7 用图模型做协同过滤</h4><p>用图模型做协同过滤，则将用户之间的相似度放到了一个图模型里面去考虑，常用的算法是<strong>SimRank系列算法</strong>和<strong>马尔科夫模型算法</strong>。对于SimRank系列算法，它的基本思想是被相似对象引用的两个对象也具有相似性。算法思想有点类似于大名鼎鼎的PageRank。而马尔科夫模型算法当然是基于马尔科夫链了，它的基本思想是基于传导性来找出普通距离度量算法难以找出的相似性。后续我会专门开篇来讲讲SimRank系列算法。</p><h4 id="3-8-用隐语义模型做协同过滤">3.8 用隐语义模型做协同过滤</h4><p>隐语义模型主要是基于NLP的，涉及到对用户行为的语义分析来做评分推荐，主要方法有<strong>隐性语义分析LSA</strong>和<strong>隐含狄利克雷分布LDA</strong>，这些等讲NLP的再专门讲。</p><h2 id="4-协同过滤的一些新方向">4 协同过滤的一些新方向</h2><p>当然推荐算法的变革也在进行中，就算是最火爆的基于逻辑回归推荐算法也在面临被取代。哪些算法可能取代逻辑回归之类的传统协同过滤呢？下面是我的理解：</p><p>a) <strong>基于集成学习的方法和混合推荐</strong>:这个和混合推荐也靠在一起了。由于集成学习的成熟，在推荐算法上也有较好的表现。一个可能取代逻辑回归的算法是GBDT。目前GBDT在很多算法比赛都有好的表现，而有工业级的并行化实现类库。</p><p>b)<strong>基于矩阵分解的方法</strong>：矩阵分解，由于方法简单，一直受到青睐。目前开始渐渐流行的矩阵分解方法有分解机(Factorization Machine)和张量分解(Tensor Factorization)。</p><p>c) <strong>基于深度学习的方法</strong>：目前两层的神经网络RBM都已经有非常好的推荐算法效果，而随着深度学习和多层神经网络的兴起，以后可能推荐算法就是深度学习的天下了？目前看最火爆的是基于CNN和RNN的推荐算法。</p><h2 id="5-协同过滤总结">5 协同过滤总结</h2><p>协同过滤作为一种经典的推荐算法种类，在工业界应用广泛，它的优点很多，模型通用性强，不需要太多对应数据领域的专业知识，工程实现简单，效果也不错。这些都是它流行的原因。</p><p>当然，协同过滤也有些难以避免的难题，比如令人头疼的“冷启动”问题，我们没有新用户任何数据的时候，无法较好的为新用户推荐物品。同时也没有考虑情景的差异，比如根据用户所在的场景和用户当前的情绪。当然，也无法得到一些小众的独特喜好，这块是基于内容的推荐比较擅长的。</p><p>以上就是协同过滤推荐算法的一个总结，希望可以帮大家对推荐算法有一个更深的认识，并预祝大家新年快乐！、</p><p>出处：<a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/pinard/p/6349233.html" title="协同过滤推荐算法总结 - 刘建平Pinard">协同过滤推荐算法总结 - 刘建平Pinard</a></p>]]></content>
      
      
      <categories>
          
          <category> 推荐算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国赛论文制作笔记</title>
      <link href="/2022/09/08/%E5%9B%BD%E8%B5%9B%E8%AE%BA%E6%96%87%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/08/%E5%9B%BD%E8%B5%9B%E8%AE%BA%E6%96%87%E5%88%B6%E4%BD%9C%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数学建模论文基本构成">数学建模论文基本构成</h2><ul><li>首页：<ul><li>论文题目、摘要、关键词</li></ul></li><li>论文正文<ul><li>问题重述</li><li>问题分析</li><li>模型假设</li><li>符号说明</li><li>模型建立与求解</li><li>模型检验/模型改进与推广</li><li>模型优缺点评价</li></ul></li><li>参考文献</li><li>附录</li></ul><h2 id="论文格式">论文格式</h2><ul><li>论文题目：黑体3号，居中</li><li>摘要标题：黑体4号，居中</li><li>摘要内容：宋体，小4号</li><li>关键词：黑体小4号</li><li>正文一级标题：黑体4号，居中</li><li>正文二三级标题：黑体小4号，居左</li><li>正文：宋体，小四号</li><li>数字、字母：Times Nem Roman</li><li>页边距：上下左右2.5厘米</li><li>论文页数：正文20页以内</li></ul><h2 id="论文首页：题目，摘要，关键词">论文首页：题目，摘要，关键词</h2><h3 id="论文题目：">论文题目：</h3><p>应尽量涵盖论文研究得主要对象或研究内容，所采用的主要研究方法</p><p>简短，精炼，一目了然</p><p>独自一行，居中排版</p><h4 id="常见方法：">常见方法：</h4><h5 id="第一种：基于XXX模型-方法-理论的XXX问题研究（一般）">第一种：基于XXX模型/方法/理论的XXX问题研究（一般）</h5><p>基于一维热传导方程的炉温曲线机理模型研究</p><p>基于动态规划，统计分析、静态博弈的穿越沙漠游戏策略设计</p><h5 id="第二种：直接对问题进行简化作为题目（大神选择）">第二种：直接对问题进行简化作为题目（大神选择）</h5><p>穿越沙漠游戏中的玩家行为决策问题</p><h4 id="关键词">关键词</h4><p>3-5个，尽可能涵盖</p><p>包括五部分内容</p><ul><li>研究对象或研究内容</li><li>研究目的</li><li>主要模型</li><li>求解算法</li><li>验证方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：熵权值法 模糊综合评价模型 多目标规划模型 小区开放评价 通行影响</span><br><span class="line">信贷风险评估 梯度下降法 改进的决策树模型 非线性规划 集成学习</span><br></pre></td></tr></table></figure><h3 id="论文摘要（非常重要）">论文摘要（非常重要）</h3><p><strong>摘要内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">摘要是现代科技论文的一个导读部分。摘要应具有独立性和代表性，即拥有与文献同等量的主要信息，即不阅读全文，就能获得必要的信息，它是解决读者再短时间内了解论文内容和方法的有效手段。</span><br></pre></td></tr></table></figure><p><strong>主要包括</strong></p><ul><li><p>背景和问题：应简要叙述研究的对象和研究内容、研究目的</p></li><li><p>问题分析：一句题目给出的数据或自行收集了哪些数据或信息</p></li><li><p>关键假设：对所研究的问题、数据做了 哪些机理分析或数据观察，据此做出了什么样的关键假设。</p></li><li><p>模型结构：采用了什么建模方法、数学模型</p></li><li><p>求解算法：对模型用了啥算法、方法或软件</p></li><li><p>结果，检验，结论</p></li><li><p>（<strong>关键词请加深加粗</strong>）</p><p><img src="https://s1.ax1x.com/2022/09/08/vqJ39I.png" alt="vqJ39I.png"></p></li></ul><h4 id="三大部分：">三大部分：</h4><ul><li>摘要前言：<ul><li>2~3句话</li><li>总结概括</li><li>研究问题的背景或意义/主要思路和方法/解决的问题或成果</li></ul></li><li>摘要正文：<ul><li>简述各个问题的建模过程与结果分析</li><li>针对问题X,针对问题X。。。</li><li>四部分：<strong>简述问题，建模思路，模型求解和结果分析</strong></li></ul></li><li>摘要结尾：<ul><li>对整个模型过程的总结和升华，常见的是进行优缺点评价、模型的创新性评价、模型的推广等。（强调亮点）</li></ul></li></ul><p><strong>简述问题</strong></p><p>解决的主要问题是什么，目的是让阅卷老师第一时间判定你是否准确解读题意。</p><p>表述形式一：直接归纳：（针对问题一，主要分析拍照赚钱任务未完成的原因）；</p><p>表述形式二：分类：（针对问题二，可以将其定性为评价类问题）</p><p><strong>建模思路</strong></p><p>问题的分析或数据预处理 + 采用了什么数学方法或进行了哪些分析 + 建立了什么样的数学模型</p><p><strong>模型求解</strong></p><p>基于XX数据，采用了XX算法/软件对模型进行求解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">利用差分法对方程组逐层求解，基于最小二乘原理，拟合实测温度，遍历得到最优的参数组合。将该组参数代入后即可得到一堆热传递模型。</span><br><span class="line">针对问题一的信贷风险评价模型，我们运用MATLAB软件编写指标计算和主成分分析程序，计算了XXXX安全指标。</span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><p>计算性问题：要求我们计算的计算量，注意单位，字体加深</p><p>开放性问题：关键性的结果进行简述，有数据最好。</p><h2 id="论文正文部分撰写">论文正文部分撰写</h2><p>问题重述-----&gt;问题分析-----&gt;模型假设------&gt;符号说明------&gt;模型建立与求解</p><h3 id="问题重述">问题重述</h3><p>首先要简单地说明问题地情景，即要说清楚事情地来龙去脉。列出必要数据，提出要解决地问题，并给出研究对象地关键信息地内容，它的目的在于使读者对要解决的问题有一个印象。</p><p><strong>真实意图</strong>：查看学院能否读懂题意，明确主要问题和待解决的难点。</p><p><strong>严重警告</strong>：绝对不能照抄原题！</p><p>针对数值计算求解类：将赛题背景简述后照搬（更改为自己语言）</p><p>针对开放类赛题：适当进行扩充或简化，提炼关键语言。（更改为自己语言）</p><p>最重要：<strong>语言改写</strong></p><p><img src="https://s1.ax1x.com/2022/09/08/vqJJjf.png" alt="vqJJjf.png"></p><h3 id="问题分析">问题分析</h3><p>问题分析是将具体问题抽象为数学模型的桥梁，反映了对问题的认识成都，体现了解决问题的雏形，也就是给出建模的思路，启乘上启下作用，反应建模者的综合水平。</p><p><strong>包含内容</strong>：</p><ul><li>题目中包括的已知条件，参数或数据等；</li><li>对问题进行宏观分析，确定要解决问题的关键</li><li>对该问题给出大致的求解思路（可建立XX模型用XX方法）</li><li>给出该问题已得到求解的相关描述</li></ul><p><strong>提示</strong>：</p><ul><li>每一小问单独设置一段</li><li>不要与摘要重复</li><li>不需要具体求解结果</li><li>可用流程图/思维导图描述求解思路</li></ul><p><img src="https://s1.ax1x.com/2022/09/08/vqJl4A.png" alt="vqJl4A.png"></p><h3 id="模型假设">模型假设</h3><p>对一些不必要的细节进行规避。</p><p>假设 一般不是实际问题直接提供的，它们因人而异，所以在撰写时要注意：</p><ul><li>论文中的假设要以严格、确切的数学语言来表达，使读者不产生任何曲解。</li><li>所提出的假设确实是建立模型所必需的，与模型无关的假设只会扰乱读者思考</li><li>具备合理性，可用别的参考资料推类。</li></ul><p>撰写模型假设时，一般包括一下几种情况：</p><ul><li>①对题目中已知条件或餐宿做出保真性假设</li><li>②仅考虑题目中涉及的主要条件，对其他情况不考虑或强制规定</li><li>③对题目中涉及的主要条件进行平稳性规定</li><li>④为使研究更简便、或从常识性角度做出的假设</li><li>⑤对相关参数做出规定</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例题 2019A</span><br><span class="line">1、高压有关是刚体，不考虑形变：  ③</span><br><span class="line">2、题目给出的数据准确，无异常值： ①</span><br><span class="line">3、不考虑高压油管内壁对油的摩擦力：  ②</span><br><span class="line">4、不考虑液体压力：   ②</span><br><span class="line">5、整个系统温度恒定   ③</span><br></pre></td></tr></table></figure><h3 id="符号说明">符号说明</h3><p>是对建模过程中涉及到的主要变量提前在论文中进行描述，方便评审老师阅读评论</p><p><strong>三线表！！</strong></p><p><strong>全局变量</strong>，临时变量不屑</p><p><strong>希腊字母！！</strong></p><p><img src="https://s1.ax1x.com/2022/09/08/vqJuHe.png" alt="vqJuHe.png"></p><h3 id="模型建立与求解">模型建立与求解</h3><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5pkoOcSjXOOFe.IeU*0YwH8viH9dh9qYZZrqbY1H9psNzTJADW6bEnpBzJGuWnR7Eo9Ly8.RngF*RmVXMsMDiLU!/b&amp;bo=2AEuAgAAAAADF8c!&amp;rf=viewer_4" alt=""></p><h4 id="评价类赛题建模">评价类赛题建模</h4><p>1、明确评价目的建立指标体系：具有代表性，确定性，独立性，区别能力。</p><p>2、对指标体系进行规范化处理 ：指标一致化处理、无量纲化处理。</p><p>3、确定指标体系对应权重系数：主观定权法和客观定权法。</p><p>4、选择或构造综合评价模型</p><h4 id="预测类赛题建模">预测类赛题建模</h4><p>1、对原始数据进行预处理（特征工程）：残缺值补全，异常值剔除</p><p>2、根据条件选择合适模型： 中短期长期预测，大小样本</p><p>3、对结果误差分析： 绝对误差分析，相对误差分析</p><p>4、给出预测结果，回答问题。</p><h4 id="优化类赛题建模">优化类赛题建模</h4><p>优化类问题通常求解目标一般用“最优”方式，使用或分配有限资源，将问题改换为数学模型要求确定问题的决策变量。构造合理的目标函数和定自变量允许的取值范围，常用<strong>不等式表示</strong></p><h4 id="对模型的改进">对模型的改进</h4><p>有的话非常优秀。对算法进行改进时难度较大的情况，会提高模型创新度，从而提得分。原则 改是为了更适用。</p><p><strong>一般对模型的改进出发点主要包括：</strong></p><p>1、原有模型有固有缺陷，影响效果</p><p>2、原有模型对现有问题不适用</p><p>3、原有模型太简单，内容较少</p><p><strong>对模型进行改进需要再论文撰写时：</strong></p><p>1、为什么要改进，改进的理由</p><p>2、如何进行改进的，改进的具体过程</p><p>3、改进效果如何；与未改进前做对比</p><p><strong>伪代码！！！</strong></p><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5rAk6AALhZlzJksPve.PkE8plC69iGWt9F24rV2d9DVnyOkMkgHSsxuqPrUEd6NIfB3Zk7hMGJFsRqKaMGS5SOE!/b&amp;bo=vgOFAgAAAAADNyg!&amp;rf=viewer_4" alt=""></p><p>常见的集成方案：</p><ul><li>基于层次分析-熵权法的综合评价模型（评价类赛题，定权更准确）</li><li>基于灰色-BP神经网络的综合预测模型（预测类赛题，小样本的预测）</li><li>基于遗传算法的BP神经网络优化算法（评价类、预测类赛题，精度更高）</li><li>基于小波变换-神经网络的预测模型（预测类赛题，大样本预测）</li></ul><h3 id="模型检验">模型检验</h3><p>稳定性与敏感性分析</p><p>统计检验与误差分析</p><p>新旧模型的对比</p><h3 id="模型优缺点评价">模型优缺点评价</h3><p>优点使劲吹，缺点不回避</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模型思路设计简介实用，效率高</span><br><span class="line">本文建立的模型具有很强创新性</span><br><span class="line">模型的计算结果准确，精度高</span><br><span class="line">模型考虑的系统全面，具有很强实用性</span><br><span class="line">对模型进行了各类检验，稳定性高</span><br><span class="line">模型本身优点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">受XX因素，未考虑XX情况，影响精度</span><br><span class="line">本文考虑因素较为理想，降低了模型普适性与推广能力</span><br><span class="line">系统考虑了XX因素，导致模型复杂，计算时间长，效率低</span><br><span class="line">模型本身缺点</span><br></pre></td></tr></table></figure><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5s1Dh.U4CSY9LuWe8MVoBG5ZXQkn6gklyVilmxYjOy.w2C7m01aU4o22Ibf*CnJ6PTl0tP66iSKb68JVcWlxKrI!/b&amp;bo=YwSRAgAAAAADR5Y!&amp;rf=viewer_4" alt=""></p><h3 id="参考文献">参考文献</h3><h4 id="引用范围">引用范围</h4><p>公开的资料，图书，期刊，网上的资料。等</p><p>参考文献列表：按正文中的引用次序列出</p><p>图书类：【编号】作者。书名【M】出版地：出版社，出版年</p><p>期刊、杂志类：【编号】作者。论文名【J】。杂志名，出版年，卷期号：起止页码</p><p>网络资料;[编号]作者，资源标题，网址，访问时间（年月日）</p><p>参考文献类型：</p><ul><li>专著【M】</li><li>会议论文集【C】</li><li>报纸文章【N】</li><li>期刊文章【J】</li><li>学位论文【D】</li><li>报告【R】</li><li>标准[S]</li><li>专利【P】</li></ul><p><img src="http://m.qpic.cn/psc?/V546geDp2QZW0L1vGz2K43S5DM3mjCJ4/ruAMsa53pVQWN7FLK88i5s1Dh.U4CSY9LuWe8MVoBG6F76cSUZ0jUyYlwHgjqq6ecMh1OqjpbvdnaedYu6bNbi1zFVFW5CGbHsoZKjk8GkE!/b&amp;bo=iwVdAwAAAAADB*I!&amp;rf=viewer_4" alt=""></p><h1>补充</h1><p>我们转本文，用第三人称。</p><p>灵敏度分析可不做。</p><p>假设（3~5个）。</p><p>模型》》》》》》求解，模型比求解重要。</p><p>参考文献的格式一定要稳健。</p><p>代码和数据可以用图片，降低查重。好看就行，美观</p><p>千万不要参考XX材料。</p><p>正文 20页左右</p><p>数据一定要放到附录！！！！！</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模套餐</title>
      <link href="/2022/09/08/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%A5%97%E9%A4%90/"/>
      <url>/2022/09/08/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%A5%97%E9%A4%90/</url>
      
        <content type="html"><![CDATA[<p>自己总结的一套数学建模套餐，可以帮助想入门数学建模的小伙伴们。</p><h1>数学建模套餐</h1><h2 id="一、相关资源">一、相关资源</h2><p><strong>网站类：</strong></p><p>1、<a href="http://www.mcm.edu.cn/">全国大学生数学建模竞赛 (mcm.edu.cn)</a></p><p>2、<a href="https://www.bilibili.com/video/BV1DW411s7wi?share_source=copy_web">清风建模bilibili</a></p><p>3、<a href="https://www.bilibili.com/video/BV1kC4y1a7Ee?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click">【零基础教程】老哥：数学建模算法、编程、写作和获奖指南全流程培训！_哔哩哔哩_bilibili</a></p><p>4、<a href="http://www.zhanshaoyi.com/">我爱分享网 | 分享知识，收获智慧 (zhanshaoyi.com)</a>(下载软件一个比较好的网站)</p><p>5、<a href="https://www.spsspro.com/">SPASS</a>（数据分析网站，上面也有一些基础算法的讲解）</p><p>6、简书/CSDN/知乎/谷歌（搜索资料类，拒绝百度！！！）</p><p>7、维基百科</p><p><strong>导航大全（收藏一个顶十个）</strong></p><p>1、科塔学术导航 - 最专业、准确、及时和全面的科研与学术资源导航平台 (<a href="http://sciping.com">sciping.com</a>)</p><p>2、编程导航 | 专注全网优质编程网址、优质编程学习资源分享。 (<a href="http://24kdh.cn">24kdh.cn</a>)</p><p>3、数字生活指南·社区 (guidebook.top)</p><p>4、国家部门导航 (<a href="http://dajiadaohang.com">dajiadaohang.com</a>)</p><p>5、大数据导航1 （bigdata.ren）</p><p>6、大数据工具导航（<a href="http://Hao.199it.com">Hao.199it.com</a>）</p><p>7、程序员的工具箱 （<a href="http://tool.lu">tool.lu</a>)</p><p><strong>数据收集</strong></p><p>1、全球数据库（<a href="http://ceicdata.com">ceicdata.com</a>）</p><p>2、国家数据 (<a href="http://stats.gov.cn">stats.gov.cn</a>)</p><p>3、CEIC：195个国家400多万个时间序列的数据源（<a href="http://ceicdata.com">ceicdata.com</a>）</p><p>4、搜数网 (<a href="http://soshoo.com">soshoo.com</a>)</p><p>5、中国互联网络信息中心 (<a href="http://cnnic.net.cn">cnnic.net.cn</a>)</p><p>6、全国地理信息资源目录服务系统 (<a href="http://webmap.cn">webmap.cn</a>)</p><p><strong>文献资料</strong></p><p>国内（免费的网站）</p><p>1、全国图书馆参考咨询联盟 (<a href="http://superlib.net">superlib.net</a>)</p><p>2、国家哲学社会科学文献中心 (<a href="http://ncpssd.org">ncpssd.org</a>)</p><p>3、中国科技论文在线-科技论文，开放存取 (<a href="http://paper.edu.cn">paper.edu.cn</a>)</p><p>4、上海科技创新资源数据中心 (<a href="http://sstir.cn">sstir.cn</a>)</p><p>国内（付费的网站）</p><p>1、中国知网 (<a href="http://cnki.net">cnki.net</a>)</p><p>2、万方数据知识服务平台 (<a href="http://wanfangdata.com.cn">wanfangdata.com.cn</a>)</p><p>国外（前4个免费）</p><p>1、免费的科技学术期刊（<a href="http://doaj.org">doaj.org</a>）</p><p>2、美国教育部赞助的网站，收录教育相关的期刊文献（<a href="http://eric.ed.gov">eric.ed.gov</a>）</p><p>3、7000余种期刊杂志免费获取（<a href="http://freefullpdf.com">freefullpdf.com</a>）</p><p>4、在线科学、技术、医学领域学术资源平台（<a href="http://link.springer.com">link.springer.com</a>）</p><p>5、Science | AAAS（<a href="http://www.science.org">www.science.org</a>）</p><p>6、Elsevier爱斯维尔数据库（<a href="http://www.sciencedirect.com">www.sciencedirect.com</a>）</p><p>7、国外医学常用数据库（<a href="http://www.wolterskluwer.com/en/solutions/ovid%EF%BC%89">www.wolterskluwer.com/en/solutions/ovid）</a></p><p><strong>书籍类：</strong></p><p>1、姜启源的《数学模型》</p><p>个人觉得对新手很友好，适合于大学生学习。也是数学系学数学模型的教材书。但是对数学建模只能起一个知识框架的作用。</p><p><img src="https://pic3.zhimg.com/v2-5c8b5f55fc66caed416f74e5895d5ce3_720w.jpg?source=b555e01d" alt="img"></p><p>(这本我也有，配套pdf也在)</p><p>2、卓金武的《MATLAB在数学建模中的应用》；</p><p><img src="https://tse1-mm.cn.bing.net/th/id/R-C.a57b79e3f85431a44eb8b1fb3bf895ad?rik=ZwwZl8Ysq6Zi4w&amp;riu=http%3a%2f%2fbooklibimg.kfzimg.com%2fdata%2fbook_lib_img_v2%2fisbn%2f0%2f93cd%2f93cd28691a74c99437d512aef5bb093c_0_0_0_0.jpg&amp;ehk=%2fDXZ%2fSyBLCvb7d2n1XGghB5gD6HGEi8U5QeOBxcFg%2bI%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt=""></p><p>(这本我也有，配套pdf也在)</p><p>3、《数学建模》</p><p><img src="https://img.alicdn.com/imgextra/i1/1049653664/TB1sK4NLXXXXXXxXXXXXXXXXXXX_!!0-item_pic.jpg_430x430q90.jpg" alt=""></p><p>(巧了，这本我也有！)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">书籍这类实在太多太多了，有一说一，现在互联网时代，查东西不如网上查来得快，但是书籍能给你带来强烈的安全感，喜欢书籍学习的可以入手以下几本书。</span><br></pre></td></tr></table></figure><p><strong>软件类：</strong></p><p>1、python：Anaconda</p><ul><li>Anaconda：python大礼包</li><li>jupyter notebook：实时操作比较适合数学建模</li><li>matplotlib:画图</li><li>pandas,numpy:数值分析，数值处理</li><li>tensorflow：深度学习框架</li><li>split - learn：机器学习神器</li></ul><p>2、matlab2020b：</p><p><a href="http://www.zhanshaoyi.com/15501.html">MATLAB 2020b中文破解版下载(附安装教程) | 我爱分享网 (zhanshaoyi.com)</a></p><p>3、lingo18.0破解版</p><p><a href="http://www.zhanshaoyi.com/14739.html">LINGO 18.0破解版64位下载|兼容WIN10 | 我爱分享网 (zhanshaoyi.com)</a></p><p>4、Typora（markdown编辑器）</p><p>[<a href="http://www.zhanshaoyi.com/11364.html">文本编辑器Typora中文版32/64位下载|兼容WIN10 | 我爱分享网 (zhanshaoyi.com)</a>](<a href="http://www.zhanshaoyi.com/11364.html">http://www.zhanshaoyi.com/11364.html</a>)</p><p>5、LateX</p><p><a href="https://blog.csdn.net/muzhicihe/article/details/80326090">LaTeX的下载安装及简易使用</a></p><p><a href="https://blog.csdn.net/SleepingEmperor/article/details/80394018">(115条消息) Win环境下LaTeX安装_SleepingEmperor的博客-CSDN博客_latex安装</a></p><h2 id="二、学习路线">二、学习路线</h2><p><a href="https://geminiplanet.cn/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/">数学建模算法汇总 | GeminiPlanet</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学习算法我觉得最重要的就是，你看到题目就能知道，woc，这道题用这个很合适。</span><br><span class="line">然后</span><br><span class="line">建模手根据数据提调整好该用啥，怎么用，把代码手搞明白。</span><br><span class="line">代码手掏出写好了的框架，测试建模效果如何。</span><br><span class="line">论文手则可以准备算法的原公式和数据解释表。</span><br><span class="line">这样大家都能很快的上手，不会浪费时间。</span><br></pre></td></tr></table></figure><h2 id="三、学习思路">三、学习思路</h2><p>大一大二小菜鸟，只能冲冲C题D题，也就是偏数据分析或者评价模型的题目。</p><p>有时候图画的好，语文功底好，就能冲个小省奖。至少也能把论文交上去，也算参与参与了。</p><p>计算机专业有个优势就是学python的人不少，而机电或信工专业，有大量人会matlab语法，他们可以成为代码手的中间力量。</p><p>但是无论如何，作为数学建模的参赛选手，你必须对基本的数学模型有一定的了解，这样你们才能在比赛前期，能有足够的能力讨论题目改用什么方法去做，论文的语言是否准确。</p><p>那怎么做到学习基本的数学模型呢，个人有个人的招数，不过我们不是数学专业的，我们学习的数学知识容易遗忘，我这边建议用做笔记的形式去学习。在比赛的时候，掏出自己的笔记，能够帮你快速进入状态。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex数学公式学习</title>
      <link href="/2022/09/08/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/08/Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>Latex数学公式学习</h1><h2 id="前言">前言</h2><ol><li>官方文档（英文）：<br>传送门：<a href="http://www.ctex.org/documents/packages/math/index.htm"><em>官方文档</em></a><br>网址：<code>http://www.ctex.org/documents/packages/math/index.htm</code></li><li>中文文档：<br>传送门：<a href="https://www.latexlive.com/help"><em>中文教程</em></a><br>网址：<code>https://www.latexlive.com/help</code></li><li>技巧：使用<a href="https://www.latexlive.com/"><em>在线LaTeX公式编辑器</em></a>，来生成LaTeX公式代码，然后复制到LaTeX编辑器（或Markdown编辑器）中，并在两边加上<code>$</code>或<code>$$</code>即可。<br>在线LaTeX公式编辑器网址：<code>https://www.latexlive.com/</code></li><li>插入公式<br>左对齐公式（行中公式）：<code>$数学公式$</code><br>居中公式（独立公式）：<code>$$数学公式$$</code><br>注意：使用<code>$</code>行中公式时，<code>数学公式</code>与<code>$</code>连接处不要有空格，否则公式不会显示；使用<code>$$</code>居中公式时，<code>数学公式</code>与<code>$$</code>连接处可以有空格。即<code>$ 数学公式 $</code> 不显示公式。</li><li>注释：<code>%</code>为单行注释。</li></ol><h2 id="注意事项">注意事项</h2><ol><li>使用<code>$</code>，即行中公式时，<code>数学公式</code>与<code>$</code>连接处不要有空格，否则公式不会显示。即<code>$ 数学公式 $</code> 不显示公式。</li><li>使用<code>$$</code>，即居中公式时，<code>数学公式</code>与<code>$$</code>连接处可以有空格。</li><li>使用<code>$$</code>时，上方要空一行。</li><li><code>=</code>不要单独打一行，否则可能会出错。</li><li><code>+ - * / = ( ) | , . '</code>等符号直接在<code>$</code>或<code>$$</code>之间输入即可识别。</li></ol><h2 id="插入公式">插入公式</h2><p>左对齐公式（行中公式）：<code>$数学公式$</code><br>居中公式（独立公式）：<code>$$数学公式$$</code></p><p><strong>注意：</strong> 注意事项请参照目录章节中的<strong>注意事项</strong>子章节。</p><p>左对齐例子：<code>$x+y=z$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x + y =z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></p><p>居中对齐例子：<code>$$x+y=z$$</code>($$后回车)</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y=z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></span></p><h2 id="注释">注释</h2><p><code>%</code>为单行注释。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">%第一个极限</span><br><span class="line">\lim_&#123;n \to +\infty&#125; \frac&#123;1&#125;&#123;n(n+1)&#125;</span><br><span class="line">\quad %空一格</span><br><span class="line">and %英文单词and</span><br><span class="line">\quad %空一格</span><br><span class="line">%第2个极限</span><br><span class="line">\lim_&#123;x\leftarrow&#123;example&#125; \infty&#125; \frac&#123;1&#125;&#123;n(n+1)&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>n</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mn>1</mn><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>x</mi><mo>←</mo><mrow><mi>e</mi><mi>x</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mn>1</mn><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">%第一个极限\lim_{n \to +\infty} \frac{1}{n(n+1)}\quad %空一格and %英文单词and\quad %空一格%第2个极限\lim_{x\leftarrow{example} \infty} \frac{1}{n(n+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2574em;vertical-align:-0.936em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7583em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">←</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">am</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal mtight">e</span></span><span class="mord mtight">∞</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8882em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="编号">编号</h2><p>在公式末尾使用<code>\tag&#123;编号&#125;</code>来实现公式手动编号，大括号内的内容可以自定义。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">x+y=z</span><br><span class="line">\tag&#123;1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>z</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">x+y=z\tag{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><h2 id="转义字符">转义字符</h2><p>在公式中输入<code>_</code>或<code>^</code>等符号时，会产生上下标功能，若想输入符号本身则需要转义字符<code>\</code>，写法为<code>\+字符</code>，示例如下：</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">% \ 为转义字符</span><br><span class="line">home\_name=honor</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>=</mo><mi>h</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">% \ 为转义字符home\_name=honor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span></span></span></span></span></p><h2 id="换行与对齐">换行与对齐</h2><h3 id="换行">换行</h3><p>使用<code>\\</code>进行换行，最后一行的<code>\\</code>可写可不写。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f(x)=2x+1 \\</span><br><span class="line">=2+1 \\</span><br><span class="line">=3</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mo>=</mo><mn>2</mn><mo>+</mo><mn>1</mn><mspace linebreak="newline"></mspace><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">f(x)=2x+1 \\=2+1 \\=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span></p><h3 id="对齐">对齐</h3><p>使用<code>\begin&#123;aligned&#125;</code>进行对齐，<code>&amp;</code>表示对齐位置，一般都在<code>=</code>前面。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">f(x)&amp;=2x+1 \\</span><br><span class="line">&amp;=2+1 \\</span><br><span class="line">&amp;=3</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}f(x)&amp;=2x+1 \\&amp;=2+1 \\&amp;=3\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="字体">字体</h2><p>若要对公式的某一部分字符进行字体转换，可以用 <code>\字体&#123;需转换的字符&#125;</code> 命令，其中 <code>\字体</code> 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体，直体为罗马体 <code>\rm</code>。一般里面一层大括号可省略。</p><p>注意：在LaTeX编辑器中，修改公式字体时，需要引入宏包<code>\usepackage&#123;amsmath&#125;</code>和<code>\usepackage&#123;amsfonts&#125;</code>，且在公式中输入。</p><table><thead><tr><th style="text-align:center">输入</th><th style="text-align:center">说明</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center">\mathit 或 \it</td><td style="text-align:center">斜体（默认，意大利体）</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">\mathit{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathit">D</span></span></span></span></td></tr><tr><td style="text-align:center">\mathrm 或 \rm</td><td style="text-align:center">罗马体</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">D</mi></mrow><annotation encoding="application/x-tex">\mathrm{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathrm">D</span></span></span></span></td></tr><tr><td style="text-align:center">\mathbf 或 \bf</td><td style="text-align:center">粗体</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">D</span></span></span></span></td></tr><tr><td style="text-align:center">\mathbb</td><td style="text-align:center">黑板粗体</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">D</mi></mrow><annotation encoding="application/x-tex">\mathbb{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">D</span></span></span></span></td></tr><tr><td style="text-align:center">\mathsf 或 \sf</td><td style="text-align:center">等线体</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="sans-serif">D</mi></mrow><annotation encoding="application/x-tex">\mathsf{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathsf">D</span></span></span></span></td></tr><tr><td style="text-align:center">\mathcal</td><td style="text-align:center">花体</td><td style="text-align:center">$\mathcal{D} $</td></tr><tr><td style="text-align:center">\mathscr</td><td style="text-align:center">手写体</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\mathscr{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7em;"></span><span class="mord mathscr" style="margin-right:0.09371em;">D</span></span></span></span></td></tr><tr><td style="text-align:center">\mathtt</td><td style="text-align:center">打字机体</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="monospace">D</mi></mrow><annotation encoding="application/x-tex">\mathtt{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em;"></span><span class="mord mathtt">D</span></span></span></span></td></tr><tr><td style="text-align:center">\mathfrak</td><td style="text-align:center">哥特体</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="fraktur">D</mi></mrow><annotation encoding="application/x-tex">\mathfrak{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6914em;"></span><span class="mord mathfrak">D</span></span></span></span></td></tr><tr><td style="text-align:center">\boldsymbol</td><td style="text-align:center">黑体</td><td style="text-align:center">D</td></tr></tbody></table><p>例子：<br><code>$$A+\mathbb&#123;BC&#125;+D$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>+</mo><mrow><mi mathvariant="double-struck">B</mi><mi mathvariant="double-struck">C</mi></mrow><mo>+</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A+\mathbb{BC}+D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7722em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbb">BC</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span></span></p><h2 id="空格">空格</h2><p><code>\quad</code>：空一格<br><code>\qquad</code>：空两格</p><p>例子：<br><code>$$x \quad y \qquad z$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mspace width="1em"/><mi>y</mi><mspace width="2em"/><mi>z</mi></mrow><annotation encoding="application/x-tex">x \quad y \qquad z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span></span></p><h2 id="上下标">上下标</h2><p><code>^</code>表示上标， <code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用 <code>&#123;&#125;</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</p><p>例子：<br><code>$$x^&#123;y^z_w&#125;=(1+&#123;\rm e&#125;^x)^&#123;-2xy^w&#125;$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>x</mi><msubsup><mi>y</mi><mi>w</mi><mi>z</mi></msubsup></msup><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi mathvariant="normal">e</mi><mi>x</mi></msup><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>2</mn><mi>x</mi><msup><mi>y</mi><mi>w</mi></msup></mrow></msup></mrow><annotation encoding="application/x-tex">x^{y^z_w}=(1+{\rm e}^x)^{-2xy^w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.214em;margin-left:-0.0359em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.18em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">e</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">x</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>上下标同时使用例子：<br><code>$$f(x) = x_1^2 + &#123;x&#125;_&#123;2&#125;^&#123;2&#125;$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">f(x) = x_1^2 + x_2^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="括号">括号</h2><p><code>()、[]、|</code>表示符号本身，使用 <code>\&#123;\&#125;</code> 来表示 {}。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令，如<code>$\left(表达式\right)$</code>，大号的括号详见下一节）。</p><p>一些特殊的括号：</p><table><thead><tr><th style="text-align:center">特殊括号</th><th style="text-align:center">输入</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center">尖括号</td><td style="text-align:center"><code> $\langle表达式\rangle$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mtext>表达式</mtext><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle表达式\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord cjk_fallback">表达式</span><span class="mclose">⟩</span></span></span></span></td></tr><tr><td style="text-align:center">向上取整</td><td style="text-align:center"><code> $\lceil表达式\rceil$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mtext>表达式</mtext><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil表达式\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord cjk_fallback">表达式</span><span class="mclose">⌉</span></span></span></span></td></tr><tr><td style="text-align:center">向下取整</td><td style="text-align:center"><code> $\lfloor表达式\rfloor$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mtext>表达式</mtext><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor表达式\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord cjk_fallback">表达式</span><span class="mclose">⌋</span></span></span></span></td></tr><tr><td style="text-align:center">大括号</td><td style="text-align:center"><code> $\lbrace表达式\rbrace$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mtext>表达式</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\lbrace表达式\rbrace</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord cjk_fallback">表达式</span><span class="mclose">}</span></span></span></span></td></tr></tbody></table><p>例子：</p><p><code> $$f(x,y,z) = 3y^2z \left( 3+\frac&#123;7x+5&#125;&#123;1+y^2&#125; \right)$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><msup><mi>y</mi><mn>2</mn></msup><mi>z</mi><mrow><mo fence="true">(</mo><mn>3</mn><mo>+</mo><mfrac><mrow><mn>7</mn><mi>x</mi><mo>+</mo><mn>5</mn></mrow><mrow><mn>1</mn><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><h2 id="大括号">大括号</h2><h4 id="方法1">方法1</h4><p>使用 <code>\left</code>和 <code>\right</code>来创建自动匹配高度的括号，包含 (圆括号)、[方括号]、|绝对值|。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f\left(</span><br><span class="line">   \left[</span><br><span class="line">     \frac&#123;</span><br><span class="line">       1+\left\&#123;x,y\right\&#125;</span><br><span class="line">     &#125;&#123;</span><br><span class="line">       \left(</span><br><span class="line">          \frac&#123;x&#125;&#123;y&#125;+\frac&#123;y&#125;&#123;x&#125;</span><br><span class="line">       \right)</span><br><span class="line">       \left(u+1\right)</span><br><span class="line">     &#125;+a</span><br><span class="line">   \right]^&#123;3/2&#125;</span><br><span class="line">\right)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mrow><mo fence="true">(</mo><msup><mrow><mo fence="true">[</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mrow><mo fence="true">{</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo fence="true">}</mo></mrow></mrow><mrow><mrow><mo fence="true">(</mo><mfrac><mi>x</mi><mi>y</mi></mfrac><mo>+</mo><mfrac><mi>y</mi><mi>x</mi></mfrac><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mi>u</mi><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow></mrow></mfrac><mo>+</mo><mi>a</mi><mo fence="true">]</mo></mrow><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">f\left(   \left[     \frac{       1+\left\{x,y\right\}     }{       \left(          \frac{x}{y}+\frac{y}{x}       \right)       \left(u+1\right)     }+a   \right]^{3/2}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.2em;vertical-align:-1.85em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-4.35em;"><span class="pstrut" style="height:6.2em;"></span><span style="width:0.875em;height:4.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='4.200em' viewBox='0 0 875 4200'><path d='M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,-36,557 l0,684c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189l0,-692c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v0 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span><span style="top:-3.38em;"><span class="pstrut" style="height:3.15em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.827em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">a</span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v0 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:2.3279em;"><span style="top:-4.5029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3/2</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-4.35em;"><span class="pstrut" style="height:6.2em;"></span><span style="width:0.875em;height:4.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='4.200em' viewBox='0 0 875 4200'><path d='M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,609c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558l0,-744c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>有时候要用<code>\left.</code>或<code>\right.</code>进行匹配而不显示本身。</p><p>例子：<br><code>$$\left. \frac&#123; &#123;\rm d&#125;u&#125;&#123; &#123;\rm d&#125;x&#125; \right| _&#123;x=0&#125;$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mfrac><mrow><mi mathvariant="normal">d</mi><mi>u</mi></mrow><mrow><mi mathvariant="normal">d</mi><mi>x</mi></mrow></mfrac><mo fence="true">∣</mo></mrow><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\left. \frac{ {\rm d}u}{ {\rm d}x} \right| _{x=0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4497em;vertical-align:-0.9997em;"></span><span class="minner"><span class="minner"><span class="mopen nulldelimiter"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathnormal">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.333em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='2.400em' viewBox='0 0 333 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.5486em;"><span style="top:-1.7003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9997em;"><span></span></span></span></span></span></span></span></span></span></span></p><h4 id="方法2">方法2</h4><p>使用<code>\big</code>和<code>\bigg</code>来创建逐级变大的括号，包含 (圆括号)、[方括号]、|绝对值|。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\bigg( \big( ( ) \big) \bigg)$$</span><br><span class="line">$$\bigg[ \big[ [ ] \big] \bigg]$$</span><br><span class="line">$$\bigg| \big| | | \big| \bigg|$$</span><br></pre></td></tr></table></figure><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">(</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">)</mo></mrow><annotation encoding="application/x-tex">\bigg( \big( ( ) \big) \bigg)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="delimsizing size3">(</span></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mord"><span class="delimsizing size3">)</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">[</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">[</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">]</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">]</mo></mrow><annotation encoding="application/x-tex">\bigg[ \big[ [ ] \big] \bigg]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="delimsizing size3">[</span></span><span class="mord"><span class="delimsizing size1">[</span></span><span class="mopen">[</span><span class="mclose">]</span><span class="mord"><span class="delimsizing size1">]</span></span><span class="mord"><span class="delimsizing size3">]</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">∣</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">∣</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">∣</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">∣</mo></mrow><annotation encoding="application/x-tex">\bigg| \big| | | \big| \bigg|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.333em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='2.400em' viewBox='0 0 333 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span><span class="mord">∣∣</span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.85em;"><span style="top:-2.85em;"><span class="pstrut" style="height:3.2em;"></span><span style="width:0.333em;height:1.200em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='1.200em' viewBox='0 0 333 1200'><path d='M145 15 v585 v0 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v0 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v0 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35em;"><span></span></span></span></span></span></span><span class="mord"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.333em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='2.400em' viewBox='0 0 333 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="分式">分式</h2><p>通常使用 <code>\frac &#123;分子&#125; &#123;分母&#125;</code> 命令产生一个分式，分式可嵌套。</p><p>便捷情况可直接输入 <code>\frac ab</code>来快速生成一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><p>如果分式很复杂，亦可使用 <code>分子 \over 分母</code> 命令，此时分式仅有一层。</p><p>例子：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><msub><mi>X</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><msub><mi>X</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>X</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">X = \frac {X- X_{min}} {X_{max} - X_{min}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1963em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><msub><mi>a</mi><mi>i</mi></msub><msub><mi>x</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">w = \frac {(\sum^{n}_{i=1}{a_ix_i)^2}}{\sum^n_{i=1}{(x_i-\overline{x})^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4978em;vertical-align:-0.994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5038em;"><span style="top:-2.3057em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6897em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><code> $$\frac&#123;a-1&#125;&#123;b-1&#125; \quad and \quad &#123;a+1\over b+1&#125;$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>b</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><mfrac><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>b</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p><h2 id="根式">根式</h2><p><code>\sqrt [根指数] &#123;被开方数&#125; </code></p><p>注意：缺省根指数时为2</p><p>例子：</p><p><code> $$\sqrt&#123;2&#125; \quad and \quad \sqrt[n]&#123;x+y&#125;$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msqrt><mn>2</mn></msqrt><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><mroot><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><mi>n</mi></mroot></mrow><annotation encoding="application/x-tex">\sqrt{2} \quad and \quad \sqrt[n]{x+y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1678em;vertical-align:-0.2117em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9561em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.9161em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.0839em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5853em;"><span style="top:-2.87em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8283em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.7883em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2117em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="对数">对数</h2><p><code> \log_&#123;对数底数&#125;&#123;表达式&#125;</code></p><p>表达式的大括号可省略</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\log_&#123;x+y&#125;&#123;(z+1)&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow></msub><mrow><mo stretchy="false">(</mo><mi>z</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\log_{x+y}{(z+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1302em;vertical-align:-0.3802em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1642em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3802em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span></p><h2 id="省略号">省略号</h2><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与文本底线对齐的横向省略号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.123em;"></span><span class="minner">…</span></span></span></span>,<code>\cdots</code></p><p>表示与文本中线对齐的横向省略号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.313em;"></span><span class="minner">⋯</span></span></span></span>,<code>\vdots</code>表示纵向省略号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow><annotation encoding="application/x-tex">\vdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.03em;"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span></span>,<code>\ddots</code>表示斜向省略号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋱</mo></mrow><annotation encoding="application/x-tex">\ddots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.823em;"></span><span class="minner">⋱</span></span></span></span></p><p>。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$f(x_1,x_2,\underbrace&#123;\ldots&#125;_&#123;\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \underbrace&#123;\cdots&#125;_&#123;\rm cdots&#125; + x_n^2$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><munder><munder><mo lspace="0em" rspace="0em">…</mo><mo stretchy="true">⏟</mo></munder><mrow><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi></mrow></munder><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>x</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>x</mi><mn>2</mn><mn>2</mn></msubsup><mo>+</mo><munder><munder><mo lspace="0em" rspace="0em">⋯</mo><mo stretchy="true">⏟</mo></munder><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">s</mi></mrow></munder><mo>+</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0841em;vertical-align:-1.3341em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.123em;"><span style="top:-1.6659em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">ldots</span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.123em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">…</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3341em;"><span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.9174em;vertical-align:-1.3341em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.313em;"><span style="top:-1.6659em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">cdots</span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.313em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3341em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="最值">最值</h2><p><code>\max_&#123;下标表达式&#125;&#123;最值表达式&#125;</code>表示最大值，<code>\min_&#123;下标表达式&#125;&#123;最值表达式&#125;</code>表达最小值。<br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$||x||_\infty=\max_&#123;1\leq i\leq n&#125;&#123;|x_i|&#125;$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∞</mi></msub><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></munder><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow></mrow><annotation encoding="application/x-tex">||x||_\infty=\max_{1\leq i\leq n}{|x_i|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal">x</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.5728em;vertical-align:-0.8228em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8228em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></span></span></p><h2 id="方程组和分段函数">方程组和分段函数</h2><h3 id="方程组">方程组</h3><p>方程组有2种方式，分别是<code>\begin&#123;aligned&#125;</code>和<code>\begin&#123;cases&#125;</code>方式，<code>&amp;</code>表示对齐位置，推荐使用<code>\begin&#123;cases&#125;</code>方式，使用方法如下：</p><p><code>\begin&#123;aligned&#125;</code>方式：可以使方程组根据<code>=</code>对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a+b454545&amp;=2 \\</span><br><span class="line">a-b&amp;=4 \\</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\right.</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mn>454545</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>4</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}a+b454545&amp;=2 \\a-b&amp;=4 \\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mord">454545</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><code>\begin&#123;cases&#125;</code>方式（推荐）：简便，但无法根据<code>=</code>对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">a+b4545=2 \\</span><br><span class="line">a-b=4 \\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mn>4545</mn><mo>=</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>a</mi><mo>−</mo><mi>b</mi><mo>=</mo><mn>4</mn></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}a+b4545=2 \\a-b=4 \\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mord">4545</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">2</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="分段函数">分段函数</h3><p>分段函数可以通过<code>\begin&#123;cases&#125;</code>方式实现，不同的是方程式和条件之间要用<code>&amp;</code>符号隔开。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">y =</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">\sin(x)       &amp; x&lt;0 \\</span><br><span class="line">x^2 + 2x +4   &amp; 0 \leq x &lt; 1 \\</span><br><span class="line">x^3           &amp; x \geq 1 \\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>4</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mn>3</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>x</mi><mo>≥</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">y =\begin{cases}\sin(x)       &amp; x&lt;0 \\x^2 + 2x +4   &amp; 0 \leq x &lt; 1 \\x^3           &amp; x \geq 1 \\\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">4</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="累加和累乘">累加和累乘</h2><p>使用 <code>\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125;&#123;累加表达式&#125;</code>来输入一个累加。<br>与之类似，使用 <code>\prod \bigcup \bigcap</code>来分别输入累乘、并集和交集。<br>此类符号在行内显示时上下标表达式将会移至右上角和右下角。</p><p>例子：<br><code>$$\sum_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125; \quad and \quad \prod_&#123;i=1&#125;^n \frac&#123;1&#125;&#123;i^2&#125; \quad and \quad \bigcup_&#123;i=1&#125;^&#123;2&#125; R$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><msup><mi>i</mi><mn>2</mn></msup></mfrac><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><msup><mi>i</mi><mn>2</mn></msup></mfrac><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><munderover><mo>⋃</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>2</mn></munderover><mi>R</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0788em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span></p><h2 id="矢量">矢量</h2><p>使用 <code>\vec&#123;矢量&#125;</code>来自动产生一个矢量。<br>也可以使用 <code>\overrightarrow</code>等命令自定义字母上方的符号。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;a&#125; \cdot \vec&#123;b&#125;=0\$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>a</mi><mo>⃗</mo></mover><mo>⋅</mo><mover accent="true"><mi>b</mi><mo>⃗</mo></mover><mo>=</mo><mn>0</mn><mtext> </mtext></mrow><annotation encoding="application/x-tex">\vec{a} \cdot \vec{b}=0\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9774em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9774em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">b</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace"> </span></span></span></span></span></p><p>例子：<br><code>$$\overleftarrow&#123;xy&#125; \quad and \quad \overleftrightarrow&#123;xy&#125; \quad and \quad \overrightarrow&#123;xy&#125;$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mrow><mi>x</mi><mi>y</mi></mrow><mo stretchy="true">←</mo></mover><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><mover accent="true"><mrow><mi>x</mi><mi>y</mi></mrow><mo stretchy="true">↔</mo></mover><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><mover accent="true"><mrow><mi>x</mi><mi>y</mi></mrow><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.147em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9526em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9526em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.522em;min-width:0.888em;"><span class="halfarrow-left" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span><span class="halfarrow-right" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9526em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="极限">极限</h2><p><code>\lim_&#123;变量 \to 表达式&#125; 表达式</code><br>如有需求，可以更改 \to 符号至任意符号。</p><p>例子：<br><code>$$\lim_&#123;n \to +\infty&#125; \frac&#123;1&#125;&#123;n(n+1)&#125; \quad and \quad \lim_&#123;x\leftarrow&#123;example&#125; \infty&#125; \frac&#123;1&#125;&#123;n(n+1)&#125;$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>n</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mn>1</mn><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mspace width="1em"/><mi>a</mi><mi>n</mi><mi>d</mi><mspace width="1em"/><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>x</mi><mo>←</mo><mrow><mi>e</mi><mi>x</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mn>1</mn><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{example} \infty} \frac{1}{n(n+1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.2574em;vertical-align:-0.936em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7583em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">←</span><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight">am</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal mtight">e</span></span><span class="mord mtight">∞</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8882em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="导数">导数</h2><h3 id="导数-2">导数</h3><p><code>$&#123;\rm d&#125;x$</code>或<code>$&#123;\text d&#125;x$</code>或<code>$\text&#123;d&#125;x$</code></p><p>$ {\rm d}x<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>或</mtext></mrow><annotation encoding="application/x-tex">或</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">或</span></span></span></span>{\text d}x<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>或</mtext></mrow><annotation encoding="application/x-tex">或</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">或</span></span></span></span>\text{d}x$</p><h3 id="偏导">偏导</h3><p><code>$\frac&#123;\partial y&#125;&#123;\partial x&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>x</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial y}{\partial x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2772em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h3 id="梯度">梯度</h3><p><code>$\nabla f(x)$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\nabla f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></p><h2 id="积分">积分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\int_积分下限^积分上限 &#123;被积表达式&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子：<br><code>$$\int_0^1 &#123;x^2&#125; \,&#123;\rm d&#125;x$$</code></p><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><msup><mi>x</mi><mn>2</mn></msup><mtext> </mtext><mi mathvariant="normal">d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_0^1 {x^2} \,{\rm d}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.476em;vertical-align:-0.9119em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.564em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">d</span></span></span><span class="mord mathnormal">x</span></span></span></span></span></p><h2 id="矩阵">矩阵</h2><h3 id="基础矩阵">基础矩阵</h3><p>使用<code>\begin&#123;matrix&#125;…\end&#123;matrix&#125;</code> 这样的形式来表示矩阵，在<code>\begin</code> 与<code>\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code> 分隔，<code>\\</code>表示换行，列之间使用<code>&amp;</code> 分隔，<code>&amp;</code>表示对齐位置。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; x &amp; x^2 \\</span><br><span class="line">1 &amp; y &amp; y^2 \\</span><br><span class="line">1 &amp; z &amp; z^2 \\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>z</mi><mn>2</mn></msup></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h3 id="带括号的矩阵">带括号的矩阵</h3><p><strong>使用\left 与\right 表示括号</strong></p><p>如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code> 与<code>\right</code> 配合表示括号符号。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; x &amp; x^2 \\</span><br><span class="line">1 &amp; y &amp; y^2 \\</span><br><span class="line">1 &amp; z &amp; z^2 \\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>z</mi><mn>2</mn></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84H403z M403 1759 V0 H319 V1759 v0 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.667em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347zM347 1759 V0 H263 V1759 v0 v1759 h84z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><strong>使用特殊的matrix</strong></p><p>带括号的矩阵也可以使用特殊的<code>matrix</code> 。即替换<code>\begin&#123;matrix&#125;…\end&#123;matrix&#125;</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p><ol><li><p>pmatrix：<code>$\begin&#123;pmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;pmatrix&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></p></li><li><p>bmatrix：<code>$\begin&#123;bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;bmatrix&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></p></li><li><p>Bmatrix：<code>$\begin&#123;Bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Bmatrix&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow><annotation encoding="application/x-tex">\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">}</span></span></span></span></span></span></p></li><li><p>vmatrix：<code>$\begin&#123;vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;vmatrix&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">∣</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.333em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='2.400em' viewBox='0 0 333 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.333em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='2.400em' viewBox='0 0 333 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>Vmatrix：<code>$\begin&#123;Vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Vmatrix&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">∥</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr></mtable><mo fence="true">∥</mo></mrow><annotation encoding="application/x-tex">\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.556em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.556em' height='2.400em' viewBox='0 0 556 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43zM367 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:4.4em;"></span><span style="width:0.556em;height:2.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.556em' height='2.400em' viewBox='0 0 556 2400'><path d='M145 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v1200 v585 h43zM367 15 v585 v1200 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-1200 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v1200 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span></span></span></p></li></ol><h2 id="行列式">行列式</h2><p>方法已经在上一节<strong>带括号的矩阵</strong>中有所介绍，此处只写一个例子。</p><p>例子1：使用<code>\left</code> 与<code>\right</code> 表示括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left|</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; x &amp; x^2 \\</span><br><span class="line">1 &amp; y &amp; y^2 \\</span><br><span class="line">1 &amp; z &amp; z^2 \\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right|</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">∣</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>z</mi><mn>2</mn></msup></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\left|\begin{matrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{matrix}\right|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.333em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='3.600em' viewBox='0 0 333 3600'><path d='M145 15 v585 v2400 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-2400 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v2400 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.333em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='3.600em' viewBox='0 0 333 3600'><path d='M145 15 v585 v2400 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-2400 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v2400 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>例子2：使用特殊的<code>matrix</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line">1 &amp; x &amp; x^2 \\</span><br><span class="line">1 &amp; y &amp; y^2 \\</span><br><span class="line">1 &amp; z &amp; z^2 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">∣</mo><mtable rowspacing="0.16em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>x</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>y</mi><mn>2</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mi>z</mi><mn>2</mn></msup></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\begin{vmatrix}1 &amp; x &amp; x^2 \\1 &amp; y &amp; y^2 \\1 &amp; z &amp; z^2 \\\end{vmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.333em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='3.600em' viewBox='0 0 333 3600'><path d='M145 15 v585 v2400 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-2400 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v2400 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.05em;"><span class="pstrut" style="height:5.6em;"></span><span style="width:0.333em;height:3.600em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.333em' height='3.600em' viewBox='0 0 333 3600'><path d='M145 15 v585 v2400 v585 c2.667,10,9.667,15,21,15c10,0,16.667,-5,20,-15 v-585 v-2400 v-585 c-2.667,-10,-9.667,-15,-21,-15c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v2400 v585 h43z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="元素省略的矩阵">元素省略的矩阵</h2><p>可以使用<code>\cdots</code>:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.313em;"></span><span class="minner">⋯</span></span></span></span>,<code>\ddots</code>:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋱</mo></mrow><annotation encoding="application/x-tex">\ddots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.823em;"></span><span class="minner">⋱</span></span></span></span>,<code>\vdots</code>:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mrow><annotation encoding="application/x-tex">\vdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.03em;"></span><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span></span>,来省略矩阵中的元素。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;pmatrix&#125;</span><br><span class="line">1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\</span><br><span class="line">1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\</span><br><span class="line">\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line">1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\</span><br><span class="line">\end&#123;pmatrix&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>a</mi><mn>1</mn><mn>2</mn></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>a</mi><mn>1</mn><mi>n</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>a</mi><mn>2</mn><mn>2</mn></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>a</mi><mn>2</mn><mi>n</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>a</mi><mi>m</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>a</mi><mi>m</mi><mn>2</mn></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>a</mi><mi>m</mi><mi>n</mi></msubsup></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\begin{pmatrix}1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.46em;vertical-align:-2.48em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.875em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='5.400em' viewBox='0 0 875 5400'><path d='M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,-36,557 l0,1884c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189l0,-1892c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.58em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.38em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.98em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.48em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.95em;"><span style="top:-4.95em;"><span class="pstrut" style="height:7.4em;"></span><span style="width:0.875em;height:5.400em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='5.400em' viewBox='0 0 875 5400'><path d='M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,1809c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558l0,-1944c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.45em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="增广矩阵">增广矩阵</h2><p>增广矩阵需要使用前面的表格中使用到的<code>\begin&#123;array&#125; ... \end&#123;array&#125;</code> 来实现。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[  \begin&#123;array&#125;  &#123;c c | c&#125; %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线</span><br><span class="line">1 &amp; 2 &amp; 3 \\</span><br><span class="line">\hline %插入横线，如果去掉\hline就是增广矩阵</span><br><span class="line">4 &amp; 5 &amp; 6</span><br><span class="line">\end&#123;array&#125;  \right]</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center" columnlines="none solid" columnspacing="1em" rowlines="solid"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[  \begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线1 &amp; 2 &amp; 3 \\\hline %插入横线，如果去掉\hline就是增广矩阵4 &amp; 5 &amp; 6\end{array}  \right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="vertical-separator" style="height:2.4em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-0.95em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span style="top:-3.7em;"><span class="pstrut" style="height:3.45em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p><h2 id="表格">表格</h2><p>使用<code>\begin&#123;array&#125;&#123;列样式&#125;…\end&#123;array&#125;</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\hline</code> 在本行前加入一条直线。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\</span><br><span class="line">\hline</span><br><span class="line">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span><br><span class="line">2 &amp; -1 &amp; 189 &amp; -8 \\</span><br><span class="line">3 &amp; -20 &amp; 2000 &amp; 1+10i \\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="center left center right" columnlines="solid none none" columnspacing="1em" rowlines="solid none none"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>n</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Left</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Center</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>Right</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.24</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>125</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>189</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>8</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>20</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2000</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>+</mo><mn>10</mn><mi>i</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{c|lcr}n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\2 &amp; -1 &amp; 189 &amp; -8 \\3 &amp; -20 &amp; 2000 &amp; 1+10i \\\end{array}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.8em;vertical-align:-2.15em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.65em;"><span class="pstrut" style="height:4.65em;"></span><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="vertical-separator" style="height:4.8em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-2.15em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">Left</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0.24</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">20</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">Center</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">189</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2000</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65em;"><span style="top:-4.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">Right</span></span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">125</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">8</span></span></span><span style="top:-1.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">10</span><span class="mord mathnormal">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span style="top:-6.1em;"><span class="pstrut" style="height:4.65em;"></span><span class="hline" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="希腊字母">希腊字母</h2><p>输入 <code>\小写希腊字母英文全称</code>和<code>\首字母大写希腊字母英文全称</code>来分别输入小写和大写希腊字母。<br>对于大写希腊字母与现有字母相同的，直接输入大写字母即可。</p><table><thead><tr><th style="text-align:center">输入</th><th style="text-align:center">显示</th><th style="text-align:center">输入</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center"><code>$\alpha$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></td><td style="text-align:center"><code>$A$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\beta$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></td><td style="text-align:center"><code>$B$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\gamma$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span></td><td style="text-align:center"><code>$\Gamma$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Γ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\delta$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span></span></span></span></td><td style="text-align:center"><code>$\Delta$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Δ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\epsilon$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></td><td style="text-align:center"><code>$E$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\zeta$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ζ</mi></mrow><annotation encoding="application/x-tex">\zeta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07378em;">ζ</span></span></span></span></td><td style="text-align:center"><code>$Z$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\eta$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span></td><td style="text-align:center"><code>$H$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\theta$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span></td><td style="text-align:center"><code>$\Theta$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Θ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\iota$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ι</span></span></span></span></td><td style="text-align:center"><code>$I$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\kappa$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span></span></span></span></td><td style="text-align:center"><code>$K$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\nu$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi></mrow><annotation encoding="application/x-tex">\nu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.06366em;">ν</span></span></span></span></td><td style="text-align:center"><code>$N$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\mu$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span></span></span></span></td><td style="text-align:center"><code>$M$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\xi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span></span></span></span></td><td style="text-align:center"><code>$\Xi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ξ</mi></mrow><annotation encoding="application/x-tex">\Xi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ξ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$o$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">o</span></span></span></span></td><td style="text-align:center"><code>$O$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>`</td></tr><tr><td style="text-align:center"><code>$\pi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span></td><td style="text-align:center"><code>$\Pi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Π</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\rho$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span></td><td style="text-align:center"><code>$P$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\sigma$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span></td><td style="text-align:center"><code>$\Sigma$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\tau$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span></span></span></span></td><td style="text-align:center"><code>$T$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\upsilon$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>υ</mi></mrow><annotation encoding="application/x-tex">\upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">υ</span></span></span></span></td><td style="text-align:center"><code>$\Upsilon$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Υ</mi></mrow><annotation encoding="application/x-tex">\Upsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Υ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\phi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span></td><td style="text-align:center"><code>$\Phi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Φ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\chi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi></mrow><annotation encoding="application/x-tex">\chi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">χ</span></span></span></span></td><td style="text-align:center"><code>$X$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\psi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi></mrow><annotation encoding="application/x-tex">\psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span></span></span></span></td><td style="text-align:center"><code>$\Psi$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ψ</mi></mrow><annotation encoding="application/x-tex">\Psi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ψ</span></span></span></span></td></tr><tr><td style="text-align:center"><code>$\omega$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span></td><td style="text-align:center"><code>$\Omega$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="黑板粗体（空心字母）">黑板粗体（空心字母）</h2><p>空心字母属于一种字体，官方名称为黑板粗体，仅对大写字母起作用。若使用LaTeX编辑器，使用前需要在导言区引入宏包<code>\usepackage&#123;amsfonts&#125;</code>，并在公式中修改字体。</p><p>使用<code>$\mathbb&#123;字母&#125;$</code>即可使用空心字母，下方示例仅展示3个字母（M，R，L），其它字母同理。</p><table><thead><tr><th style="text-align:center">大写字母</th><th style="text-align:center">公式语言</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">M</mi></mrow><annotation encoding="application/x-tex">\mathbb{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">M</span></span></span></span></td><td style="text-align:center"><code>$\mathbb&#123;M&#125;$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></td><td style="text-align:center"><code>$\mathbb&#123;R&#125;$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">L</mi></mrow><annotation encoding="application/x-tex">\mathbb{L}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">L</span></span></span></span></td><td style="text-align:center"><code>$\mathbb&#123;L&#125;$</code></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h2 id="运算符">运算符</h2><p>对于加减除，对应键盘上便可打出来，但是对于乘法，键盘上没有这个符号，所以我们应该输入 <code>\times</code> 来显示一个  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 号</p><h3 id="关系运算符">关系运算符</h3><table><thead><tr><th style="text-align:center">关系运算符</th><th style="text-align:center">公式语言</th><th style="text-align:center">集合运算符</th><th style="text-align:center">公式语言</th><th style="text-align:center">对数运算符</th><th style="text-align:center">公式语言</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo></mrow><annotation encoding="application/x-tex">\pm</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">±</span></span></span></span></td><td style="text-align:center"><code>$\pm$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">∅</span></span></span></span></td><td style="text-align:center"><code>$\emptyset$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span></td><td style="text-align:center"><code>$\log$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span></td><td style="text-align:center"><code>$\times$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span></td><td style="text-align:center"><code>$\in$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lg</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\lg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span></span></span></span></td><td style="text-align:center"><code>$\lg$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">÷</span></span></span></span></td><td style="text-align:center"><code>$\div$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span></span></span></span></td><td style="text-align:center"><code>$\notin$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ln</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\ln</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">ln</span></span></span></span></td><td style="text-align:center"><code>$\ln$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo></mrow><annotation encoding="application/x-tex">\mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span></td><td style="text-align:center"><code>$\mid$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊂</mo></mrow><annotation encoding="application/x-tex">\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span></td><td style="text-align:center"><code>$\subset$</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∤</mo></mrow><annotation encoding="application/x-tex">\nmid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9925em;vertical-align:-0.2514em;"></span><span class="mrel amsrm">∤</span></span></span></span></td><td style="text-align:center"><code>$\nmid$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊃</mo></mrow><annotation encoding="application/x-tex">\supset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊃</span></span></span></span></td><td style="text-align:center"><code>$\supset$</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span></td><td style="text-align:center"><code>$\cdot$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span></td><td style="text-align:center"><code>$\subseteq$</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∘</mo></mrow><annotation encoding="application/x-tex">\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∘</span></span></span></span></td><td style="text-align:center"><code>$\circ$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊇</mo></mrow><annotation encoding="application/x-tex">\supseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊇</span></span></span></span></td><td style="text-align:center"><code>$\supseteq$</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">\ast</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">∗</span></span></span></span></td><td style="text-align:center"><code>$\ast$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span></td><td style="text-align:center"><code>$\cap$</code>(可加前缀big)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊙</mo></mrow><annotation encoding="application/x-tex">\odot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊙</span></span></span></span></td><td style="text-align:center"><code>$\odot$</code>(可加前缀big)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∪</span></span></span></span></td><td style="text-align:center"><code>$\cup$</code>(可加前缀big)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding="application/x-tex">\otimes</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊗</span></span></span></span></td><td style="text-align:center"><code>$\otimes$</code>(可加前缀big)</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\vee</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span></td><td style="text-align:center"><code>$\vee$</code>(可加前缀big)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding="application/x-tex">\oplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">⊕</span></span></span></span></td><td style="text-align:center"><code>$\oplus$</code>(可加前缀big)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo></mrow><annotation encoding="application/x-tex">\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span></span></span></span></td><td style="text-align:center"><code>$\leq$</code> 或 <code>$\le$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span></td><td style="text-align:center"><code>$\wedge$</code>(可加前缀big)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span></td><td style="text-align:center"><code>$\geq$</code> 或 <code>$\ge$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊎</mo></mrow><annotation encoding="application/x-tex">\uplus</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">⊎</span></span></span></span></td><td style="text-align:center"><code>$\uplus$</code>(可加前缀big)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span></td><td style="text-align:center"><code>$\neq$</code> 或 <code>$\ne$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding="application/x-tex">\sqcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">⊔</span></span></span></span></td><td style="text-align:center"><code>$\sqcup$</code>(可加前缀big)</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∼</mo></mrow><annotation encoding="application/x-tex">\sim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">∼</span></span></span></span></td><td style="text-align:center"><code>$\sim$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∽</mo></mrow><annotation encoding="application/x-tex">\backsim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3779em;"></span><span class="mrel amsrm">∽</span></span></span></span></td><td style="text-align:center"><code>$\backsim$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≃</mo></mrow><annotation encoding="application/x-tex">\simeq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mrel">≃</span></span></span></span></td><td style="text-align:center"><code>$\simeq$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≅</mo></mrow><annotation encoding="application/x-tex">\cong</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.589em;"></span><span class="mrel">≅</span></span></span></span></td><td style="text-align:center"><code>$\cong$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mrel">≈</span></span></span></span></td><td style="text-align:center"><code>$\approx$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mrel">≡</span></span></span></span></td><td style="text-align:center"><code>$\equiv$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≪</mo></mrow><annotation encoding="application/x-tex">\ll</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">≪</span></span></span></span></td><td style="text-align:center"><code>$\ll$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≫</mo></mrow><annotation encoding="application/x-tex">\gg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">≫</span></span></span></span></td><td style="text-align:center"><code>$\gg$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span></span></span></span></td><td style="text-align:center"><code>$\sum$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span></td><td style="text-align:center"><code>$\prod$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∐</mo></mrow><annotation encoding="application/x-tex">\coprod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∐</span></span></span></span></td><td style="text-align:center"><code>$\coprod$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≺</mo></mrow><annotation encoding="application/x-tex">\prec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">≺</span></span></span></span></td><td style="text-align:center"><code>$\prec$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⪯</mo></mrow><annotation encoding="application/x-tex">\preceq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⪯</span></span></span></span></td><td style="text-align:center"><code>$\preceq$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≻</mo></mrow><annotation encoding="application/x-tex">\succ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">≻</span></span></span></span></td><td style="text-align:center"><code>$\succ$</code></td><td style="text-align:center"></td><td style="text-align:center">+,−,∗,/,&lt;,&gt;,=</td><td style="text-align:center"><code>$+, -, *, /, &lt;, &gt;, =$</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⪰</mo></mrow><annotation encoding="application/x-tex">\succeq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⪰</span></span></span></span></td><td style="text-align:center"><code>$\succeq$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>其中，部分公式添加前缀<code>big</code>可以放大，删掉<code>big</code>前缀即为正常大小。</p><p>例如，<code>$\odot$</code>为$ \odot<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">，`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord cjk_fallback">，</span><span class="mord">‘</span></span></span></span>\bigodot$`为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⨀</mo></mrow><annotation encoding="application/x-tex">\bigodot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">⨀</span></span></span></span>。</p><h3 id="三角运算符">三角运算符</h3><table><thead><tr><th style="text-align:center">三角运算符</th><th style="text-align:center">公式语言</th><th style="text-align:center">微积分运算符</th><th style="text-align:center">公式语言</th><th style="text-align:center">逻辑运算符</th><th style="text-align:center">公式语言</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">⊥</mi></mrow><annotation encoding="application/x-tex">\bot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">⊥</span></span></span></span></td><td style="text-align:center"><code>$\bot$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">′</mo></mrow><annotation encoding="application/x-tex">\prime</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">′</span></span></span></span></td><td style="text-align:center"><code>$\prime$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∵</mo></mrow><annotation encoding="application/x-tex">\because</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∵</span></span></span></span></td><td style="text-align:center"><code>$\because$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∠</mi></mrow><annotation encoding="application/x-tex">\angle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mord">∠</span></span></span></span></td><td style="text-align:center"><code>$\angle$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∫</mo></mrow><annotation encoding="application/x-tex">\int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span></span></span></span></td><td style="text-align:center"><code>$\int$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∴</mo></mrow><annotation encoding="application/x-tex">\therefore</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6922em;"></span><span class="mrel amsrm">∴</span></span></span></span></td><td style="text-align:center"><code>$\therefore$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mn>0</mn><mo>∘</mo></msup></mrow><annotation encoding="application/x-tex">30^\circ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6741em;"></span><span class="mord">3</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6741em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∘</span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><code>$30^\circ$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∬</mo></mrow><annotation encoding="application/x-tex">\iint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005em;">∬</span></span></span></span></td><td style="text-align:center"><code>$\iint$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∀</span></span></span></span></td><td style="text-align:center"><code>$\forall$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\sin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mop">sin</span></span></span></span></td><td style="text-align:center"><code>$\sin$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∭</mo></mrow><annotation encoding="application/x-tex">\iiint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.111em;vertical-align:-0.306em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005em;">∭</span></span></span></span></td><td style="text-align:center"><code>$\iiint$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∃</span></span></span></span></td><td style="text-align:center"><code>$\exists$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cos</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\cos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mop">cos</span></span></span></span></td><td style="text-align:center"><code>$\cos$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∮</mo></mrow><annotation encoding="application/x-tex">\oint</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.3061em;"></span><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∮</span></span></span></span></td><td style="text-align:center"><code>$\oint$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≠</mo></mrow><annotation encoding="application/x-tex">\not=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span></span></span></span></td><td style="text-align:center"><code>$\not=$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>tan</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\tan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mop">tan</span></span></span></span></td><td style="text-align:center"><code>$\tan$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>lim</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\lim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">lim</span></span></span></span></td><td style="text-align:center"><code>$\lim$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;̸</mo></mrow><annotation encoding="application/x-tex">\not&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span></span></span></td><td style="text-align:center"><code>$\not&gt;$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>cot</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\cot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mop">cot</span></span></span></span></td><td style="text-align:center"><code>$\cot$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></td><td style="text-align:center"><code>$\infty$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊄</mo></mrow><annotation encoding="application/x-tex">\not\subset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">⊂</span></span></span></span></td><td style="text-align:center"><code>$\not\subset$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sec</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\sec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mop">sec</span></span></span></span></td><td style="text-align:center"><code>$\sec$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi></mrow><annotation encoding="application/x-tex">\nabla</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">∇</span></span></span></span></td><td style="text-align:center"><code>$\nabla$</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span></span></span></span></td><td style="text-align:center"><code>$\neg$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>csc</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\csc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mop">csc</span></span></span></span></td><td style="text-align:center"><code>$\csc$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4831em;"></span><span class="mrel">≈</span></span></span></span></td><td style="text-align:center"><code>$\approx$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>△</mo></mrow><annotation encoding="application/x-tex">\bigtriangleup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">△</span></span></span></span></td><td style="text-align:center"><code>$\bigtriangleup$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>▽</mo></mrow><annotation encoding="application/x-tex">\bigtriangledown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">▽</span></span></span></span></td><td style="text-align:center"><code>$\bigtriangledown$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>◃</mo></mrow><annotation encoding="application/x-tex">\triangleleft</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">◃</span></span></span></span></td><td style="text-align:center"><code>$\triangleleft$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>▹</mo></mrow><annotation encoding="application/x-tex">\triangleright</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord">▹</span></span></span></span></td><td style="text-align:center"><code>$\triangleright$</code></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="箭头运算符">箭头运算符</h3><table><thead><tr><th style="text-align:center">箭头符号</th><th style="text-align:center">公式语言</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↑</mo></mrow><annotation encoding="application/x-tex">\uparrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↑</span></span></span></span></td><td style="text-align:center"><code>$\uparrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↓</mo></mrow><annotation encoding="application/x-tex">\downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↓</span></span></span></span></td><td style="text-align:center"><code>$\downarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↕</mo></mrow><annotation encoding="application/x-tex">\updownarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">↕</span></span></span></span></td><td style="text-align:center"><code>$\updownarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇑</mo></mrow><annotation encoding="application/x-tex">\Uparrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">⇑</span></span></span></span></td><td style="text-align:center"><code>$\Uparrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇓</mo></mrow><annotation encoding="application/x-tex">\Downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">⇓</span></span></span></span></td><td style="text-align:center"><code>$\Downarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇕</mo></mrow><annotation encoding="application/x-tex">\Updownarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">⇕</span></span></span></span></td><td style="text-align:center"><code>$\Updownarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></td><td style="text-align:center"><code>$\rightarrow$</code> 或 <code>$\to$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span></td><td style="text-align:center"><code>$\leftarrow$</code> 或 <code>$\gets$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">↔</span></span></span></span></td><td style="text-align:center"><code>$\leftrightarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span></td><td style="text-align:center"><code>$\Rightarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇐</mo></mrow><annotation encoding="application/x-tex">\Leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇐</span></span></span></span></td><td style="text-align:center"><code>$\Leftarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇔</mo></mrow><annotation encoding="application/x-tex">\Leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇔</span></span></span></span></td><td style="text-align:center"><code>$\Leftrightarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟶</mo></mrow><annotation encoding="application/x-tex">\longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟶</span></span></span></span></td><td style="text-align:center"><code>$\longrightarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟵</mo></mrow><annotation encoding="application/x-tex">\longleftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟵</span></span></span></span></td><td style="text-align:center"><code>$\longleftarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟹</mo></mrow><annotation encoding="application/x-tex">\Longrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟹</span></span></span></span></td><td style="text-align:center"><code>$\Longrightarrow$</code> 或 <code>$\implies$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟸</mo></mrow><annotation encoding="application/x-tex">\Longleftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟸</span></span></span></span></td><td style="text-align:center"><code>$\Longleftarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟺</mo></mrow><annotation encoding="application/x-tex">\Longleftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mrel">⟺</span></span></span></span></td><td style="text-align:center"><code>$\Longleftrightarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇀</mo></mrow><annotation encoding="application/x-tex">\rightharpoonup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇀</span></span></span></span></td><td style="text-align:center"><code>$\rightharpoonup$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↼</mo></mrow><annotation encoding="application/x-tex">\leftharpoonup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">↼</span></span></span></span></td><td style="text-align:center"><code>$\leftharpoonup$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇁</mo></mrow><annotation encoding="application/x-tex">\rightharpoondown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇁</span></span></span></span></td><td style="text-align:center"><code>$\rightharpoondown$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↽</mo></mrow><annotation encoding="application/x-tex">\leftharpoondown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">↽</span></span></span></span></td><td style="text-align:center"><code>$\leftharpoondown$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↙</mo></mrow><annotation encoding="application/x-tex">\swarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↙</span></span></span></span></td><td style="text-align:center"><code>$\swarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↗</mo></mrow><annotation encoding="application/x-tex">\nearrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↗</span></span></span></span></td><td style="text-align:center"><code>$\nearrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↖</mo></mrow><annotation encoding="application/x-tex">\nwarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↖</span></span></span></span></td><td style="text-align:center"><code>$\nwarrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↘</mo></mrow><annotation encoding="application/x-tex">\searrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↘</span></span></span></span></td><td style="text-align:center"><code>$\searrow$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↦</mo></mrow><annotation encoding="application/x-tex">\mapsto</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">↦</span></span></span></span></td><td style="text-align:center"><code>$\mapsto$</code></td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⟼</mo></mrow><annotation encoding="application/x-tex">\longmapsto</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mrel">⟼</span></span></span></span></td><td style="text-align:center"><code>$\longmapsto$</code></td></tr></tbody></table><h2 id="离散数学符号">离散数学符号</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">公式</th><th style="text-align:center">名称</th></tr></thead><tbody><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span></span></span></span></td><td style="text-align:center"><code>$\neg$</code></td><td style="text-align:center">非</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span></td><td style="text-align:center"><code>$\wedge$</code></td><td style="text-align:center">合取，且</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\vee</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span></td><td style="text-align:center"><code>$\vee$</code></td><td style="text-align:center">析取，或</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span></td><td style="text-align:center"><code>$\rightarrow$</code></td><td style="text-align:center">充分条件</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span></td><td style="text-align:center"><code>$\leftarrow$</code></td><td style="text-align:center">必要条件</td></tr><tr><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>↔</mo></mrow><annotation encoding="application/x-tex">\leftrightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">↔</span></span></span></span></td><td style="text-align:center"><code>$\leftrightarrow$</code></td><td style="text-align:center">充要条件</td></tr></tbody></table><h2 id="戴帽符号（各种帽子）">戴帽符号（各种帽子）</h2><table><thead><tr><th>戴帽符号</th><th>公式语言</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9468em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></td><td><code>$\hat&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">^</mo></mover></mrow><annotation encoding="application/x-tex">\widehat{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9233em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9233em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="width:calc(100% - 0.2778em);margin-left:0.2778em;top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.24em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.24em' viewBox='0 0 1062 239' preserveAspectRatio='none'><path d='M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z'/></svg></span></span></span></span></span></span></span></span></span></td><td><code>$\widehat&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>ˇ</mo></mover></mrow><annotation encoding="application/x-tex">\check{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8808em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8808em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">ˇ</span></span></span></span></span></span></span></span></span></span></td><td><code>$\check&#123;A&#125;$</code></td></tr><tr><td><em>A</em></td><td><code>$\widecheck&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>˘</mo></mover></mrow><annotation encoding="application/x-tex">\breve{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9468em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9468em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˘</span></span></span></span></span></span></span></span></span></span></td><td><code>$\breve&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9202em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9202em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span style="top:-3.6023em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">~</span></span></span></span></span></span></span></span></span></span></td><td><code>$\tilde&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9433em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9433em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="width:calc(100% - 0.2778em);margin-left:0.2778em;top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span></td><td><code>$\widetilde&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></td><td><code>$\overline&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder accentunder="true"><mi>A</mi><mo stretchy="true">‾</mo></munder></mrow><annotation encoding="application/x-tex">\underline{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;vertical-align:-0.2em;"></span><span class="mord underline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span style="top:-2.84em;"><span class="pstrut" style="height:3em;"></span><span class="underline-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span></td><td><code>$\underline&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">←</mo></mover></mrow><annotation encoding="application/x-tex">\overleftarrow{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2053em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMinYMin slice'><path d='M400000 241H110l3-3c68.7-52.7 113.7-120 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202 l-3-3h399890zM100 241v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span></td><td><code>$\overleftarrow&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>A</mi><mo stretchy="true">→</mo></mover></mrow><annotation encoding="application/x-tex">\overrightarrow{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2053em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2053em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">A</span></span><span class="svg-align" style="top:-3.6833em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="height:0.522em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span></span></span></span></span></span></span></td><td><code>$\overrightarrow&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>A</mi><mo stretchy="true">⏞</mo></mover></mrow><annotation encoding="application/x-tex">\overbrace{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3313em;"></span><span class="mord mover"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.3313em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span><span class="svg-align" style="top:-3.7833em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7 5-6 9-10 13-.7 1-7.3 1-20 1H6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M200428 334c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M400000 542l-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z'/></svg></span></span></span></span></span></span></span></span></span></span></td><td><code>$\overbrace&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munder><mi>A</mi><mo stretchy="true">⏟</mo></munder></mrow><annotation encoding="application/x-tex">\underbrace{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3313em;vertical-align:-0.648em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6833em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMinYMin slice'><path d='M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z'/></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMidYMin slice'><path d='M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z'/></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.548em' viewBox='0 0 400000 548' preserveAspectRatio='xMaxYMin slice'><path d='M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z'/></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span></span></td><td><code>$\underbrace&#123;A&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><mover><mo><mi>b</mi></mo><mi>a</mi></mover></mi></mrow><annotation encoding="application/x-tex">\overset{a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2958em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2958em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop mathnormal">b</span></span></span><span style="top:-3.8944em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span></span></span></span></span></span></span></span></td><td><code>$\overset&#123;a&#125;&#123;b&#125;$</code></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>b</mi></mo><mi>a</mi></munder></mi></mrow><annotation encoding="application/x-tex">\underset{a}{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3944em;vertical-align:-0.7em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span></span></span></span></td><td><code>$\underset&#123;a&#125;&#123;b&#125;$</code></td></tr></tbody></table><h2 id="特殊符号">特殊符号</h2><p>上述内容仅包含一些常用公式及符号，一些不常用的符号可以查找官方文档获取，此处提供一个比较全的LaTeX符号博客：<a href="https://www.oscaner.com/skill/others/mathjax-symbol.html">链接</a>，供大家参考。</p><p>下方展示一些不常用特殊符号：</p><p>无穷大符号：<code>$\infty$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span></p><p>领结符号：<code>$\bowtie$</code><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋈</mo></mrow><annotation encoding="application/x-tex">\bowtie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em;"></span><span class="mrel">⋈</span></span></span></span></p><p>帽：<code>$\hat x$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span></span></span></span></p><p>范数：<code>$\ell_p$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">ℓ</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\ell_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p><p>箭头备注：<code>$\xrightarrow&#123;f&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>f</mi></mpadded></mover></mrow><annotation encoding="application/x-tex">\xrightarrow{f}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='0.522em' viewBox='0 0 400000 522' preserveAspectRatio='xMaxYMin slice'><path d='M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67 151.7 139 205zm0 0v40h399900v-40z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></p><p>上备注：<code>$\overset&#123;def&#125;&#123;=&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo><mover><mo><mo>=</mo></mo><mrow><mi>d</mi><mi>e</mi><mi>f</mi></mrow></mover></mo></mrow><annotation encoding="application/x-tex">\overset{def}{=}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2001em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.2001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.614em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span></p><p>下备注：<code>$\underset&#123;x\in S\subseteq X&#125;&#123;max&#125;$</code></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi><munder><mo><mi>m</mi><mi>a</mi><mi>x</mi></mo><mrow><mi>x</mi><mo>∈</mo><mi>S</mi><mo>⊆</mo><mi>X</mi></mrow></munder></mi></mrow><annotation encoding="application/x-tex">\underset{x\in S\subseteq X}{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2701em;vertical-align:-0.8395em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3557em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mrel mtight">⊆</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">X</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8395em;"><span></span></span></span></span></span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2022/09/08/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/09/08/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、markdown简介">一、markdown简介</h2><p>markdown 是一种轻量级标记语言,能将文本换成有效的XHTML(或者HTML)文档，它的目标是实现易读易写，成为一种适用于网络的书写语言。Markdown 语法简洁明了，易于掌握，所以用它来写作是件既效率又舒服的事情。<br>markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p><h2 id="二、markdown-标题">二、markdown 标题</h2><p>markdown 支持两种标题的语法，类 Setext 和 类 Atx 形式。<br>类 Setext 形式是用底线的形式，利用 <code>=</code>（最高价标题）和 <code>-</code>（第二阶标题），例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is an H1</span><br><span class="line">============</span><br><span class="line"></span><br><span class="line">This is an H2</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。效果如下：</p><h2 id="This-is-an-H1">This is an H1</h2><h2 id="This-is-an-H2">This is an H2</h2><p>类 Atx 形式则是在行首插入1到6个 <code>#</code> ,对应到标题1到6级标题，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h2 id="一级标题">一级标题</h2><h3 id="二级标题">二级标题</h3><h3 id="三级标题">三级标题</h3><h3 id="四级标题">四级标题</h3><h3 id="五级标题">五级标题</h3><h3 id="六级标题">六级标题</h3><h2 id="三、markdown-段落和换行">三、markdown 段落和换行</h2><p>一个 markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。<br>「由一个或多个连续的文本行组成」这句话其实暗示了 markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。<br>如果你确实想要依赖 markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。<br>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。</p><h2 id="四、markdown-列表">四、markdown 列表</h2><p>markdown 支持有序列表和无序列表。</p><h3 id="1-无序列表">1.无序列表</h3><p>无序列表用 <code>*</code>,<code>+</code>或<code>-</code>作为列表标记，语法如下:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* red</span><br><span class="line">* green</span><br><span class="line">* blue</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ red</span><br><span class="line">+ green</span><br><span class="line">+ blue</span><br></pre></td></tr></table></figure><p>也等同于：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- red</span><br><span class="line">- green</span><br><span class="line">- blue</span><br></pre></td></tr></table></figure><p>上面三种方式效果如下: <em>red</em> green * blue</p><h3 id="2-有序列表">2.有序列表</h3><p>有序列表则使用数字接着一个英文句点：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Bird</span><br><span class="line">2. McHale</span><br><span class="line">3. Parish</span><br></pre></td></tr></table></figure><p>效果如下： 1. Bird 2. McHale 3. Parish</p><h2 id="五、markdown-代码区块">五、markdown 代码区块</h2><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块， 通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示， markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。<br>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以， 例如，下面的输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个代码区块</span><br><span class="line">一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</span><br></pre></td></tr></table></figure><p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 markdown 都会帮你处理，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">        &amp;copy; 2004 Foo Corporation</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;</span><br><span class="line">    &amp;amp;copy; 2004 Foo Corporation</span><br><span class="line">&amp;lt;/div&amp;gt;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>代码区块中，一般的 markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 markdown 语法撰写 markdown 语法相关的文件。</p><h2 id="六、markdown-分割线">六、markdown 分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">******</span><br><span class="line">- - -</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><hr><hr><h2 id="七、markdown-链接">七、markdown 链接</h2><p>markdown 支持两种形式的链接语法： 行内式和参考式两种形式。<br>不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [an example](http://bing.com/ &quot;Title&quot;) inline link.</span><br><span class="line"></span><br><span class="line">[This link](http://bing.com/) has no title attribute.</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>This is <a href="https://link.zhihu.com/?target=http%3A//bing.com/">an example</a> inline link.</p><p><a href="https://link.zhihu.com/?target=http%3A//bing.com/">This link</a> has no title attribute.</p><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li></ul><p>下面这三种链接的定义都是相同：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[foo]: http://bing.com/  &quot;Optional Title Here&quot;</span><br><span class="line">[foo]: http://bing.com/  &#x27;Optional Title Here&#x27;</span><br><span class="line">[foo]: http://bing.com/  (Optional Title Here)</span><br></pre></td></tr></table></figure><p>链接网址也可以用尖括号包起来：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[id]: http://example.com/longish/path/to/resource/here</span><br><span class="line">    &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p><p>链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[link text][a]</span><br><span class="line">[link text][A]</span><br></pre></td></tr></table></figure><p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 <a href="https://link.zhihu.com/?target=http%3A//google.com">http://google.com</a>，你可以简化成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google][]</span><br></pre></td></tr></table></figure><p>然后定义链接内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google]: http://google.com/</span><br></pre></td></tr></table></figure><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>下面是一个参考式链接的范例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><p>如果改成用链接名称的方式写：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google][] than from</span><br><span class="line">[Yahoo][] or [MSN][].</span><br><span class="line"></span><br><span class="line">  [google]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><p>上面两种写法都会产生下面的 HTML。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I get 10 times more traffic from <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://google.com/&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;external nofollow&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">title</span>=<span class="string">&quot;Google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span> than from</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://search.yahoo.com/&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;external nofollow&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;Yahoo Search&quot;</span>&gt;</span>Yahoo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">or <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://search.msn.com/&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;external nofollow&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;MSN Search&quot;</span>&gt;</span>MSN<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是用行内式写的同样一段内容的 markdown 文件，提供作为比较之用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)</span><br><span class="line">than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or</span><br><span class="line">[MSN](http://search.msn.com/ &quot;MSN Search&quot;).</span><br></pre></td></tr></table></figure><p>使用 markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p><h2 id="八、markdown-强调">八、markdown 强调</h2><p>markdown 使用星号 <code>*</code> 和底线 <code>_</code> 作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line"></span><br><span class="line">_single underscores_</span><br><span class="line"></span><br><span class="line">**double asterisks**</span><br><span class="line"></span><br><span class="line">__double underscores__</span><br></pre></td></tr></table></figure><p>会转成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>single asterisks<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>single underscores<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>double asterisks<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>double underscores<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果入下：</p><p><em>single asterisks</em></p><p><em>single underscores</em></p><p><strong>double asterisks</strong></p><p><strong>double underscores</strong></p><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p><p>强调也可以直接插在文字中间：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">un*frigging*believable</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>un<em>frigging</em>believable</p><p>但是如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号。</p><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*this text is surrounded by literal asterisks\*</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><em>this text is surrounded by literal asterisks</em></p><h2 id="九、markdown-代码">九、markdown 代码</h2><p>如果要标记一小段行内代码，你可以用反引号把它包起来 <code>(</code>)` ，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use the `printf()` function.</span><br></pre></td></tr></table></figure><h2 id="十、markdown-图片">十、markdown 图片</h2><p>markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。<br>行内式的图片语法看起来像是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](/path/to/img.jpg)</span><br><span class="line"></span><br><span class="line">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure><p>详细叙述如下： <em>一个惊叹号 !</em> 接着一个方括号，里面放上图片的替代文字 * 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</p><p>参考式的图片语法则长得像这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][id]</span><br></pre></td></tr></table></figure><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: url/to/image  &quot;Optional title attribute&quot;</span><br></pre></td></tr></table></figure><p>到目前为止， markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><p><a href="https://zhuanlan.zhihu.com/p/359357509">原文链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>首篇博客</title>
      <link href="/2022/09/08/%E9%A6%96%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/09/08/%E9%A6%96%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>初次书写博客，请多指教。</p><h1>联系方式：</h1><p>QQ: <strong>1005741898</strong></p><p>电话：13662644116</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/06/hello-world/"/>
      <url>/2022/09/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
